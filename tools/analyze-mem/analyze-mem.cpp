/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#include <iostream>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <string>
#include <unordered_map>
#include <vector>
#include <algorithm>
#include <cassert>
#include <unistd.h>
#include "ruts/util.h"

using namespace std;


string as_mem(double size) {
  string suffix = "bytes";
  if (size > 1024) {
    size /= 1024;
    suffix = "kB";
  }
  if (size > 1024) {
    size /= 1024;
    suffix = "MB";
  }
  if (size > 1024) {
    size /= 1024;
    suffix = "GB";
  }
  if (size > 1024) {
    size /= 1024;
    suffix = "TB";
  }
  return ruts::format([&](auto &out) {
      out << fixed << setprecision(2) << size << " " << suffix;
    });
}

struct alloc {
  size_t n_marked = 0;
  size_t words_marked = 0;
  size_t n_unmarked = 0;
  size_t words_unmarked = 0;

  void marked(size_t w) {
    n_marked++;
    words_marked += w;
  }
  void unmarked(size_t w) {
    n_unmarked++;
    words_unmarked += w;
  }
};

template <typename C, typename T>
auto &operator <<(basic_ostream<C,T> &out, alloc a) {
  out << as_mem(a.words_marked*8)
      << " (" << ruts::comma_sep(a.n_marked)
      << " * " << a.words_marked/a.n_marked
      << ")";
  if (a.n_unmarked > 0) {
    out << " unmarked: "
        << as_mem(a.words_unmarked*8)
        << " (" << ruts::comma_sep(a.n_unmarked)
        << " * " << a.words_marked/a.n_unmarked
        << ")";
  }
  return out;
}

using map_type = unordered_map<string, alloc>;

map_type allocations;

enum class operation { ALLOCATED, COLLECTED, MARKED };

template <typename C, typename T>
auto &operator >>(basic_istream<C,T> &in, operation &o) {
  string s;
  in >> s;
  if (s == "collected") {
    o = operation::COLLECTED;
  } else if (s == "allocated") {
    o = operation::ALLOCATED;
  } else if (s == "marked") {
    o = operation::MARKED;
  } else {
    cerr << "Unknown operation: '" << s << "'" << endl;
    abort();
  }
  return in;
}

template <typename C, typename T>
auto &operator <<(basic_ostream<C,T> &out, operation o) {
  switch (o) {
  case operation::COLLECTED:
    return out << "COLLECTED";
  case operation::ALLOCATED:
    return out << "ALLOCATED";
  case operation::MARKED:
    return out << "MARKED";
  default:
    assert(false);
    return out;
  }
}


// string demangle(const string &mangled) {
//   static once_flag once;
//   static int parent_to_child[2];
//   static int child_pid;
//   call_once(once, [&]{
//       int child_to_parent[2];
//       pipe(parent_to_child);
//       pipe(child_to_parent);
//       child_pid = fork();
//       if (child_pid == 0) {
//         // In the child
//         close(parent_to_child[1]);
//         close(child_to_parent[0]);
//         dup2(parent_to_child[0], STDIN_FILENO);
//         dup2(child_to_parent[1], STDOUT_FILENO);
//         execl("/usr/bin/c++filt", (char*)0);
//       }
//       close(parent_to_child[0]);
//       close(child_to_parent[1]);
      
//     });
  
// }

vector<pair<string,string>> markings;


struct trace {
  string addr;
  string stamp;
  size_t words;
  operation op;
  string type;

  void follows(const trace &prior) {
    switch (op) {
    case operation::ALLOCATED:
      {
        if (prior.op == operation::ALLOCATED) {
          if (prior.addr == addr) {
            cerr << "Allocation without collection at " << addr
                 << " (" << as_mem(words) << ")"
                 << endl;
          } else {
            allocations[prior.type].unmarked(prior.words);
          }
        }
        return;
      }
    case operation::COLLECTED:
      {
        if (prior.op != operation::ALLOCATED || prior.addr != addr) {
          cerr << "Collected unallocated obj at " << addr
               << " (" << as_mem(words) << ")"
               << endl;
        }
        return;
      }
    case operation::MARKED:
      {
        if (prior.op != operation::ALLOCATED || prior.addr != addr) {
          cerr << "Marked unallocated obj at " << addr
               << " (" << as_mem(words) << ")"
               << endl;
          allocations["UNKNOWN"].marked(words);
          // markings.emplace_back(stamp, addr+" UNKNOWN");
          markings.emplace_back(stamp, "UNKNOWN / 0x"+addr);
          return;
        }
        // markings.emplace_back(stamp, addr+" "+demangle(prior.type));
        markings.emplace_back(stamp, prior.type+" / 0x"+addr);
        allocations[prior.type].marked(words);
        return;
      }
    default:
      {
        assert(false);
      }
      
    }
  }
};

template <typename C, typename T>
auto &operator >>(basic_istream<C,T> &in, trace &ln) {
  in >> ln.addr >> ln.stamp >> ln.words >> ln.op;
  if (ln.op == operation::ALLOCATED) {
    in >> ln.type;
  }
  return in;
}

int main(int argc, char **argv) {
  string line;
  trace prior;
  

  while (getline(cin, line)) {
    // if (n++ > 100000) {
    //   break;
    // }
    istringstream in(line);
    trace current;

    in >> current;
    current.follows(prior);
    prior = current;
  }

  vector<pair<string, alloc>> v(allocations.begin(), allocations.end());
  sort(v.begin(), v.end(),
       [](const auto &a, const auto &b) {
         if (a.second.words_marked > b.second.words_marked) {
           return true;
         } else if (a.second.words_marked < b.second.words_marked) {
           return false;
         } else if (a.second.n_marked > b.second.n_marked) {
           return true;
         } else if (a.second.n_marked < b.second.n_marked) {
           return false;
         } else if (a.second.words_unmarked > b.second.words_unmarked) {
           return true;
         } else if (a.second.words_unmarked < b.second.words_unmarked) {
           return false;
         } else if (a.second.n_unmarked > b.second.n_unmarked) {
           return true;
         } else if (a.second.n_unmarked < b.second.n_unmarked) {
           return false;
         } else {
           return a.first < b.first;
         }
       });

  size_t total_n_marked = 0;
  size_t total_w_marked = 0;
  size_t total_n_unmarked = 0;
  size_t total_w_unmarked = 0;
  for (const auto &p : v) {
    total_n_marked += p.second.n_marked;
    total_w_marked += p.second.words_marked;
    total_n_unmarked += p.second.n_unmarked;
    total_w_unmarked += p.second.words_unmarked;
  }

  cout << "MARKED : " << as_mem(total_w_marked*8)
       << " (" << ruts::comma_sep(total_n_marked) << ")"
       << endl;
  cout << "UNMARKED : " << as_mem(total_w_unmarked*8)
       << " (" << ruts::comma_sep(total_n_unmarked) << ")"
       << endl;
  
  for (const auto &p : v) {
    cout << p.first << " : " << p.second << endl;
  }

  sort(markings.begin(), markings.end());
  ofstream mout("mark-sequence");
  for (const auto &p : markings) {
    mout << p.second << endl;
  }
  

  return 0;
}
