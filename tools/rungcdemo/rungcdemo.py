#!/usr/bin/env python3
##
#
#  Multi Process Garbage Collector
#  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU Lesser General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU Lesser General Public License for more details.
#
#  You should have received a copy of the GNU Lesser General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#  As an exception, the copyright holders of this Library grant you permission
#  to (i) compile an Application with the Library, and (ii) distribute the 
#  Application containing code generated by the Library and added to the 
#  Application during this compilation process under terms of your choice, 
#  provided you also meet the terms and conditions of the Application license.
#


#
# rungcdemo.py
#
#  Created on: July 28, 2016
#      Author: uversky
#
import argparse
import subprocess
import sys

def parse_args(arg_v=None):
    class Arg:
        def __init__(self, flag, help_str, dest, argtype=None, action='store', default=None):
            self.flag = flag
            self.help = help_str
            self.dest = dest
            self.type = argtype
            self.action = action
            self.default = default

    parser_desc_ = 'Run the social network application that demonstrates MPGC.'
    args = [
        Arg('-b', 'Runs the application in benchmark mode.',
            'benchmark', action='store_true'),
        Arg('-d', 'Prints additional debug info (memstats(), during execution.',
            'debug', action='store_true'),
        Arg('-f', 'Removes any existing graph under the same name in the persistent heap without a prompt.',
            'forceClear', action='store_true'),
        Arg('-i', 'Specifies the number of iterations of posts/comments to run across all worker threads.',
            'iters', argtype=int, default=10000),
        Arg('-k', 'Runs `pkill -9 -x gcdemo` to kill any running worker processes.',
            'kill', action='store_true'),
        Arg('-l', 'Specifies the maximum length of the user\'s feed.',
            'feedLength', argtype=int, default=200),
        Arg('-mc', 'Sets the mean number of new users tagged in a post when commenting.',
            'meanNumCommentTags', argtype=float, default=1.0),
        Arg('-mf', 'Specifies the mean number of friends per user (drawn from an exponential distribution).',
            'meanNumFriends', argtype=int, default=200),
        Arg('-mp', 'Sets the mean number of friends tagged in a new post.',
            'meanNumPostTags', argtype=float, default=3.0),
        Arg('-n', 'Sets the name of the graph in the persistent heap.',
            'name', argtype=str, default='com.hpe.gcdemo.users'),
        Arg('-p', 'Sets the number of worker processes to spawn.',
            'numProcesses', argtype=int, default=1),
        Arg('-pc', 'Sets the proportion between posts and comments.  1 is all posts, 0 is all comments.',
            'postCommentProportion', argtype=float, default=0.6),
        Arg('-s', 'Skips graph initialization process (persistent counters are still cleared).',
            'skipInit', action='store_true'),
        Arg('-t', 'Sets the number of worker threads per process to NUM_THREADS.',
            'numThreads', argtype=int, default=1),
        Arg('-u', 'Sets the number of users used when generating the graph.',
            'users', argtype=int, default=1000000),
        Arg('-w', 'Specifies the ideal work rate (# iterations/sec) for the worker processes.',
            'idealWorkRate', argtype=int, default=100)
    ]

    parser = argparse.ArgumentParser(description=parser_desc_, formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    for a in args:
        if a.action == 'store_true':
            parser.add_argument(a.flag, help=a.help, action=a.action, dest=a.dest)
        else:
            parser.add_argument(a.flag, help=a.help, type=a.type, default=a.default, dest=a.dest)
    return parser, parser.parse_args(arg_v)


def arg_values_correct(args):
    correct = False
    if args.iters <= 0:
        print("Number of iterations must be a positive integer.")
    elif args.feedLength <= 0:
        print("Feed length must be a positive integer.")
    elif args.meanNumCommentTags <= 0:
        print("Mean number of tags/comment must be positive.")
    elif args.meanNumFriends <= 0:
        print("Mean number of friends per user must be a positive integer.")
    elif args.meanNumPostTags <= 0:
        print("Mean number of tags/post must be positive.")
    elif args.numProcesses <= 0 or args.numThreads <= 0:
        print("Number of processes and threads must be positive integers.")
    elif args.postCommentProportion < 0 or args.postCommentProportion > 1:
        print("Proportion of posts to comments must be between [0,1] inclusive.")
    elif args.users <= 0:
        print("Number of users must be a positive integer.")
    elif args.idealWorkRate <= 0:
        print("Ideal work rate must be a positive integer.")
    else:
        correct = True
    return correct


def main():
    (parser, args) = parse_args(sys.argv[1:])
    if not arg_values_correct(args):
        print()
        parser.print_help()
        sys.exit(1)

    if args.kill:
        # Kill running processes
        print("Killing running clients...", end='')
        killstr = "pkill -9 -x gcdemo"
        p = subprocess.Popen(killstr.split())
        p.wait()
        print("Done.")

    # Clean old log directory
    cleanlogstrs = ["mkdir -p outlog", "rm -f outlog/*"]
    print("Cleaning outlog directory...", end='')
    for s in cleanlogstrs:
        p = subprocess.Popen(s.split())
        p.wait()
    print("Done.")
    print('========================================')
    sys.stdout.flush()

    initStr = "./gcdemo-init" + \
             (" -f" if args.forceClear else "") + \
              " -i " + str(args.iters) + \
              " -l " + str(args.feedLength) + \
              " -m " + str(args.meanNumFriends) + \
              " -n " + args.name + \
             (" -s" if args.skipInit else "") + \
              " -t " + str(args.numProcesses * args.numThreads) + \
              " -u " + str(args.users)

    procStr = "./gcdemo" + \
             (" -b" if args.benchmark else "") + \
              " -C " + str(args.meanNumCommentTags) + \
             (" -d" if args.debug else "") + \
              " -i " + str(args.iters) + \
              " -n " + args.name + \
              " -P " + str(args.meanNumPostTags) + \
              " -r " + str(args.postCommentProportion) + \
              " -t " + str(args.numThreads) + \
              " -w " + str(args.idealWorkRate)

    # Run the init process
    print("Launching initialization process.")
    print("--------------------")
    print(initStr)
    initProc = subprocess.Popen(initStr.split())
    initProc.wait()
    sys.stdout.flush()
    print()
    print('========================================')
    print("Launching client processes.")
    print("--------------------")
    print("Initializing", args.numProcesses, "social network clients with the following parameters:")
    print("  Graph name in pheap:         ", args.name)
    print("  Number of threads:           ", args.numThreads)
    print("  Post-comment proportion:     ", args.postCommentProportion)
    print("  Number of total iterations:  ", args.iters)
    print("  Mean number of tags/post:    ", args.meanNumPostTags)
    print("  Mean number of tags/comment: ", args.meanNumCommentTags)
    print("  Ideal work rate (txns/sec):  ", args.idealWorkRate)
    print("  Benchmark mode:              ", "ON" if args.benchmark else "OFF")
    print("  Debug mode:                  ", "ON" if args.debug else "OFF")
    print()
    print(procStr)
    sys.stdout.flush()

    workers = []
    for i in range(args.numProcesses):
        workers.append(subprocess.Popen(procStr.split()))
    for w in workers:
        w.wait()
    sys.stdout.flush()

    sys.exit(0)

if __name__ == '__main__':
    main()
