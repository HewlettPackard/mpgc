/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#include<getopt.h>
#include<unistd.h>
#include<fcntl.h>
#include<sys/types.h>
#include<sys/stat.h>

#include <iostream>
#include <cstdlib>
#include <cassert>
#include <regex>

#include "mpgc/gc.h"

using namespace std;

/*namespace mpgc {
 class mark_bitmap;
 class gc_allocator;
 extern std::size_t mark_bitmap::compute_total_bitmap_size(const std::size_t);
 extern std::size_t gc_allocator::align_size_up(std::size_t, std::size_t);
}*/

void show_usage() {
   std::cerr << "usage: ./createheap [options] <size>\n\n"
             << "Creates a GC heap file of given size (in GB). Also creates control heap file.\n\n"
             << "Options:\n"
             << "-s, --ctrl-size <size>\t Create a control heap of given size (in GB). Default: computed automatically.\n"
             << "-f, --heap-path <path>\t Create GC heap file at path. Default: heaps/gc_heap\n"
             << "-c, --ctrl-path <path>\t Create control heap file at path. Default: heaps/managed_heap\n"
             << "-h, --help\t\t Display this message.\n";
}

std::size_t compute_ctrl_size(const std::size_t heapsize) {
  std::size_t size = mpgc::mark_bitmap::compute_total_bitmap_size(heapsize);
  //Round-up to next GB.
  size = mpgc::gc_allocator::align_size_up(size, 1 << 30);
  return size + (1 << 30); //Extra 1GB for GC usage like queues, allocator etc.
}

size_t parse_mem_size(const string &s)
{
  static regex r("([0-9]+(?:\\.[0-9]*)?) *([KMGT]B?)?",
                 regex::icase);
  smatch m;
  if (!regex_match(s.begin(), s.end(), m, r)) {
    cerr << "Can't parse memory size: '" << s << "'" << endl;
    abort();
  }
  double n = stod(m[1]);
  size_t shift = 30;
  if (m[2].matched) {
    switch (m[2].str()[0]) {
    case 'k':
    case 'K':
      shift = 10;
      break;
    case 'm':
    case 'M':
      shift = 20;
      break;
    case 'g':
    case 'G':
      shift = 30;
      break;
    case 't':
    case 'T':
      shift = 40;
      break;
    default:
      assert(false);
    }
  }
  size_t size = n*(1UL<<shift);
  return size;
}

void make_file(const string &name,
               size_t size,
               const string &desc)
{
  string command = "mkdir -p " + name.substr(0, name.find_last_of('/'));
  system(command.c_str());

  int fd = open(name.c_str(), O_TRUNC | O_CREAT | O_WRONLY, S_IRUSR | S_IWUSR);
  assert(fd != -1);
  if (ftruncate(fd, size)) {
    cerr << desc << " (" << name << ") truncation failed: " << errno << "\n";
    abort();
  }
  close(fd);
}

int main(int argc, char **argv) {
  struct option long_options[] = {
           {"help",       no_argument,       0, 'h'},
           {"ctrl-path",  required_argument, 0, 'c'},
           {"heap-path",  required_argument, 0, 'f'},
           {"ctrl-size",  required_argument, 0, 's'},
           {0,            0,                 0,  0 }
    };

  std::string ctrl_file = "heaps/managed_heap";
  std::string heap_file = "heaps/gc_heap";

  std::size_t ctrl_size = 0;
  std::size_t heap_size;

  while (true) {
    int c = getopt_long(argc, argv, "hc:f:s:", long_options, nullptr);

    if (c == -1) {
      break;
    }

    switch(c) {
      case 'h': show_usage();
                return 0;

      case 'c': ctrl_file = optarg;
                break;
                
      case 'f': heap_file = optarg;
                break;

      case 's': ctrl_size = parse_mem_size(optarg);
                break;

      case '?': show_usage();
                return -1;
    }
  }

  if (optind >= argc) {
    std::cout << "Heap size not specified.\n\n";
    show_usage();
    return -1;
  } else {
    heap_size = parse_mem_size(argv[optind]);
  }

  std::size_t computed_ctrl_size = compute_ctrl_size(heap_size);

  if (ctrl_size < computed_ctrl_size) {
    ctrl_size = computed_ctrl_size;
  }

  make_file(heap_file, heap_size, "GC heap file");
  setenv("MPGC_GC_HEAP", heap_file.c_str(), 1);

  make_file(ctrl_file, ctrl_size, "Control file");
  setenv("MPGC_CONTROL_HEAP", ctrl_file.c_str(), 1);

  mpgc::init_on_createheap();

  unsetenv("MPGC_GC_HEAP");
  unsetenv("MPGC_CONTROL_HEAP");

  return 0;
}
