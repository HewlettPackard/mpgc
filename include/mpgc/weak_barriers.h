/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#ifndef WEAK_BARRIERS_H
#define WEAK_BARRIERS_H

namespace mpgc {
  template<typename T> template<typename LoadFn, typename ModFn>
  void weak_gc_ptr<T>::write_barrier(const void *loc,
                                     LoadFn&& load_func,
                                     ModFn&& mod_func) noexcept {
    constexpr auto stage_bits_fld = bits::field<Weak_stage, uint16_t>(0, 2);
    gc_handshake::in_memory_thread_struct &thread_struct =
                                 *gc_handshake::thread_struct_handles.handle;
    gc_control_block &cb = control_block();

    thread_struct.weak_signal = gc_handshake::Weak_signal::InBarrier;
    offset_ptr<T> r = std::forward<LoadFn>(load_func)();
    Weak_stage s = stage_bits_fld.decode(cb.weak_stage);
    switch (s) {
      case Weak_stage::Normal:
        break;
      case Weak_stage::Trace:
      case Weak_stage::Repeat:
        if (!base_offset_ptr::is_valid(loc)) {
          break;
        }
      case Weak_stage::Clean:
        if (!cb.bitmap.is_marked(r, true)) {
          if (s == Weak_stage::Clean) {
            r = nullptr;
          } else {
            cb.bitmap.mark_weak((std::size_t*)loc);
          }
        }
    }
    std::forward<ModFn>(mod_func)(r);
    thread_struct.weak_signal = gc_handshake::Weak_signal::Working;
  }

  template<typename T>
  gc_ptr<T> weak_gc_ptr<T>::lock() const noexcept {
    gc_handshake::in_memory_thread_struct &thread_struct = *gc_handshake::thread_struct_handles.handle;
    gc_control_block &cb = control_block();
    per_process_struct &proc = *gc_handshake::process_struct;

    //constexpr auto version_bits_fld = bits::field<uint16_t, uint16_t>(2, 14);
    constexpr auto stage_bits_fld = bits::field<Weak_stage, uint16_t>(0, 2);
    constexpr auto state_bits_fld = bits::field<gc_mutator_weak_sync_state, uint16_t>(0, 1);
    constexpr auto nr_thread_bits_fld = bits::field<uint16_t, uint16_t>(1, 15);
    constexpr auto ptr_type_fld = bits::field<special_ptr_type, std::size_t>(0, 2);

    bool done = false;

    offset_ptr<T> r(ptr_type_fld.replace(_ptr.val(), special_ptr_type::Strong));
    if (!r.is_valid()) {
      return gc_ptr<T>::from_offset_ptr(r);
    }
    /* The following signal fence is required to ensure that the read of offset_ptr
     * above takes place before read of signal below in the if condition, as we
     * might get a signal in between.
     */
    std::atomic_signal_fence(std::memory_order_release);

    gc_handshake::Signum sig = thread_struct.status_idx.load().status();
    if (sig == gc_handshake::Signum::sigSync1 || sig == gc_handshake::Signum::sigSync2) {
      return gc_ptr<T>::from_offset_ptr(r);
    }

    do {
      thread_struct.weak_signal = gc_handshake::Weak_signal::InBarrier;
      r.set_val(ptr_type_fld.replace(_ptr.val(), special_ptr_type::Strong));
      if (!r.is_valid()) {
        break;
      }
      uint16_t expected_stage = cb.weak_stage;
      Weak_stage s = stage_bits_fld.decode(expected_stage);
      if (s == Weak_stage::Normal || thread_struct.bitmap->is_marked(r)) {
        done = true;
      } else {
        switch (s) {
          case Weak_stage::Clean:
            r = nullptr;
          case Weak_stage::Normal:
            done = true;
            break;
          case Weak_stage::Trace:
            {//First try to acquire process-local lock.
              uint16_t expected = proc.gc_mutator_weak_sync;
              while (state_bits_fld.decode(expected) == gc_mutator_weak_sync_state::Work) {
                if (proc.gc_mutator_weak_sync.compare_exchange_weak(expected,
                                                                    nr_thread_bits_fld.replace(expected,
                                                                                             nr_thread_bits_fld.decode(expected) + 1))) {
                  //We got the process-local lock.
                  thread_struct.persist_data->mbuf.add_element(r);
                  /*
                   * Here we are certain that the sync is in <i, Work> state with i > 1.
                   * So we can use fetch_sub, instead of cas, to decrement thread count.
                   * The decrement needs to be of 2 not 1 as the lsb is state flag.
                   */
                  proc.gc_mutator_weak_sync.fetch_sub(2);
                  done = true;
                  break;
                }
              }
            }
            /*
             * Couldn't do the marking through process-local mechanism above. Lets try the
             * global weak stage now.
             */
            if (done || !cb.weak_stage.compare_exchange_strong(expected_stage,
                                                               stage_bits_fld.replace(expected_stage, Weak_stage::Repeat))) {
              break;
            }
          case Weak_stage::Repeat:
            thread_struct.persist_data->mbuf.add_element(r);
            done = true;
        }
      }
    } while (!done);
    thread_struct.weak_signal = gc_handshake::Weak_signal::Working;
    assert(r.is_null() || r->get_gc_descriptor().is_valid());
    return gc_ptr<T>::from_offset_ptr(r);
  }
}

#endif //WEAK_BARRIERS_H
