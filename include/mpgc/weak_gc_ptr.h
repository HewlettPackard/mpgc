/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#ifndef WEAK_GC_PTR_H
#define WEAK_GC_PTR_H

#include "mpgc/offset_ptr.h"

namespace mpgc {
  /*
   * As an initial dummy implementation, a weak_gc_ptr will just
   * include a gc_ptr.
   */
  template <typename T>
  class weak_gc_ptr {
    template <typename U> friend class weak_gc_ptr;
    offset_ptr<T> _ptr;

    offset_ptr<T> from_strong_to_weak(const offset_ptr<T> &rhs) {
      constexpr auto ptr_type_fld = bits::field<special_ptr_type, std::size_t>(0, 2);
      return rhs.is_null() ? offset_ptr<T>(nullptr) :
                             offset_ptr<T>(rhs.val() | ptr_type_fld.encode(special_ptr_type::Weak));
    }

    template <typename Y, typename = std::enable_if_t<std::is_assignable<T*&,Y*>::value> >
    void write_barrier(const weak_gc_ptr<Y>&) noexcept;

  public:
    using element_type = T;

    constexpr weak_gc_ptr() noexcept : _ptr{nullptr} {}
    constexpr weak_gc_ptr(std::nullptr_t) noexcept : weak_gc_ptr{} {}

    weak_gc_ptr(const weak_gc_ptr &rhs) noexcept {
      write_barrier(rhs);
    }
    weak_gc_ptr(weak_gc_ptr &&rhs) noexcept {
      write_barrier(std::move(rhs));
    }
    weak_gc_ptr &operator =(const weak_gc_ptr &rhs) noexcept {
      write_barrier(rhs);
      return *this;
    }
    weak_gc_ptr &operator =(weak_gc_ptr &&rhs) noexcept {
      write_barrier(std::move(rhs));
      return *this;
    }

    template <typename Y, typename = std::enable_if_t<std::is_assignable<T*&,Y*>::value> >
    weak_gc_ptr(const weak_gc_ptr<Y> &rhs) noexcept {
      write_barrier(rhs);
    }
    template <typename Y, typename = std::enable_if_t<std::is_assignable<T*&,Y*>::value> >
    weak_gc_ptr(weak_gc_ptr<Y> &&rhs) noexcept {
      write_barrier(std::move(rhs));
    }
    template <typename Y, typename = std::enable_if_t<std::is_assignable<T*&,Y*>::value> >
    weak_gc_ptr(const gc_ptr<Y> &rhs) noexcept : _ptr{from_strong_to_weak(rhs.as_offset_pointer())} {}

    template <typename Y, typename = std::enable_if_t<std::is_assignable<T*&,Y*>::value> >
    weak_gc_ptr(gc_ptr<Y> &&rhs) noexcept : _ptr{from_strong_to_weak(std::move(rhs.as_offset_pointer()))} {}

    template <typename Y, typename = std::enable_if_t<std::is_assignable<T*&,Y*>::value> >
    weak_gc_ptr(const external_gc_ptr<Y> &rhs) noexcept : weak_gc_ptr{rhs.value()} {}

    template <typename Y, typename = std::enable_if_t<std::is_assignable<T*&,Y*>::value> >
    weak_gc_ptr(external_gc_ptr<Y> &&rhs) noexcept : weak_gc_ptr{std::move(rhs.value())} {}

    weak_gc_ptr &operator =(nullptr_t) noexcept {
      _ptr = nullptr;
      return *this;
    }

    template <typename Y, typename = std::enable_if_t<std::is_assignable<T*&,Y*>::value> >
    weak_gc_ptr &operator =(const weak_gc_ptr<Y> &rhs) noexcept {
      write_barrier(rhs);
      return *this;
    }

    template <typename Y, typename = std::enable_if_t<std::is_assignable<T*&,Y*>::value> >
    weak_gc_ptr &operator =(weak_gc_ptr<Y> &&rhs) noexcept {
      write_barrier(std::move(rhs));
      return *this;
    }

    template <typename Y, typename = std::enable_if_t<std::is_assignable<T*&,Y*>::value> >
    weak_gc_ptr &operator =(const gc_ptr<Y> &rhs) noexcept  {
      _ptr = from_strong_to_weak(rhs.as_offset_pointer());
      return *this;
    }

    template <typename Y, typename = std::enable_if_t<std::is_assignable<T*&,Y*>::value> >
    weak_gc_ptr &operator =(gc_ptr<Y> &&rhs) noexcept {
      _ptr = from_strong_to_weak(std::move(rhs.as_offset_pointer()));
      return *this;
    }

    template <typename Y, typename = std::enable_if_t<std::is_assignable<T*&,Y*>::value> >
    weak_gc_ptr &operator =(const external_gc_ptr<Y> &rhs) noexcept {
      *this = rhs.value();
      return *this;
    }

    template <typename Y, typename = std::enable_if_t<std::is_assignable<T*&,Y*>::value> >
    weak_gc_ptr &operator =(external_gc_ptr<Y> &&rhs) noexcept {
      *this = std::move(rhs.value());
      return *this;
    }

    gc_ptr<T> lock() const noexcept;

    bool expired() const noexcept {
      return _ptr == nullptr;
    }

    void reset() {
      _ptr = nullptr;
    }

    void swap(weak_gc_ptr &r) {
      weak_gc_ptr temp = r;
      r = std::move(*this);
      *this = std::move(temp);
    }
  };
}

namespace std {
  template <typename T>
  inline
  void swap(mpgc::weak_gc_ptr<T> &lhs, mpgc::weak_gc_ptr<T> &rhs) {
    lhs.swap(rhs);
  }

  template <typename C, typename T, typename X>
  basic_ostream<C,T> &
  operator <<(basic_ostream<C,T> &os, const mpgc::weak_gc_ptr<X> &ptr) {
    // We get rid of the lock as soon as we can.
    auto op = ptr.lock().as_offset_pointer();
    return os << op;
  }

}

#endif
