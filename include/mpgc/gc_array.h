/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#ifndef GC_ARRAY_H
#define GC_ARRAY_H

#include <type_traits>
#include <utility>
#include <iterator>
#include <memory>
#include <stdexcept>
#include <algorithm>
#include "mpgc/gc_allocated.h"

namespace mpgc {


  

  class gc_array_access_ex {};


  /*
   * Holds the size.  Needed for by gc_descriptor for casting.
   *
   * Note that gc_array_base and gc_array don't have descriptors
   * themselves.  gc_array gets its descriptor from the element type
   * (with the array bit set), and gc_array_base's constructor is
   * protected.
   */
  class gc_array_base : public gc_allocated {
  public:
    using size_type = std::size_t;
  private:
    const size_type _size;
  protected:
    explicit gc_array_base(gc_token &gc, size_type s) 
      : gc_allocated{gc}, _size{s} 
    {}
  public:
    bool empty() const {
      return _size==0;
    }
    size_type size() const {
      return _size;
    }
  };

  template <typename T>
  class gc_array : public gc_array_base {
  public:
    using arg_type = T;
    constexpr static bool holds_direct_values = !std::is_base_of<gc_allocated, T>::value;
    using value_type = std::conditional_t<holds_direct_values,T,gc_ptr<T>>;
    using size_type = gc_array_base::size_type;
    using difference_type = std::ptrdiff_t;
private:
public:
    template <bool IsConst>
    class iter_ {
    public:
      constexpr static bool is_const = IsConst;
      using value_type = std::conditional_t<is_const, const gc_array::value_type, gc_array::value_type>;
      using reference = value_type &;
      // We allow indexes to be negative for intermediate values
      using index_type = std::ptrdiff_t;
      using difference_type = std::ptrdiff_t;
      using iterator_category = std::random_access_iterator_tag;
      //using pointer = offset_ptr<value_type>;
      using pointer = value_type *;
    private:
      // TODO: Why isn't this a conditional type?
      gc_ptr<const gc_array<T>> _array;
      index_type _index;
      iter_(const gc_ptr<const gc_array<T>> &ap, index_type i)
      : _array{ap}, _index{i}
      {}
      friend class gc_array;
      void check_valid() const {
      }
      pointer ptr(index_type i) const {
        assert(_array != nullptr
               && i >= 0
               && i <= static_cast<difference_type>(_array.size()));
	using gvt = gc_array::value_type;
	gvt *ptr_to_first = const_cast<gvt *>(&_array->_first_value);
        return ptr_to_first + i;
      }
      pointer ptr() const {
        return ptr(_index);
      }
    public:
      iter_() : _index{0} {}
      iter_(nullptr_t) : _index{0} {}
      iter_(const iter_ &) = default;
      iter_(iter_ &&) = default;
      /* A const iter can be constructed from a non-const iter */
      template <bool B = is_const, typename E=std::enable_if_t<B> >
      iter_(const iter_<false> &other)
      : _array{other._array},_index{other._index}
      {}
      template <bool B = is_const, typename E=std::enable_if_t<B> >
      iter_(iter_<false> &&other)
      : _array{std::move(other._array)}, _index{std::move(other._index)}
      {}

      static const auto &descriptor() {
	static gc_descriptor d =
	  GC_DESC(iter_)
	  .template WITH_FIELD(&iter_::_array)
          .template WITH_FIELD(&iter_::_index);
        return d;
      }
      iter_ &operator =(const iter_ &) = default;
      iter_ &operator =(iter_ &&) = default;
      /* A const iter can be constructed from a non-const iter */
      template <bool  B = is_const, typename E=std::enable_if_t<B> >
      iter_ &operator =(const iter_<false> &other)
      {
        _array = other._array;
        _index = other._index;
        return *this;
      }

      template <bool B = is_const, typename E=std::enable_if_t<B> >
      iter_&operator =(iter_<false> &&other) {
        _array = std::move(other._array);
        _index = std::move(other._index);
        return *this;
      }


      pointer operator ->() const {
        return ptr();
      }
      reference operator *() const {
        return *ptr();
      }

      /*
       * This pointer should only be used while you're holding onto the iterator.
       */
      
      value_type *as_bare_pointer() const {
        return &(*ptr());
      }

      reference operator[](index_type i) const {
        return *ptr(_index+i);
      }
      template <bool C>
      bool operator==(const iter_<C> &rhs) const {
        return _array == rhs._array && _index == rhs._index;
      }
      bool operator==(nullptr_t) const {
        return _array == nullptr;
      }
      template <typename X>
      bool operator==(X *p) const {
        return _array == nullptr ? p == nullptr : ptr() == p;
      }

      template <typename X>
      bool operator !=(X &&rhs) const {
        return !((*this) == std::forward<X>(rhs));
      }

      template <bool C>
      bool operator<(const iter_<C> &rhs) const {
        return _array == rhs._array && _index < rhs._index;
      }
      template <bool C>
      bool operator>(const iter_<C> &rhs) const {
        return _array == rhs._array && _index > rhs._index;
      }
      template <bool C>
      bool operator<=(const iter_<C> &rhs) const {
        return *this < rhs || *this == rhs;
      }
      template <bool C>
      bool operator>=(const iter_<C> &rhs) const {
        return *this > rhs || *this == rhs;
      }

      iter_ &operator +=(difference_type delta) {
        _index += delta;
        return *this;
      }
      iter_ &operator -=(difference_type delta) {
        _index -= delta;
        return *this;
      }

      iter_ &operator ++() {
        return (*this) += 1;
      }
      iter_ &operator --() {
        return (*this) -= 1;
      }

      iter_ operator ++(int) {
        index_type i = _index;
        ++(*this);
        return iter_{_array, i};
      }
      iter_ operator --(int) {
        index_type i = _index;
        --(*this);
        return iter_{_array, i};
      }

      iter_ operator +(difference_type delta) const {
        return iter_{_array, _index+delta};
      }
      iter_ operator -(difference_type delta) const {
        return iter_{_array, _index-delta};
      }

      template <bool C>
      difference_type operator -(const iter_<C> &rhs) const {
        assert(_array == rhs._array);
        return _index - rhs._index;
      }

      template <typename C, typename Tr>
      std::basic_ostream<C,Tr> &print_on(std::basic_ostream<C,Tr> &os) const {
        return os << _array << "[" << _index << "]";
      }



    };

  public:
    using iterator = iter_<false>;
    using const_iterator = iter_<true>;

    using reference = typename iterator::reference;
    using const_reference = typename const_iterator::reference;

    using reverse_iterator = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;
  private:
    value_type _first_value;

  public:
    gc_array(gc_token &gc, size_type n) 
      : gc_array_base(gc, n)
    {
      assert(n > 0);
      /*
       * The allocation is guaranteed to give us zeroed memory.  In
       * most cases (numbers, enums, bools, gc_ptrs, gc_sub_ptrs),
       * that's what we would put in there anyway, so there's no point
       * in walking the array again.  So we'll count on the compiler
       * to remove the loop.
       */
      if (!zero_init_okay<value_type>::value) {
        value_type *p = &_first_value;
        for (size_type i=1; i<n; i++) {
          new (++p) value_type;
        }
      }
    }
    template <typename Iter>
    gc_array(gc_token &gc, size_type n, Iter from, size_type n_to_copy) 
      : gc_array_base(gc, n),
	_first_value(*from)
    {
      assert(n > 0);
      assert(n_to_copy > 0);
      value_type *p = &_first_value+1;
      p = std::uninitialized_copy_n(++from, n_to_copy-1, p);
      if (n>n_to_copy && !zero_init_okay<value_type>::value) {
        size_type n_default = n-n_to_copy;
        for (size_type i=1; i<n_default; i++) {
          new (p++) value_type;
        }
      }
    }
    /*
     * And other ctors copying and working from iterators
     * Probably op=, as well.
     */
    reference at(size_type pos) {
      if (pos >= size()) {
        throw std::out_of_range("");
      }
      return (*this)[pos];
    }
    const_reference at(size_type pos) const {
      if (pos >= size()) {
        throw std::out_of_range("");
      }
      return (*this)[pos];
    }
    /*
     * Should these check, too?
     */
    reference operator[](size_type pos) {
      return *(begin()+pos);
    }
    constexpr const_reference operator[](size_type pos) const {
      return *(begin()+pos);
    }

    reference front() {
      /* check? */
      return (*this)[0];
    }
    const_reference front() const {
      /* check? */
      return (*this)[0];
    }
    reference back() {
      /* check? */
      return (*this)[size()-1];
    }
    const_reference back() const {
      /* check? */
      return (*this)[size()-1];
    }

    const_iterator cbegin() const {
      return const_iterator{GC_THIS, 0};
    }
    iterator begin() {
      return iterator{GC_THIS, 0};
    }
    const_iterator begin() const {
      return cbegin();
    }
    const_iterator cend() const {
      return const_iterator{GC_THIS, static_cast<typename const_iterator::index_type>(size())};
    }
    iterator end() {
      return iterator{GC_THIS, static_cast<typename iterator::index_type>(size())};
    }
    const_iterator end() const {
      return cend();
    }

    reverse_iterator rbegin() {
      return reverse_iterator(end());
    }
    const_reverse_iterator crbegin() const {
      return const_reverse_iterator(cend());
    }
    const_reverse_iterator rbegin() const {
      return crbegin();
    }
    reverse_iterator rend() {
      return reverse_iterator(begin());
    }
    const_reverse_iterator crend() const {
      return const_reverse_iterator(cbegin());
    }
    const_reverse_iterator rend() const {
      return crend();
    }


    void clear() {
      std::fill(begin(), end(), value_type{});
    }



  };

  template <typename T> struct is_gc_array : std::false_type {};

  template <typename T>
  struct is_gc_array<gc_array<T>> : std::true_type {};
  template <typename T>
  struct is_gc_array<const gc_array<T>> : std::true_type {};


  template <typename T>
  struct gc_allocatable {
    static constexpr bool value =
        !std::is_polymorphic<T>::value
        && std::is_base_of<gc_allocated, T>::value;
  };



}

namespace std {
  template <typename C, typename T, typename X, bool Constp>
  basic_ostream<C,T> &
  operator <<(basic_ostream<C,T> &os,
              const typename mpgc::gc_array<X>::template iter_<Constp> &iter) {
    return iter.print_on(os);
  }
}

#endif
