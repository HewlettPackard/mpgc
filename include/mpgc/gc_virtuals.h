/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#ifndef GC_VIRTUALS_H
#define GC_VIRTUALS_H

#include <functional>
#include <vector>
#include <utility>
#include <type_traits>
#include <mutex>

#include "mpgc/gc_allocated.h"


namespace mpgc {



  /*
   * GC-allocated objects (at least when the GC heap is in NVM) aren't
   * allowed to have pointers into process-local space, and this
   * includes vtbl pointers, so they can't have virtual functions.
   * The gc_allocated_with_virtuals class allows a (somewhat awkward)
   * way of getting around this restriction, providing a mechanism by
   * which virtual functions are delegated through a process-local
   * object created on the stack for the call.
   */

  template <typename Root, typename Disc = std::size_t>
  class gc_allocated_with_virtuals : public gc_allocated {
  public:
    using discriminator_type = Disc;
    using virtual_root_type = Root;
  private:
  protected:
    const discriminator_type _discrim;
    class virtuals_base {
    };

    using virtuals = virtuals_base;

    gc_allocated_with_virtuals(gc_token &gc, discriminator_type d)
      : gc_allocated{gc}, _discrim{d}
    {}

  public:
    /*
     * Public to allow it to be split
     */
    class vf_table {
      friend class gc_allocated_with_virtuals;
      using ct_func_type = std::function<void(virtuals_base &vb)>;
      using f2_type = std::function<void(const ct_func_type &)>;
      using rep_type = std::vector<f2_type>;

      rep_type _rep;

      template <typename Sub, typename Fn>
      auto call_through_void(Sub *sub, Fn&& fn) const {
	const std::size_t i = static_cast<std::size_t>(sub->_discrim);
	using sub_virt = typename Sub::virtuals;
	auto ct = [&](virtuals_base &vb) {
	  sub_virt &vs = static_cast<sub_virt &>(vb);
	  std::forward<Fn>(fn)(vs);
	};
	(_rep[i])(ct);
      }
      template <typename Sub, typename Fn>
      auto call_through(Sub *sub, Fn&& fn) const {
	const std::size_t i = static_cast<std::size_t>(sub->_discrim);
	using sub_virt = typename Sub::virtuals;
	std::result_of_t<Fn(typename Sub::virtuals &)> res;
	auto ct = [&](virtuals_base &vb) {
	  sub_virt &vs = static_cast<sub_virt &>(vb);
	  res = std::forward<Fn>(fn)(vs);
	};
	(_rep[i])(ct);
	return res;
      }
    public:
      /* public to allow the initialization to be split between
	 compilation units */

      template <typename T>
      void bind(discriminator_type disc = T::discrim) {
	std::size_t index = static_cast<std::size_t>(disc);
	if (_rep.size() < index) {
	  _rep.resize(index+1);
	}
	_rep[index] = [](const ct_func_type &ct) {
	  typename T::virtuals virt;
	  ct(virt);
	};
      }
    };
  protected:
    

    static void init_vf_table(vf_table &); 

    static vf_table &vtbl() {
      static vf_table t;
      static std::once_flag initialized;
      std::call_once(initialized, []() {
	  init_vf_table(t);
	});
      return t;
    }

    template <typename Sub, typename X, typename... FnArgs, typename...Args, 
	      typename = std::enable_if_t<!std::is_void<X>::value> >
    static auto
    call_virtual(Sub *sub, X (Sub::virtuals::*m)(FnArgs...), Args&&...args) {
      auto ct_func = [&](typename Sub::virtuals &vp) {
	return (vp.*m)(sub, std::forward<Args>(args)...);
      };
      return vtbl().call_through(sub, ct_func); 
    }

    template <typename Sub, typename... FnArgs, typename...Args>
    static auto
    call_virtual(Sub *sub, void (Sub::virtuals::*m)(FnArgs...), Args&&...args) {
      auto ct_func = [&](typename Sub::virtuals &vp) {
	(vp.*m)(sub, std::forward<Args>(args)...);
      };
      vtbl().call_through_void(sub, ct_func); 
    }

    template <typename Sub, typename X, typename... FnArgs, typename...Args, 
	      typename = std::enable_if_t<!std::is_void<X>::value> >
    static auto
    call_virtual(const Sub *sub, X (Sub::virtuals::*m)(FnArgs...) const, Args&&...args) {
      auto ct_func = [&](typename Sub::virtuals &vp) {
	return (vp.*m)(sub, std::forward<Args>(args)...);
      };
      Sub *nc_sub = const_cast<Sub *>(sub);
      return vtbl().call_through(nc_sub, ct_func); 
    }

    template <typename Sub, typename... FnArgs, typename...Args>
    static auto
    call_virtual(const Sub *sub, void (Sub::virtuals::*m)(FnArgs...) const, Args&&...args) {
      auto ct_func = [&](typename Sub::virtuals &vp) {
	(vp.*m)(sub, std::forward<Args>(args)...);
      };
      Sub *nc_sub = const_cast<Sub *>(sub);
      vtbl().call_through_void(nc_sub, ct_func); 
    }


  public:
    template <typename C, typename X, typename... FnArgs, typename ...Args>
    auto call_non_virtual(X (C::*m)(FnArgs...), Args&&...args) {
      C *cp = static_cast<C*>(this);
      return (cp->*m)(std::forward<Args>(args)...);
    }
    template <typename C, typename X, typename... FnArgs, typename ...Args>
    auto call_non_virtual(X (C::*m)(FnArgs...) const, Args&&...args) const {
      const C *cp = static_cast<const C*>(this);
      return (cp->*m)(std::forward<Args>(args)...);
    }

    static const auto &descriptor() {
      static gc_descriptor d =
	GC_DESC(gc_allocated_with_virtuals)
	.template WITH_FIELD(&gc_allocated_with_virtuals::_discrim);
      return d;
    }
 
  };

}

#endif
