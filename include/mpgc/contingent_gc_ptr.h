/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#ifndef CONTINGENT_GC_PTR_H
#define CONTINGENT_GC_PTR_H

#include <utility>
#include "mpgc/gc_fwd.h"
/*
 * Note: We need to explicitly include gc_fwd.h, because it declares
 * the default argument for the second template arg for
 * contingent_gc_ptr.
 */
#include "ruts/atomic16B.h"
#include "mpgc/gc_ptr.h"
#include "mpgc/weak_gc_ptr.h"


namespace mpgc {
  template <typename T>
  class controlled_gc_ptr {
    offset_ptr<T> _ptr;
    gc_ptr<T> convert_to_strong(const offset_ptr<T> &p) const {
      constexpr auto ptr_type_fld = base_offset_ptr::ptr_type_fld;
      return gc_ptr<T>::from_offset_ptr(offset_ptr<T>(ptr_type_fld.replace(p.val(), special_ptr_type::Strong)));
    }

    offset_ptr<T> convert_from_strong(const gc_ptr<T> &p) const {
      if (p == nullptr) {
        return nullptr;
      }
      constexpr auto ptr_type_fld = base_offset_ptr::ptr_type_fld;
      return offset_ptr<T>(ptr_type_fld.replace(p.as_offset_pointer().val(), special_ptr_type::Contingent));
    }
   public:
    controlled_gc_ptr() noexcept : _ptr(nullptr) {}
    controlled_gc_ptr(std::nullptr_t) noexcept : controlled_gc_ptr{} {}
    controlled_gc_ptr(const gc_ptr<T> &rhs) noexcept : _ptr(convert_from_strong(rhs)) {}

    controlled_gc_ptr &operator =(std::nullptr_t) noexcept {
      _ptr = nullptr;
      return *this;
    }
    controlled_gc_ptr &operator =(const gc_ptr<T> &rhs) noexcept {
      _ptr = convert_from_strong(rhs);
      return *this;
    }

    operator gc_ptr<T>() const {
      return convert_to_strong(_ptr);
    }

    const offset_ptr<T>& as_offset_pointer() const noexcept {
      return _ptr;
    }
  };

  template <typename C, typename T>
  class alignas(16) contingent_gc_ptr {
    struct pair {
      weak_gc_ptr<C> _control;
      controlled_gc_ptr<T> _ptr;

      constexpr pair(weak_gc_ptr<C> c = nullptr, gc_ptr<T> p = nullptr) noexcept
        : _control(c), _ptr(p) {}

     /* pair(const pair& p) noexcept : _control(p._control), _ptr(p._ptr) {}
      pair &operator =(const pair& p) noexcept {
        _control = p._control;
        _ptr = p._ptr;
        return *this;
      }*/

      static const auto &descriptor() {
        static gc_descriptor d =
          GC_DESC(pair)
          .template WITH_FIELD(&pair::_control)
          .template WITH_FIELD(&pair::_ptr);
        return d;
      }
    };

    union {
     ruts::atomic16B<pair> _atomic_pair;
     pair                  _pair;
    };

    template <typename X, typename Y>
    using if_assignable = std::enable_if_t<std::is_assignable<C*&,X*>::value
                                           && std::is_assignable<T*&,Y*>::value>;
  public:
    using control_type = C;
    using element_type = T;

    static const auto &descriptor() {
      static gc_descriptor d =
        GC_DESC(contingent_gc_ptr)
        .template WITH_FIELD(&contingent_gc_ptr::_pair);
      return d;
    }

    /*
     * The second (desired) argument is a non-const ref because if the
     * controlling pointer in the pair is expired, cas() will null out
     * the controlled pointer.
     */
    void cas(pair&, pair&, const bool);

    template <typename X, typename Y, typename = if_assignable<X,Y> >
    void cas(pair& old, const weak_gc_ptr<X>& new_wp, const gc_ptr<Y>& new_sp, const bool try_once) {
      pair p(new_wp, new_sp);
      return cas(old, p, try_once);
    }

    template <typename X, typename Y, typename = if_assignable<X,Y> >
    void cas(contingent_gc_ptr &old, const weak_gc_ptr<X> &new_wp, const gc_ptr<Y> &new_sp, const bool try_once) {
      pair p(new_wp, new_sp);
      return cas(old._pair, p, try_once);
    }

    void write(pair &p) {
      pair old = _atomic_pair;
      cas(old, p, false);
    }

    template <typename X, typename Y, typename = if_assignable<X,Y> >
    void write(const weak_gc_ptr<X> &new_wp, const gc_ptr<Y> &new_sp) {
      write(pair(new_wp, new_sp));
    }

    void write(const contingent_gc_ptr &cp) {
      pair p = cp._pair;
      write(p);
    }

    template <typename X, typename = std::enable_if_t<std::is_assignable<C*&,X*>::value> >
    void write_control(const weak_gc_ptr<X> &new_wp) {
      pair old = _atomic_pair;
      gc_ptr<C> sp = old._control.lock();
      if (sp != nullptr) {
        cas(old, pair(new_wp, old._ptr), false);
      } else {
        cas(old, pair(new_wp, nullptr), false);
      }
    }

    template <typename Y, typename = std::enable_if_t<std::is_assignable<T*&,Y*>::value> >
    void write_controlled(const gc_ptr<Y> &new_sp) {
      pair old = _atomic_pair;
      cas(old, old._control, new_sp, false);
    }

    constexpr contingent_gc_ptr() noexcept
      : _pair{}
    {}
    constexpr contingent_gc_ptr(std::nullptr_t) noexcept
      : contingent_gc_ptr{}
    {}

    contingent_gc_ptr(const contingent_gc_ptr &rhs) noexcept {
      weak_gc_ptr<C>::write_barrier(this, &rhs._pair._control,
                                    [&rhs]{return rhs._pair._control.as_offset_pointer();},
                                    [this, &rhs](const offset_ptr<C>& wp) {
                                      const_cast<offset_ptr<C> &>(_pair._control.as_offset_pointer()) = wp;
                                      _pair._ptr = rhs._pair._ptr;
                                    });
    }

    contingent_gc_ptr(contingent_gc_ptr&&rhs) noexcept
      : contingent_gc_ptr(const_cast<const contingent_gc_ptr &>(rhs))
      {}

    contingent_gc_ptr(const weak_gc_ptr<C> &wp, const gc_ptr<T> &sp)
    {
      weak_gc_ptr<C>::write_barrier(this, &wp,
                                    [&wp]{return wp.as_offset_pointer();},
                                    [this, &sp](const offset_ptr<C>& wp) {
                                      const_cast<offset_ptr<C> &>(_pair._control.as_offset_pointer()) = wp;
                                      _pair._ptr = sp;
                                    });
    }

    template <typename X, typename Y, typename = if_assignable<X,Y> >
    contingent_gc_ptr(const contingent_gc_ptr<X,Y> &rhs) noexcept
    {
      weak_gc_ptr<X>::write_barrier(this, &rhs._pair._control,
                                    [&rhs]{return rhs._pair._control.as_offset_pointer();},
                                    [this, &rhs](const offset_ptr<X>& wp) {
                                      const_cast<offset_ptr<C> &>(_pair._control.as_offset_pointer()) = wp;
                                      _pair._ptr = rhs._pair._ptr;
                                    });
    }

    contingent_gc_ptr &operator =(const contingent_gc_ptr &rhs) noexcept {
      write(rhs);
      return *this;
    }
    contingent_gc_ptr &operator =(contingent_gc_ptr &&rhs) noexcept {
      write(rhs);
      return *this;
    }
    contingent_gc_ptr &operator =(nullptr_t) noexcept {
      write(contingent_gc_ptr());
      return *this;
    }

    template <typename X, typename Y, typename = if_assignable<X,Y> >
    contingent_gc_ptr &operator =(const contingent_gc_ptr<X,Y> &rhs) noexcept {
      write(rhs);
      return *this;
    }

    /*
     * The non-contingent assignments just change the pointer, leaving
     * the control alone.  It's probably not worth checking the
     * control.
     */
    template <typename Y, typename = std::enable_if_t<std::is_assignable<T*&,Y*>::value> >
    contingent_gc_ptr &operator =(const gc_ptr<Y> &rhs) noexcept  {
      write_controlled(rhs);
      return *this;
    }

    void reset_control(nullptr_t) noexcept {
      write_control(nullptr);
    }
    void reset_control(const weak_gc_ptr<C> &rhs) noexcept {
      write_control(rhs);
    }

    std::pair<gc_ptr<C>, gc_ptr<T>> lock_pair() const noexcept {
      pair p = _atomic_pair;
      gc_ptr<C> ctrl = p._control.lock();
      return std::make_pair(ctrl, (ctrl != nullptr) ? p._ptr : nullptr);
    }

    gc_ptr<T> lock() const noexcept {
      std::pair<gc_ptr<C>, gc_ptr<T>> p = lock_pair();
      return (p.first == nullptr || p.second == nullptr) ? nullptr : p.second;
    }

    // gc_ptr<T> operator->() const noexcept {
    //   return lock();
    // }

    weak_gc_ptr<C> control() const noexcept {
      return _pair._control;
    }

    gc_ptr<C> lock_control() const noexcept {
      return _pair._control.lock();
    }

    bool control_expired() const noexcept {
      return _pair._control.expired();
    }

    bool expired() const noexcept {
      return control_expired();
    }

    void reset() noexcept {
      write(nullptr, nullptr);
    }
    
    void swap(contingent_gc_ptr &other) {
      pair p = _atomic_pair.load();
      _atomic_pair = other._atomic_pair.load();
      other._atomic_pair = p;
    }

    template <typename Ch, typename Tr>
    std::basic_ostream<Ch,Tr> &print_on(std::basic_ostream<Ch,Tr> &os) const {
      pair p = _atomic_pair;
      return os << p._ptr << "{" << p._control << "}";
    }
  };

  template <typename T>
  struct gc_traits<controlled_gc_ptr<T>> : is_ref_descriptor {};
}

namespace std {
  template <typename T, typename C>
  inline
  void swap(mpgc::contingent_gc_ptr<T,C> &lhs, mpgc::contingent_gc_ptr<T,C> &rhs) {
    lhs.swap(rhs);
  }

  template <typename C, typename T, typename X>
  basic_ostream<C,T> &
  operator <<(basic_ostream<C,T> &os, const mpgc::controlled_gc_ptr<X> &ptr) {
    return os << ptr.as_offset_pointer();
  }

  template <typename C, typename T, typename X, typename Y>
  basic_ostream<C,T> &
  operator <<(basic_ostream<C,T> &os, const mpgc::contingent_gc_ptr<X,Y> &ptr) {
    return ptr.print_on(os);
  }
}
#endif

