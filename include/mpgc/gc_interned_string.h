/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * gc_interned_string.h
 *
 *  Created on: Sep 21, 2014
 *      Author: evank
 */

#ifndef GC_INTERNED_STRING_H_
#define GC_INTERNED_STRING_H_

#include <cstddef>
#include <memory>
#include <string>
#include <type_traits>
#include <ostream>

#include "ruts/uniform_key.h"
#include "mpgc/gc.h"
#include "mpgc/gc_cuckoo_map.h"
#include "ruts/hashes.h"

namespace mpgc {
  /*
   * Eventually, we'll want a much more robust class, probably with UTF-8 or UTF-16 encoding
   * and lots of ways to do it.  For now, we're just going to to handle 2-byte chars directly
   * with no conversion, since this is easiest for Java.  THIS IS WRONG.
   */

  struct keyed_string : gc_allocated, ruts::with_uniform_id {
    using char_type = char16_t;
    using uniform_key = ruts::uniform_key;
    // TODO: string_type needs to be in GC space
//    using string_type = const std::basic_string<char_type, std::char_traits<char_type>>;
  private:
    gc_array_ptr<char_type> _value;
  public:
    /*
     * For some reason, if I leave off string_type, I can't find it through keyed_type, but if I repeat it
     * the compiler complains.
     */
//      using string_type = gc_interned_string_table::string_type;
//    using stype = string_type;
    template <typename Iter>
    keyed_string(gc_token &gc, const uniform_key &k,const Iter &from, const Iter &to)
    : gc_allocated{gc}, ruts::with_uniform_id{k}, _value{make_gc_array<char_type>(from, to)}
    {}
    static const auto &descriptor() {
      static gc_descriptor d =
	GC_DESC(keyed_string)
	.WITH_SUPER(with_uniform_id)
	.WITH_FIELD(&keyed_string::_value);
      return d;
    }
    const uniform_key &key() const {
      return id;
    }

    template <typename ST>
    std::basic_ostream<char,ST> &
    print_on(std::basic_ostream<char,ST> &os) const {
      for (char_type c : _value) {
        os << static_cast<char>(c);
      }
      return os;
    }
//    const string_type &as_string() const {
//      return _value;
//    }
  };

  template <typename SC, typename ST>
  inline
  std::basic_ostream<SC,ST> &
  operator <<(std::basic_ostream<SC,ST> &os,
              const gc_ptr<const keyed_string> &s)
  {
    if (s != nullptr) {
      s->print_on(os);
    }
    return os;
  }

  template <typename Traits = gc_cm_traits>
  class gc_interned_string_table : public gc_allocated {
  public:
    using char_type = char16_t;

  private:
    using key_type = ruts::uniform_key;
  public:
    using keyed_string_type = keyed_string;
//    using string_type = typename keyed_string_type::string_type;

    using value_type = gc_ptr<const keyed_string_type>;
  private:
    using map_type = gc_cuckoo_map<key_type, value_type, Traits>;
    const gc_ptr<map_type> _map;


  public:
    gc_interned_string_table(gc_token &gc, std::size_t default_cap)
    : gc_allocated{gc}, _map{make_gc<map_type>(default_cap)}
    {}

    static const auto &descriptor() {
      static gc_descriptor d =
	GC_DESC(gc_interned_string_table)
	.template WITH_FIELD(&gc_interned_string_table::_map);
      return d;
    }

    template <typename Iter>
    value_type intern(const Iter &from, const Iter &to) {
      using namespace ruts;
      /*
       * Whatever the iterator, we want to treat it as if it's pointing to a char16_t;
       */
      std::pair<masher::accumulator_type, masher::accumulator_type> accums = uniform_key::accumulators();
      for (char16_t c : ruts::range_over(from,to)) {
        accums.first.add(c);
        accums.second.add(c);
      }
      uniform_key key{accums};
      gc_ptr<const keyed_string_type> s = _map->get(key);
      if (s != nullptr) {
        return s;
      }
      s = make_gc<keyed_string_type>(key, from, to);
      auto rr = _map->put_new(key, s);
      // if
      if (rr.had_value) {
        // Somebody else put it in while we were constructing it
        return rr.old_value;
      } else {
        return s;
      }
    }

    value_type intern(const char *chars, std::size_t len) {
      return intern(chars, chars+len);
    }

    // This is assumed to be a literal string (with a null byte at the end)
    template <std::size_t N>
    value_type intern(const char (&chars)[N]) {
      return intern(chars, N-1);
    }

    value_type intern(const char16_t *chars, std::size_t len) {
      return intern(chars, chars+len);
    }
    // This is assumed to be a literal string (with a null byte at the end)
    template <std::size_t N>
    value_type intern(const char16_t (&chars)[N]) {
      return intern(chars, N-1);
    }

    value_type intern(const wchar_t *chars, std::size_t len) {
      return intern(chars, chars+len);
    }
    // This is assumed to be a literal string (with a null byte at the end)
    template <std::size_t N>
    value_type intern(const wchar_t (&chars)[N]) {
      return intern(chars, N-1);
    }

    template <typename C, typename T, typename A>
    value_type intern(const std::basic_string<C,T,A> &s) {
      return intern(s.begin(), s.end());
    }

  };

}

#if 0
namespace ruts {
  template <>
  struct hash1<const mpgc::keyed_string *> {
    uniform_key::hash_t operator()(const mpgc::keyed_string *p) const {
      return hash1<uniform_key>{}(p->key());
    }
  };
  template <>
  struct hash2<const mpgc::keyed_string<Allocator> *> {
    uniform_key::hash_t operator()(const keyed_string *p) const {
      return hash2<uniform_key>{}(p->key());
    }
  };
}
#endif



#endif /* GC_INTERNED_STRING_H_ */
