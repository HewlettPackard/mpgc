/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#ifndef BUMP_ALLOCATION_SLOTS_H
#define BUMP_ALLOCATION_SLOTS_H

#include "mpgc/gc_ptr.h"

namespace mpgc {
  struct gc_control_block;
  namespace gc_allocator {
      struct slot {
        std::size_t id = 0;
        union {
          std::size_t  ptr_offset = 0;
          slot_number  next;
        };

        static const auto &descriptor() {
          static gc_descriptor d =
            GC_DESC(slot)
            .template WITH_FIELD(&slot::id)
            .template WITH_FIELD(&slot::ptr_offset);
          return d;
        }
        slot(): id(0), ptr_offset(0) {}
      };

    class bump_allocation_slots {
      constexpr static std::size_t sentinel_size = 1 << 14;
      constexpr static std::size_t block_size = 1 << 14;

      gc_array_ptr<slot> sentinel[sentinel_size];
      std::atomic<slot_number> head;
      void install_new_block() {
        //TODO:not implemented yet.
        std::abort();
#if 0
        using array_type = gc_array<slot>;
        uint8_t i = 1;
        while (i < sentinel_size) {
          if (sentinel[i++] == nullptr) {
            break;
          }
        }
        gc_ptr<array_type> b(block_size);
        uint16_t k = 2;
        for (auto j : b) {
          j->next.sentinel_idx = i;
          j->next.sentinel_idx = k++;
        }
        
        gc_array_ptr<slot> expected = nullptr;
        sentinel[i].compare_exchange_strong(expected, b);
#endif
      }
     public:
      friend gc_control_block;

      bump_allocation_slots(uint8_t* b) : sentinel{nullptr}, head{slot_number(0, 1)} {
        using array_type = gc_array<slot>;
        using value_type = typename array_type::value_type;

        gc_descriptor valdesc = desc_for<value_type>();
        gc_token tok(valdesc.in_array<value_type>(block_size));
        array_type *bp = new (b) array_type(tok, block_size);
        gc_ptr<array_type> block = gc_ptr_from_bare_ptr(bp);

        uint32_t s = 2;
        for (auto &i : block) {
          i.next.sentinel_idx = 0;
          i.next.block_idx = s++;
        }
        block.end()->next.data = 0;
        *reinterpret_cast<offset_ptr<uint8_t>*>(sentinel) = b;
      }

      template <typename Fn>
      void enumerate_pointers(const Fn &fn) const {
        for (std::size_t i = 0; i < sentinel_size; i++) {
          if (sentinel[i] == nullptr) {
            break;
          }
          fn(sentinel[i]);
        }
      }

      slot& get_ref(slot_number s) {
        return sentinel[s.sentinel_idx]->at(s.block_idx - 1);
      }

      slot get(slot_number s) {
        return sentinel[s.sentinel_idx]->at(s.block_idx - 1);
      }

      slot_number acquire_slot() {
        slot_number exp = head;
        slot_number des;
        do {
          while (exp.data == 0) {
            std::cpu_relax();
            exp = head;
          }
          des = sentinel[exp.sentinel_idx]->at(exp.block_idx - 1).next;
        } while (!head.compare_exchange_weak(exp, des));
        if (des.data == 0) {
          install_new_block();
        }
        return exp;
      }

      void release_slot(slot_number s) {
        slot_number exp = head;
        do {
          sentinel[s.sentinel_idx]->at(s.block_idx - 1).next = exp;
        } while (!head.compare_exchange_weak(exp, s));
      }
    };
  }
}

#endif //BUMP_ALLOCATION_SLOTS_H

