/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#ifndef GC_VERSIONED_H
#define GC_VERSIONED_H

#include "ruts/versioned_ptr.h"
#include "ruts/atomic.h"
#include "mpgc/gc_ptr.h"
#include "mpgc/weak_gc_ptr.h"

namespace mpgc {

  template <typename T, std::size_t NFlags = 0>
  using versioned_gc_ptr = ruts::versioned<gc_ptr<T>, NFlags, base_offset_ptr::used_bits()>;

  template <typename T, std::size_t NFlags = 0>
  using atomic_versioned_gc_ptr = ruts::atomic_versioned<gc_ptr<T>, NFlags, base_offset_ptr::used_bits()>;

  template <typename T, std::size_t NFlags = 0>
  using versioned_weak_gc_ptr = ruts::versioned<weak_gc_ptr<T>, NFlags, base_offset_ptr::used_bits()>;

  template <typename T, std::size_t NFlags = 0>
  using atomic_versioned_weak_gc_ptr = ruts::atomic_versioned<weak_gc_ptr<T>, NFlags, base_offset_ptr::used_bits()>;
}

namespace std {
  
  template <typename T, size_t NFlags, size_t NBits>
  class atomic<ruts::versioned<mpgc::gc_ptr<T>, NFlags, NBits>>
    : public ruts::default_atomic<ruts::versioned<mpgc::gc_ptr<T>, NFlags, NBits>>
  {
    using base = ruts::default_atomic<ruts::versioned<mpgc::gc_ptr<T>, NFlags, NBits>>;
    using contained_type = ruts::versioned<mpgc::gc_ptr<T>, NFlags, NBits>;

    template <typename Fn>
    void write_barrier(const contained_type &lhs, const contained_type &rhs, Fn&& func) {
      mpgc::gc_ptr<T> lhs_ptr = lhs.pointer();
      mpgc::gc_ptr<T> rhs_ptr = rhs.pointer();
      mpgc::write_barrier(lhs_ptr.as_offset_pointer(), rhs_ptr.as_offset_pointer(), func);
    }

  public:
    using base::load_order;
    using base::base;
    contained_type operator =(const contained_type &desired) {
      store(desired);
      return desired;
    }
    contained_type operator =(const contained_type &desired) volatile {
      store(desired);
      return desired;
    }
    using base::load;
    void store(const contained_type &desired,
               std::memory_order order = std::memory_order_seq_cst)
    {
      write_barrier(load(), desired, [&] {
        base::store(desired, order);
      });
    }

    void store(const contained_type &desired,
               std::memory_order order = std::memory_order_seq_cst) volatile
    {
      write_barrier(load(), desired, [&] {
        base::store(desired, order);
      });
    }

    contained_type exchange(const contained_type &desired,
                            std::memory_order order = std::memory_order_seq_cst)
    {
      contained_type ret;
      write_barrier(load(), desired, [&] {
        ret = base::exchange(desired, order);
      });
      return ret;
    }

    contained_type exchange(const contained_type &desired,
                            std::memory_order order = std::memory_order_seq_cst) volatile
    {
      contained_type ret;
      write_barrier(load(), desired, [&] {
        ret = base::exchange(desired, order);
      });
      return ret;
    }

    bool compare_exchange_weak(contained_type &expected,
                               const contained_type &desired,
                               std::memory_order success,
                               std::memory_order failure)
    {
      bool ret;
      write_barrier(expected, desired, [&] {
        ret = base::compare_exchange_weak(expected, desired,
                                          success, failure);
      });
      return ret;
    }

    bool compare_exchange_weak(contained_type &expected,
                               const contained_type &desired,
                               std::memory_order order = std::memory_order_seq_cst)
    {
      return compare_exchange_weak(expected, desired, order, load_order(order));
    }

    bool compare_exchange_weak(contained_type &expected,
                               const contained_type &desired,
                               std::memory_order success,
                               std::memory_order failure) volatile
    {
      bool ret;
      write_barrier(expected, desired, [&] {
        ret = base::compare_exchange_weak(expected, desired,
                                          success, failure);
      });
      return ret;
    }

    bool compare_exchange_weak(contained_type &expected,
                               const contained_type &desired,
                               std::memory_order order = std::memory_order_seq_cst) volatile
    {
      return compare_exchange_weak(expected, desired, order, load_order(order));
    }

    /*
     * If you override one with a name, you have to import the whole
     * set, otherwise you lose the others.
     */
    bool compare_exchange_strong(contained_type &expected,
                                 const contained_type &desired,
                                 std::memory_order success,
                                 std::memory_order failure)
    {
      // mark expected
      bool ret;
      write_barrier(expected, desired, [&] {
        ret = base::compare_exchange_strong(expected, desired,
                                            success, failure);
      });
      return ret;
    }

    bool compare_exchange_strong(contained_type &expected,
                                 const contained_type &desired,
                                 std::memory_order order = std::memory_order_seq_cst)
    {
      return compare_exchange_strong(expected, desired, order, load_order(order));
    }

    bool compare_exchange_strong(contained_type &expected,
                                 const contained_type &desired,
                                 std::memory_order success,
                                 std::memory_order failure) volatile
    {
      bool ret;
      write_barrier(expected, desired, [&] {
        ret = base::compare_exchange_strong(expected, desired,
                                            success, failure);
      });
      return ret;
    }

    bool compare_exchange_strong(contained_type &expected,
                                 const contained_type &desired,
                                 std::memory_order order = std::memory_order_seq_cst) volatile
    {
      return compare_exchange_strong(expected, desired, order, load_order(order));
    }

  };

  template <typename T, size_t NFlags, size_t NBits>
  class atomic<ruts::versioned<mpgc::weak_gc_ptr<T>, NFlags, NBits>>
    : public ruts::default_atomic<ruts::versioned<mpgc::weak_gc_ptr<T>, NFlags, NBits>>
  {
    using base = ruts::default_atomic<ruts::versioned<mpgc::weak_gc_ptr<T>, NFlags, NBits>>;
    using contained_type = ruts::versioned<mpgc::weak_gc_ptr<T>, NFlags, NBits>;

  public:
    using base::load_order;
    using base::load;

    atomic(const contained_type &desired) {
      mpgc::weak_gc_ptr<T>::write_barrier(this,
        [&desired]{return desired.pointer().as_offset_pointer();},
        [&](mpgc::offset_ptr<T> &p) {
          base(reinterpret_cast<contained_type&>(p).set(ruts::version_num(desired.version()),
                                                        desired.flags()));
        }
      );
    }
    constexpr atomic() : base(contained_type()) {};
    atomic(const atomic &) = delete;

    contained_type operator =(const contained_type &desired) {
      store(desired);
      return desired;
    }
    contained_type operator =(const contained_type &desired) volatile {
      store(desired);
      return desired;
    }
    void store(const contained_type &desired,
               std::memory_order order = std::memory_order_seq_cst)
    {
      mpgc::weak_gc_ptr<T>::write_barrier(this,
        [&desired]{return desired.pointer().as_offset_pointer();},
        [&](mpgc::offset_ptr<T> &p) {
          base::store(reinterpret_cast<contained_type&>(p).set(ruts::version_num(desired.version()),
                                                               desired.flags()),
                      order);
        }
      );
    }

    void store(const contained_type &desired,
               std::memory_order order = std::memory_order_seq_cst) volatile
    {
      mpgc::weak_gc_ptr<T>::write_barrier(this,
        [&desired]{return desired.pointer().as_offset_pointer();},
        [&](mpgc::offset_ptr<T> &p) {
          base::store(reinterpret_cast<contained_type&>(p).set(ruts::version_num(desired.version()),
                                                               desired.flags()),
                      order);
        }
      );
    }

    contained_type exchange(const contained_type &desired,
                            std::memory_order order = std::memory_order_seq_cst)
    {
      contained_type ret;
      mpgc::weak_gc_ptr<T>::write_barrier(this,
        [&desired]{return desired.pointer().as_offset_pointer();},
        [&](mpgc::offset_ptr<T> &p) {
          ret = base::exchange(reinterpret_cast<contained_type&>(p)
                                .set(ruts::version_num(desired.version()),
                                                       desired.flags()),
                               order);
        }
      );
      return ret;
    }

    contained_type exchange(const contained_type &desired,
                            std::memory_order order = std::memory_order_seq_cst) volatile
    {
      contained_type ret;
      mpgc::weak_gc_ptr<T>::write_barrier(this,
        [&desired]{return desired.pointer().as_offset_pointer();},
        [&](mpgc::offset_ptr<T> &p) {
          ret = base::exchange(reinterpret_cast<contained_type&>(p)
                                .set(ruts::version_num(desired.version()),
                                     desired.flags()),
                               order);
        }
      );
      return ret;
    }

    bool compare_exchange_weak(contained_type &expected,
                               const contained_type &desired,
                               std::memory_order success,
                               std::memory_order failure)
    {
      bool ret;
      mpgc::weak_gc_ptr<T>::write_barrier(this,
        [&desired]{return desired.pointer().as_offset_pointer();},
        [&](mpgc::offset_ptr<T> &p) {
          ret = base::compare_exchange_weak(expected,
                                            reinterpret_cast<contained_type&>(p)
                                             .set(ruts::version_num(desired.version()),
                                                  desired.flags()),
                                            success, failure);
        }
      );
      return ret;
    }

    bool compare_exchange_weak(contained_type &expected,
                               const contained_type &desired,
                               std::memory_order order = std::memory_order_seq_cst)
    {
      return compare_exchange_weak(expected, desired, order, load_order(order));
    }

    bool compare_exchange_weak(contained_type &expected,
                               const contained_type &desired,
                               std::memory_order success,
                               std::memory_order failure) volatile
    {
      bool ret;
      mpgc::weak_gc_ptr<T>::write_barrier(this,
        [&desired]{return desired.pointer().as_offset_pointer();},
        [&](mpgc::offset_ptr<T> &p) {
          ret = base::compare_exchange_weak(expected,
                                            reinterpret_cast<contained_type&>(p)
                                             .set(ruts::version_num(desired.version()),
                                                  desired.flags()),
                                            success, failure);
        }
      );
      return ret;
    }

    bool compare_exchange_weak(contained_type &expected,
                               const contained_type &desired,
                               std::memory_order order = std::memory_order_seq_cst) volatile
    {
      return compare_exchange_weak(expected, desired, order, load_order(order));
    }

    /*
     * If you override one with a name, you have to import the whole
     * set, otherwise you lose the others.
     */
    bool compare_exchange_strong(contained_type &expected,
                                 const contained_type &desired,
                                 std::memory_order success,
                                 std::memory_order failure)
    {
      // mark expected
      bool ret;
      mpgc::weak_gc_ptr<T>::write_barrier(this,
        [&desired]{return desired.pointer().as_offset_pointer();},
        [&](mpgc::offset_ptr<T> &p) {
          ret = base::compare_exchange_strong(expected,
                                              reinterpret_cast<contained_type&>(p)
                                               .set(ruts::version_num(desired.version()),
                                                    desired.flags()),
                                              success, failure);
        }
      );
      return ret;
    }

    bool compare_exchange_strong(contained_type &expected,
                                 const contained_type &desired,
                                 std::memory_order order = std::memory_order_seq_cst)
    {
      return compare_exchange_strong(expected, desired, order, load_order(order));
    }

    bool compare_exchange_strong(contained_type &expected,
                                 const contained_type &desired,
                                 std::memory_order success,
                                 std::memory_order failure) volatile
    {
      bool ret;
      mpgc::weak_gc_ptr<T>::write_barrier(this,
        [&desired]{return desired.pointer().as_offset_pointer();},
        [&](mpgc::offset_ptr<T> &p) {
          ret = base::compare_exchange_strong(expected,
                                              reinterpret_cast<contained_type&>(p)
                                               .set(ruts::version_num(desired.version()),
                                                    desired.flags()),
                                              success, failure);
        }
      );
      return ret;
    }

    bool compare_exchange_strong(contained_type &expected,
                                 const contained_type &desired,
                                 std::memory_order order = std::memory_order_seq_cst) volatile
    {
      return compare_exchange_strong(expected, desired, order, load_order(order));
    }

  };
}

#endif
