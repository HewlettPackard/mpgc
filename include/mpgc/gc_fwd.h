/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#ifndef GC_FWD_H_
#define GC_FWD_H_

#include <cstddef>
#include <mutex>
#include <type_traits>
#include "ruts/versioned_ptr.h"

namespace mpgc {
  class gc_token;
  class gc_allocated;
  template <typename T> class offset_ptr;
  template <typename T> class gc_array;
  template <typename T> class gc_ptr;
  template <typename T> class gc_sub_ptr;
  template <typename T> class gc_sub_ref;
  template <typename T>
  using gc_array_ptr = gc_ptr<gc_array<T>>;

  /**
   * A convenience alias for gc_ptr<const gc_allocated>, used when you
   * just want to guarantee that an object doesn't get collected.
   */
  using gc_anchor = gc_ptr<const gc_allocated>;

  template <typename T> class external_gc_ptr;
  template <typename T> class external_gc_sub_ptr;
  template <typename T> class external_gc_sub_ref;
  template <typename T>
  using external_gc_array_ptr = external_gc_ptr<gc_array<T>>;
  using external_gc_anchor = external_gc_ptr<const gc_allocated>;
  template <typename T> class external_weak_gc_ptr;

  template <typename T> class weak_gc_ptr;
  template <typename T, typename C=gc_allocated> class contingent_gc_ptr;


  template <typename X, typename ...Args>
  gc_ptr<X> make_gc(Args&&...args);
  template <typename T>
  gc_ptr<gc_array<T>> make_gc_array(std::size_t n);

  struct internal_pointers {
    template <typename T> using ptr_t = gc_ptr<T>;
    template <typename T> using array_ptr_t = gc_array_ptr<T>;
    template <typename T> using sub_ptr_t = gc_sub_ptr<T>;
    constexpr static bool is_internal = true;
  };

  struct external_pointers {
    template <typename T> using ptr_t = external_gc_ptr<T>;
    template <typename T> using array_ptr_t = external_gc_array_ptr<T>;
    template <typename T> using sub_ptr_t = external_gc_sub_ptr<T>;
    constexpr static bool is_internal = false;
  };

  extern void initialize();

  inline
  void initialize_thread() {
    static thread_local std::once_flag done;
    std::call_once(done, initialize);
  }

  template <typename T>
  struct is_collectible : public std::is_trivially_destructible<T>
  {};

  template <typename T, typename = void>
  struct zero_init_okay : std::false_type {};

  template <typename T>
  struct zero_init_okay<std::atomic<T>> : zero_init_okay<T> {};

  template <typename T>
  struct zero_init_okay<T, std::enable_if_t<std::is_scalar<T>::value> > : std::true_type {};

  template <typename T>
  struct zero_init_okay<offset_ptr<T>> : std::true_type {};

  template <typename T>
  struct zero_init_okay<gc_ptr<T>> : std::true_type {};
  template <typename T>
  struct zero_init_okay<gc_sub_ptr<T>> : std::true_type {};
}

#endif
