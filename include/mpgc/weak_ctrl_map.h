/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#ifndef WEAK_CTRL_MAP_H
#define WEAK_CTRL_MAP_H

#include <utility>
#include <functional>
#include <unordered_map>
#include <unordered_set>

#include "ruts/uniform_key.h"
#include "ruts/cuckoo_map.h"

namespace mpgc {
  template <typename T>
  class white_allocator {
   public:
    using size_type = std::size_t;
    using difference_type = typename offset_ptr<T>::difference_type;
    using pointer = offset_ptr<T>;
    using const_pointer = offset_ptr<const T>;
    using reference = T&;
    using const_reference = const T&;
    using value_type = T;
    template <typename T2> struct rebind
    {
      using other = white_allocator<T2>;
    };
    using propagate_on_container_move_assignment = std::true_type;
    // static_assert(alignof(T) <= 8, "White allocation doesn't respect special alignment requests.");

    white_allocator() throw() {}
    white_allocator(const white_allocator&) throw() {}
    template <typename T2> white_allocator(const white_allocator<T2>&) throw() {}
    ~white_allocator() throw() {}

    pointer allocate(const size_t) throw();

    void deallocate(pointer ptr, size_type n)
    {
      //Do nothing for now. We can eventually maintain a list to be reused.
    }

    template <typename U>
    void destroy(offset_ptr<U> ptr)
    {
      ptr->~U();
    }

    void destroy(offset_ptr<T> ptr) {
      ptr->~T();
    }

    template <typename U, typename... Args>
    void construct(offset_ptr<U> ptr, Args&&... args)
    {
      new (static_cast<void*>(ptr)) U(std::forward<Args>(args)...);
    }

    template <typename... Args>
    void construct(offset_ptr<T> ptr, Args&&... args) {
      new (static_cast<void*>(ptr)) T(std::forward<Args>(args)...);
    }
  };

  struct weak_ctrl_map_key {
    ruts::uniform_key id;

    static std::pair<std::size_t, std::size_t> compute_hash(std::size_t num) {
      constexpr static std::size_t prime1 = 32416188191;
      constexpr static std::size_t prime2 = 22801761847;
      std::size_t h1 = 0, h2 = 0;
      std::size_t temp = num;
      for (uint8_t j = 0; j < 7; j++, temp >>= 8) {
        h1 = h1 * prime1 + (temp & 0xff);
      }

      temp = num;
      for (uint8_t j = 0; j < 7; j++, temp >>= 8) {
        h2 = h2 * prime2 + (temp & 0xff);
      }
      return std::make_pair(h1, h2);
    }

    weak_ctrl_map_key() = delete;
    weak_ctrl_map_key(const weak_ctrl_map_key &) = default;
    weak_ctrl_map_key(weak_ctrl_map_key &&) = default;
    weak_ctrl_map_key &operator =(const weak_ctrl_map_key &) = default;
    weak_ctrl_map_key &operator =(weak_ctrl_map_key &&) = default;

    weak_ctrl_map_key(const ruts::uniform_key &key) : id(key) {}
    weak_ctrl_map_key(const ruts::with_uniform_id &wuid) : id(wuid.id) {}

    weak_ctrl_map_key(const offset_ptr<const gc_allocated> &p)
      : id(compute_hash(p.as_number())) {}
    weak_ctrl_map_key(offset_ptr<const gc_allocated> &&p)
      : id(std::move(compute_hash(p.as_number()))) {}

    bool operator==(const weak_ctrl_map_key &other) const {
      return id == other.id;
    }
    bool operator!=(const weak_ctrl_map_key &other) const {
      return id != other.id;
    }

    template <typename CharT, typename Traits>
    friend std::basic_ostream<CharT, Traits> &operator <<(std::basic_ostream<CharT, Traits> &out,
                                                          const weak_ctrl_map_key &key)
    {
      return out << key.id;
    }

  };
}

namespace ruts {
  template <>
  struct hash1<mpgc::weak_ctrl_map_key> {
    auto operator()(const mpgc::weak_ctrl_map_key &key) const {
      return hash1<uniform_key>{}(key.id);
    }
  };
  template <>
  struct hash2<mpgc::weak_ctrl_map_key> {
    auto operator()(const mpgc::weak_ctrl_map_key &key) const {
      return hash2<uniform_key>{}(key.id);
    }
  };
}

namespace mpgc {
  struct weak_ctrl_map_val {
    using T = offset_ptr<const gc_allocated>;
    //static constexpr int64_t buffer_size = mark_buffer<T>::buffer_size;
    static constexpr int64_t buffer_size = 16;
    struct buffer {
      std::atomic<int64_t> idx;
      T buf[buffer_size];
      buffer() : idx(0) {
        std::uninitialized_fill_n(buf, buffer_size, T());
      }
    };

    using val_t = ruts::lf_stack<buffer, white_allocator<buffer>>;
    val_t v;

    void add(const T& p) {
      offset_ptr<buffer> b = v.head();
      while (true) {
        if (!b || b->idx >= buffer_size) {
          offset_ptr<buffer> t = v.allocate();
          v.push(t);
          b = t;
        }
        int64_t i = b->idx++;
        if (i < buffer_size) {
          b->buf[i] = p;
          break;
        }
      }
    }

    template<typename Fn>
    void process_and_remove(Fn &&func) {
      /*
       * Currently we do not try to reuse the buffers. It may
       * be doable, though with caution as other threads might
       * be adding references at the same time.
       */
      offset_ptr<buffer> b = v.head();
      while (b) {
        for (int64_t i = 0; i < buffer_size; i++) {
          T& temp = b->buf[i];
          if (temp != nullptr) {
            std::forward<Fn>(func)(temp);
          }
        }
        b = v.next(b);
      }
    }
  };

  class weak_ctrl_map {
    using key_type = weak_ctrl_map_key;
    using val_type = weak_ctrl_map_val;
    using ptr_type = offset_ptr<val_type>;
    using map_type = ruts::cuckoo_map<key_type, ptr_type,
                                      ruts::hash1<key_type>, ruts::hash2<key_type>,
                                      3, white_allocator<ptr_type>>;
    using val_allocator = white_allocator<val_type>;
    using map_allocator = white_allocator<map_type>;

    union {
      std::atomic<offset_ptr<map_type>> _atomic_map;
      offset_ptr<map_type>              _map;
    };
    std::atomic<offset_ptr<val_type::buffer>> _free_buf_list;
    val_allocator v_alloc;
    map_allocator m_alloc;

    ptr_type store_new(key_type key) {
      bool has_val;
      ptr_type current;
      std::tie(has_val, current) = _map->lookup(key);

      if (has_val) {
        assert(current);
        return current;
      }

      ptr_type new_val = v_alloc.allocate(1);
      v_alloc.construct(new_val);
      //auto rr =
        _map->put_new(key, new_val);
      //TODO: Once cuckoo map is fixed, we don't need to do lookup again.
      std::tie(has_val, current) = _map->lookup(key);
      //We may get a nullptr back as some other GC thread may have removed entry.
      assert(!has_val || current);
      return current;
      /*if (rr.replaced) {
        return new_val;
      } else {
        return rr.old_value;
      }*/
    }

    void initialize() {
      if (!_map) {
        offset_ptr<map_type> exp = nullptr;
        offset_ptr<map_type> des = m_alloc.allocate(1);
        m_alloc.construct(des);
        _atomic_map.compare_exchange_strong(exp, des);
      }
    }

   public:
    weak_ctrl_map() noexcept : _map(nullptr), _free_buf_list(nullptr) {}

    void clear() {
      _map = nullptr;
      _free_buf_list = nullptr;
    }

    bool insert(const offset_ptr<const gc_allocated> &k,
                const offset_ptr<const gc_allocated> &v) {
      initialize();
      ptr_type stack = store_new(k);
      if (stack != nullptr) {
        stack->add(v);
        return true;
      }
      return false;
    }

    template <typename Fn>
    void process_and_remove(const offset_ptr<const gc_allocated> &k, Fn &&func) {
      if (_map != nullptr) {
        ptr_type stack = _map->get(k);
        if (stack) {
          stack->process_and_remove(std::forward<Fn>(func));
          _map->remove(k);
        }
      }
    }
  };
}

#endif //WEAK_CTRL_MAP_H
