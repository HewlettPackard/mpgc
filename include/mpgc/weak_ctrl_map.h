/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#ifndef WEAK_CTRL_MAP_H
#define WEAK_CTRL_MAP_H

#include <utility>
#include <functional>
#include <unordered_map>
#include <unordered_set>

#include "ruts/uniform.h"

namespace mpgc {

/*
 * FIXME: The global control map is the ulimate goal. However,
 * for that to work, the GC-internal data structures need to
 * start using gc heap instead of pheap. Until then we will
 * use the process-local control maps.

  struct weak_ctrl_map_key {
    ruts::uniform_key k;

    weak_ctrl_map_key() = delete;
    weak_ctrl_map_key(const weak_ctrl_map_key &) = default;
    weak_ctrl_map_key(weak_ctrl_map_key &&) = default;
    weak_ctrl_map_key &operator =(const weak_ctrl_map_key &) = default;
    weak_ctrl_map_key &operator =(weak_ctrl_map_key &&) = default;

    constexpr static auto computed = ruts::uniform_key::computed;

    weak_ctrl_map_key(const offset_ptr<const gc_allocated> &p) : k(computed, p) {}
    weak_ctrl_map_key(const offset_ptr<const gc_allocated> &&p) : k(computed, std::move(p)) {}

    bool operator==(const weak_ctrl_map_key &other) const {
      return k == other.k;
    }
    bool operator!=(const weak_ctrl_map_key &other) const {
      return k != other.k;
    }

    template <typename CharT, typename Traits>
    friend std::basic_ostream<CharT, Traits> &operator <<(std::basic_ostream<CharT, Traits> &out,
                                                          const weak_ctrl_map_key &key)
    {
      return out << key.k;
    }

  };

  struct weak_ctrl_map_val {
    using T = const offset_ptr<const gc_allocated>;

    static constexpr int64_t buffer_size = mark_buffer<T>::buffer_size;
    struct buffer {
      std::atomic<int64_t> idx;
      T buf[buffer_size];
      buffer() : idx(0) {
        std::uninitialized_fill_n(buf, buffer_size, T());
      }
    };

    using val_t = ruts::lf_stack<buffer, ruts::managed_space::allocator<buffer>>;
    val_t *v;

    //Allocation of value will be dealt with in the control map itself
    weak_ctrl_map_val() = delete;
  };

  class weak_ctrl_map {
    using key_type = weak_ctrl_map_key;
    using val_type = weak_ctrl_map_val;
    using map_type = cuckoo_map<key_type, val_type, ruts::hash1<key_type>, ruts::hash2<key_type>,
                                10, ruts::managed_space::allocator<val_type>>;
    using Allocator = ruts::managed_space::allocator<val_type::val_t>;
    map_type map;
    Allocator alloc;

   public:    

  };
 */

 using weak_ctrl_map_key = offset_ptr<const gc_allocated>;

 using weak_ctrl_map_val = std::unordered_set<weak_ctrl_map_key, std::hash<weak_ctrl_map_key>,
                           std::equal_to<weak_ctrl_map_key>, ruts::managed_space::allocator<weak_ctrl_map_key>>;

 using weak_ctrl_map = std::unordered_map<weak_ctrl_map_key, weak_ctrl_map_val, std::hash<weak_ctrl_map_key>,
                       std::equal_to<weak_ctrl_map_key>, ruts::managed_space::allocator<std::pair<const weak_ctrl_map_key, weak_ctrl_map_val>>>;
}

#endif //WEAK_CTRL_MAP_H
