/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#ifndef GC_ALLOCATED_H
#define GC_ALLOCATED_H

#include <type_traits>
#include <utility>

#include "mpgc/gc_fwd.h"
#include "mpgc/gc_desc.h"

namespace mpgc {
  namespace gc_handshake {
    struct in_memory_thread_struct;
  }

  namespace gc_allocator {
    class bump_allocation_slots;
  }
  class gc_token {
    friend class gc_allocated;
    friend class gc_allocator::bump_allocation_slots;
    template <typename T> friend class gc_allocator__;
    const gc_descriptor descriptor;
    explicit gc_token(const gc_descriptor &d)
      : descriptor(d) 
    {}
  };


  class gc_allocated {
    gc_descriptor _descriptor;

    friend void allocation_epilogue(gc_handshake::in_memory_thread_struct&, void*, gc_token&, std::size_t);
    //An indicator class to restrict only allocation_epilogue to be able to call the following ctor.
    class only_allocation_epilogue{};
    //Only to be called from allocation epilogue.
    explicit gc_allocated(only_allocation_epilogue, gc_token &gc)
      : _descriptor(gc_descriptor::install{}, gc.descriptor)
    {}
    protected:
    /*
     * By requiring a gc_token parameter, we ensure that
     * anything deriving from this cannot be directly created by
     * anything that can't find one.  In practice, this means that
     * subclasses will need to include this parameter and pass it up,
     * and only make_gc() will be able to call such a ctor.
     *
     * Each subclass T will be expected to ensure that desc_for<T>()
     * exists and provides a gc_descriptor.  The easiest way is to
     * define
     *   static const auto &descriptor();
     * which will create a static local and return it.
     */
    explicit gc_allocated(gc_token &gc) 
      : _descriptor(gc_descriptor::install{}, gc.descriptor)
    {
      //assert(_descriptor.is_valid());
    }
  public:
    /*
     * We turn off all of the implicit ctors and assignment ops.
     * This means that subclasses won't have them, either.
     */
    gc_allocated(const gc_allocated &) = delete;
    gc_allocated(gc_allocated &&) = delete;
    gc_allocated &operator =(const gc_allocated &) = delete;
    gc_allocated &operator =(gc_allocated &) = delete;

    const gc_descriptor& get_gc_descriptor() const {
      return _descriptor;
    }
    gc_descriptor& get_non_const_gc_desc() {
      return _descriptor;
    }
  protected:
    template <typename T>
    static gc_ptr<T> this_as_gc_ptr(T *self) {
      return gc_ptr_from_bare_ptr(self);
    }
#define GC_THIS this_as_gc_ptr(this)    
  };

  template <typename T, typename = void> struct is_gc_allocated : std::false_type {};
  
  template <typename T>
  struct is_gc_allocated<T, std::enable_if_t<std::is_base_of<gc_allocated, T>::value>>
    : std::true_type
  {};

  /*
   * Things that are the same size as gc_allocated and derive
   * from it necessarily don't have anything interesting in them.
   */
  template <typename T>
  struct gc_traits<T,std::enable_if_t<std::is_base_of<gc_allocated, T>::value
				      && sizeof(T) == sizeof(gc_allocated)>> 
    : no_ref_descriptor<T>
  {};

  /*
   * Used to wrap something that isn't otherwise gc_allocated
   */
  template <typename T>
  class gc_wrapped : public gc_allocated {
    T _val;
  public:
    using wrapped_type = T;
    template <typename...Args>
    gc_wrapped(gc_token &gc, Args&&...args)
    : gc_allocated{gc},
      _val(std::forward<Args>(args)...)
      {}
    static const auto &descriptor() {
      static gc_descriptor d =
	GC_DESC(gc_wrapped)
	.template WITH_FIELD(&gc_wrapped::_val);
      return d;
    }

    operator T &() {
      return _val;
    }

    operator const T &() const {
      return _val;
    }

    T & content() {
      return _val;
    }

    const T & content() const {
      return _val;
    }

  };

  template <typename T> struct is_gc_wrapped : std::false_type {};
  template <typename T>
  struct is_gc_wrapped<gc_wrapped<T>> : std::true_type {};
  template <typename T>
  struct is_gc_wrapped<const gc_wrapped<T>> : std::true_type {};
  


}


#endif
