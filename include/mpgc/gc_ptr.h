/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#ifndef GC_PTR_H
#define GC_PTR_H


#include <utility>
#include <type_traits>
#include <cstdint>
#include <iterator>
#include <ostream>

#include "mpgc/write_barrier.h"
#include "mpgc/gc_array.h"
#include "ruts/hashes.h"
#include "ruts/atomic.h"


namespace mpgc {

  /**
   * An indicator used to explicitly construct a gc_ptr from an offset_ptr.
   */
  class gc_ptr_from_offset_ptr {};
  
  template <typename T> class external_gc_ptr;

  /**
   * A strong, possibly null, GC reference.
   *
   * @tparam T the type pointed to.
   *
   * @pre `T` derives from gc_allocated.  This isn't actually checked,
   *       since it is often desirable to use gc_ptr<T> within the
   *       declaration of `T`, and if we cheked, the compiler would
   *       complain that `T` is an incomplete type.  That being said,
   *       it is very difficult (though probably not impossible) to
   *       write code that actually gets called with a non-null gc_ptr
   *       to a value that is not gc_allocated.  If you stick to
   *       copying, assigning, and calling make_gc(), you should
   *       be fine.
   * @pre
   *       If you need to get a safe reference to a GC-friendly member
   *       of a gc_allocated object, use gc_sub_ptr.
   *
   * @warning `T` must not be a polymorphic type.  That is, it must
   * not have any virtual member functions.  We don't check, for the
   * same reason we don't check for derivation from gc_allocated, but
   * it is currently possible to create a polymorphic object on the GC
   * heap.  (We will probably put a check in make_gc() to prevent
   * this.)
   *
   * @par
   * @warning It is very important that the garbage collector be able
   * to find all gc_ptr's.  That means that the *only* safe places to
   * put a gc_ptr are
   * + on the program stack (e.g., as a non-static local variable or
   *   temporary), possibly within an object, or
   * + in an object on the MPGC heap.
   * @warning
   * If you need pointers anyplace else, including
   * + in a global variable
   * + in a class static variable
   * + in a function static variable
   * + in an object created by `new` on the program heap
   * @warning
   * you should use external_gc_ptr<T> instead.  The only exception is
   * if you are **absolutely 100% certain** that there is _also_ an
   * external_gc_ptr to the same object or a gc_ptr to the same object
   * stored in a place MPGC can find it.  If you aren't completely
   * positive (and don't understand the sorts of optimizations a
   * compiler might make), please don't try this.  Getting it wrong
   * can corrupt the MPGC heap irreparably.
   */
  template <typename T>
  class gc_ptr {
//    static_assert(std::is_base_of<gc_allocated,T>::value,
//                  "gc_ptr target type must derive from gc_allocated");
//    static_assert(!(std::is_polymorphic<T>::value),
//                  "gc_ptr target type may not be polymorphic (i.e., may not have virtual functions)");

    /** The underlying offset_ptr. */
    offset_ptr<T> _ptr;

    /**
     * Friended to allow access to the underlying pointer when template parameter differs.
     */
    template <typename Y> friend class gc_ptr;
    /**
     * Friended to allow access allow_ptr_conversion.
     */
    template <typename Y> friend gc_ptr<Y> gc_ptr_from_bare_ptr(Y*);

    /** 
     * A private indicator class for those situations in which you
     * really need to convert from a bare pointer. 
     * 
     * Used by gc_ptr_from_bare_ptr().
     */
    class allow_ptr_conversion{};

  public:
    /** The type of the object being pointed to */
    using element_type = T;

    /** 
     * A reference to the object pointed to.
     *
     * @note This is specialized to allow the specialization for
     * pointers to wrapped values.
     *
     * @pre this pointer is not null.
     */
    template <typename S=T, typename = std::enable_if_t<!is_gc_wrapped<S>::value> >
    T &operator *() const {
      return *_ptr;
    }

    /** 
     * A reference to the content of the wrapped object pointed to.
     *
     * @pre this pointer is not null.
     * @par
     * @pre `T` is `gc_wrapped<X>` for some `X`.
     */
    template <typename S=T, typename = std::enable_if_t<is_gc_wrapped<S>::value> >
    auto &operator *() const {
      return _ptr->content();
    }

    /** 
     * Dereferece through the pointer 
     *
     * @returns the underlying offset pointer, which is itself
     * dereferenced.
     *
     * @note This is specialized to allow the specialization for
     * pointers to wrapped values.
     *
     * @pre the pointer is not null.
     **/
    template <typename S=T, typename = std::enable_if_t<!is_gc_wrapped<S>::value> >
    offset_ptr<T> operator ->() const noexcept {
      return _ptr;
    }

    /** 
     * Dereferece through the pointer to the content of a wrapped
     * object.
     *
     * @returns the underlying offset pointer, which is itself
     * dereferenced.
     *
     * @pre the pointer is not null.
     * @par
     * @pre `T` is `gc_wrapped<X>` for some `X`.
     **/
    template <typename S=T, typename = std::enable_if_t<is_gc_wrapped<S>::value> >
    auto *operator ->() const noexcept {
      return &_ptr->content();
    }


    /**
     * Default construction creates a null pointer.
     */
    constexpr gc_ptr() noexcept : _ptr{nullptr} {};
    /**
     * Conversion from `nullptr` is allowed and `constexpr`.
     */
    constexpr gc_ptr(std::nullptr_t) noexcept : gc_ptr{} {}
    /**
     * Explicit conversion from a bare pointer.
     *
     * @param "(allow_ptr_conversion)" indicator 
     * @param p a bare pointer to the object.
     *
     * This is only used by gc_ptr_from_bare_ptr().  
     */
    gc_ptr(allow_ptr_conversion, T *p) noexcept : _ptr{p} {}

    /**
     * Explicit copy construction from a compatible offset_ptr.
     *
     * @tparam Y type pointer-assignable to `T`.
     * @param rhs an offset_ptr<Y>.
     */
    template <typename Y, typename = std::enable_if_t<std::is_assignable<T*&,Y*>::value> >
    gc_ptr(gc_ptr_from_offset_ptr, const offset_ptr<Y> &rhs) noexcept : _ptr{rhs} {}

    /**
     * Explicit move construction from a compatible offset_ptr.
     *
     * @tparam Y type pointer-assignable to `T`.
     * @param rhs an offset_ptr<Y>.
     */
    template <typename Y, typename = std::enable_if_t<std::is_assignable<T*&,Y*>::value> >
    gc_ptr(gc_ptr_from_offset_ptr, offset_ptr<Y> &&rhs) noexcept : _ptr{std::move(rhs)} {}

    /**
     * Copy a compatible offset_ptr as a gc_ptr.
     *
     * @tparam Y type pointer-assignable to `T`.
     * @param rhs an offset_ptr<Y>.
     */
    template <typename Y, typename = std::enable_if_t<std::is_assignable<T*&,Y*>::value> >
    static gc_ptr from_offset_ptr(const offset_ptr<Y> &rhs) noexcept {
      return gc_ptr(gc_ptr_from_offset_ptr{}, rhs);
    }
    /**
     * Move a compatible offset_ptr as a gc_ptr.
     *
     * @tparam Y type pointer-assignable to `T`.
     * @param rhs an offset_ptr<Y>.
     */
    template <typename Y, typename = std::enable_if_t<std::is_assignable<T*&,Y*>::value> >
    static gc_ptr from_offset_ptr(offset_ptr<Y> &&rhs) noexcept {
      return gc_ptr(gc_ptr_from_offset_ptr{}, std::move(rhs));
    }

    /**
     * Create an array of a given size.
     *
     * @pre `T` is a gc_array.
     *
     * This allows you to say
     * ~~~
     * gc_array_ptr<X> a(5);
     * ~~~
     * to create a five-element array rather than having to say
     * ~~~
     * gc_array_ptr<X> a = make_gc_array<X>(5);
     * ~~~
     */
    template <typename S=T, typename E=std::enable_if_t<is_gc_array<S>::value> >
    explicit gc_ptr(typename S::size_type count)
    : gc_ptr{make_gc_array<typename S::arg_type>(count)}
    {}

    /**
     * Default copy construction.
     *
     * @note Construction not require a write barrier.
     */
    gc_ptr(const gc_ptr &rhs) noexcept = default;
    /**
     * Default move construction.
     *
     * @note Does not require a write barrier.
     * @par
     * @note The source of the move is not cleared. 
     */
    gc_ptr(gc_ptr &&rhs) noexcept = default;
    /**
     * Copy assignment operator.
     *
     * @note Requires a write barrier.
     */
    gc_ptr &operator =(const gc_ptr &rhs) noexcept {
      write_barrier(_ptr, rhs._ptr, [&] {
        _ptr = rhs._ptr;
      });
      return *this;
    }
    /**
     * Move assignment operator.
     *
     * @note Requires a write barrier.
     * @par
     * @note The source of the move is not cleared.
     */
    gc_ptr &operator =(gc_ptr &&rhs) noexcept {
      write_barrier(_ptr, rhs._ptr, [&, rhs = std::move(rhs)] () mutable {
        _ptr = std::move(rhs._ptr);
      });
      return *this;
    }

    /**
     * Copy construction from assignment-compatible gc_ptr.
     *
     * @note Does not require a write barrier.
     */
    template <typename Y, typename = std::enable_if_t<std::is_assignable<T*&,Y*>::value> >
    gc_ptr(const gc_ptr<Y> &rhs) noexcept : _ptr{rhs._ptr} {}

    /**
     * Move construction from assignment-compatible gc_ptr.
     *
     * @note Does not require a write barrier.
     * @par
     * @note The source of the move is not cleared.
     */
    template <typename Y, typename = std::enable_if_t<std::is_assignable<T*&,Y*>::value> >
    gc_ptr(gc_ptr<Y> &&rhs) noexcept : _ptr{std::move(rhs._ptr)} {}

    /**
     * Copy construction from assignment-compatible external_gc_ptr.
     *
     * @note Does not require a write barrier.
     */
    template <typename Y, typename = std::enable_if_t<std::is_assignable<T*&,Y*>::value> >
    gc_ptr(const external_gc_ptr<Y> &rhs) noexcept : gc_ptr{rhs.value()} {}

    /**
     * Move construction from assignment-compatible external_gc_ptr.
     *
     * @note Does not require a write barrier.
     * @par
     * @note Unlike move constructing from a gc_ptr, here we do clear
     * the source external_gc_ptr.
     */
    template <typename Y, typename = std::enable_if_t<std::is_assignable<T*&,Y*>::value> >
    gc_ptr(external_gc_ptr<Y> &&rhs) noexcept : gc_ptr{std::move(rhs.value())} {
      rhs = nullptr;
    }


    /**
     * Copy assignment from assignment-compatible gc_ptr.
     *
     * @note Requires a write barrier.
     */
    template <typename Y, typename = std::enable_if_t<std::is_assignable<T*&,Y*>::value> >
    gc_ptr &operator =(const gc_ptr<Y> &rhs) noexcept {
      write_barrier(_ptr, rhs._ptr, [&] {
        _ptr = rhs._ptr;
      });
      return *this;
    }
    /**
     * Move assignment from assignment-compatible gc_ptr.
     *
     * @note Requires a write barrier.
     * @par
     * @note The source of the move is not cleared.
     */
    template <typename Y, typename = std::enable_if_t<std::is_assignable<T*&,Y*>::value> >
    gc_ptr &operator =(gc_ptr<Y> &&rhs) noexcept {
      write_barrier(_ptr, rhs._ptr, [&, rhs = std::move(rhs)] () mutable {
        _ptr = std::move(rhs._ptr);
      });
      return *this;
    }

    /**
     * A bare pointer pointing to the referenced object.
     *
     * @warning The pointer returned may become a dangling pointer if
     * the object referred to is garbage collected.  If it is later
     * reconstituted as a gc_ptr by calling gc_ptr_from_bare_ptr(), it
     * could break the MPGC system.  It is usually only safe to use
     * the pointer returned (e.g., as a parameter to a function that
     * requires a bare pointer) while holding on to the gc_ptr to the
     * object.
     */
    element_type *as_bare_pointer() const noexcept {
      return _ptr.as_bare_pointer();
    }

    /**
     * An offset_ptr pointing to the referenced object.
     *
     * @warning The pointer returned may become a dangling pointer if
     * the object referred to is garbage collected.  If it is later
     * reconstituted as a gc_ptr, it could break the MPGC system.  It
     * is usually only safe to use the pointer returned (e.g., as a
     * parameter to a function that requires an offset_ptr) while
     * holding on to the gc_ptr to the object.
     */
    const offset_ptr<T> &as_offset_pointer() const noexcept {
      return _ptr;
    }

    /* Not clear if this is needed */
    //    constexpr bool is_valid() const noexcept {
    //      return _ptr.is_valid();
    //    }

    /**
     * Swap this gc_ptr with another.
     *
     * @param other another gc_ptr<T>.
     *
     * @note This requires two write barriers, since we need to make
     * sure that both of the pointers are marked during tracing.
     */
    void swap (gc_ptr &other) noexcept {
      //Need to call separately as the barrier *must* be called on both.
      write_barrier(_ptr, nullptr, []{});
      write_barrier(other._ptr, nullptr, [&] {
        std::swap(_ptr, other._ptr);
      });
    }

    /**
     * Convert to `bool` by testing whether the pointer is null.
     *
     * As with bare pointers, a gc_ptr converts to `false` if it is
     * null and `true` otherise.
     */
    constexpr operator bool() const noexcept {
      return _ptr != nullptr;
    }

    /**
     * The size of a referenced gc_array or `0` if null.
     *
     * @pre `T` is a gc_array.
     *
     * Allows you to say
     * ~~~
     * gc_array_ptr<X> a;
     * ...
     * size_t n = a.size();
     * ~~~
     * without worrying about whether the pointer is null.
     */
    template <typename S=T, typename E=std::enable_if_t<is_gc_array<S>::value> >
    typename S::size_type size() const {
      return _ptr == nullptr ? 0 : _ptr->size();
    }


    /**
     * Whether a referenced gc_array is empty (size zero).
     *
     * @pre `T` is a gc_array.
     *
     * Actual gc_array objects are never empty, so this merely tests
     * the pointer.
     * Allows you to say
     * ~~~
     * gc_array_ptr<X> a;
     * ...
     * if (a.empty()) { ... }
     * ~~~
     */
    template <typename S=T, typename E=std::enable_if_t<is_gc_array<S>::value> >
    bool empty() const {
      return _ptr == nullptr;
    }

    /**
     * Index into a referenced gc_array.
     *
     * @param pos the index into the array.
     *
     * @returns a reference to the array element.  This is a const
     * reference if the pointer is to a const gc_array.
     *
     * @pre `T` is a gc_array.
     * @par
     * @pre the pointer is not null.
     * @par
     * @pre `pos` is in the array.
     *
     * @warning The reference returned is currently an unchecked bare
     * C++ reference.  If the pointer is null or if the index is out
     * of bounds, this will be referring to random memory on the heap.
     * Also, if the array gets collected, these will be dangling
     * references.
     * @warning Both of these issues are expected to be fixed soon,
     * which will result in an assertion failure for the first two
     * cases and the reference holding on to the array for the latter
     * case, but for now you have to be careful.
     * 
     */
    template <typename S=T, typename E=std::enable_if_t<is_gc_array<S>::value> >
    auto &operator[](typename S::size_type pos) const {
      // throw something if null
      return (*_ptr)[pos];
    }

    /**
     * Convert a pointer to a const gc_array to a gc_array::const_iterator.
     *
     * As with bare pointers, a gc_ptr to an array can be treated as
     * an iterator pointing to the first element of the array.  If the
     * pointer is a null pointer, this will be a null iterator.
     * gc_array iterators hold a GC reference to the array as a whole,
     * so it is safe to store them.
     * 
     * @pre `T` is a const gc_array.
     */
    template <typename S=T, typename E=std::enable_if_t<is_gc_array<S>::value && std::is_const<S>::value >>
    operator typename S::const_iterator() const {
      return _ptr == nullptr ? typename S::const_iterator{} : _ptr->cbegin();
    }

    /**
     * Convert a pointer to a non-const gc_array to a gc_array::iterator.
     *
     * As with bare pointers, a gc_ptr to an array can be treated as
     * an iterator pointing to the first element of the array.  If the
     * pointer is a null pointer, this will be a null iterator.
     * gc_array iterators hold a GC reference to the array as a whole,
     * so it is safe to store them.
     * 
     * @pre `T` is a non-const gc_array.
     */
    template <typename S=T, typename E=std::enable_if_t<is_gc_array<S>::value && !std::is_const<S>::value >>
    operator typename S::iterator() const {
      return _ptr == nullptr ? typename S::iterator{} : _ptr->begin();
    }

    /**
     * Obtain an iterator indexing into a referenced gc_array.
     *
     * @param delta an index into the array.  May be negative.  
     *
     * @returns an iterator or const_iterator into the array
     * (depending on whether `T` is a const gc_array or a non-const
     * gc_array).
     * 
     * If the pointer is a null pointer, this will be a null iterator,
     * otherwise it will be an iterator to the appropriate element.
     * It's okay if this is out of bounds (or even negative) as long
     * as you don't try to dereference it without further adding
     * values to get it in bounds.  gc_array iterators hold a GC
     * reference to the array as a whole, so it is safe to store them.
     * 
     * @pre `T` is a gc_array.
     */
    template <typename S=T, typename E=std::enable_if_t<is_gc_array<S>::value>>
    auto operator +(typename S::const_iterator::difference_type delta) const {
      // If _ptr is null, delta had better be zero.  To be safe, we'll just return null
      return _ptr == nullptr ? decltype(_ptr->begin()+delta){} : _ptr->begin()+delta;
    }

    /**
     * Obtain an iterator to the beginning of a referenced gc_array.
     *
     * @returns an iterator or const_iterator into the array
     * (depending on whether `T` is a const gc_array or a non-const
     * gc_array).  
     * 
     * If the pointer is a null pointer, this will be a null iterator,
     * otherwise it will be an iterator to the first element.
     * 
     * @pre `T` is a gc_array.
     */
    template <typename S=T, typename E=std::enable_if_t<is_gc_array<S>::value>>
    auto begin() const {
      return _ptr == nullptr ? decltype(_ptr->begin()){} : _ptr->begin();
    }
    /**
     * Obtain an iterator to the end of a referenced gc_array.
     *
     * @returns an iterator or const_iterator into the array
     * (depending on whether `T` is a const gc_array or a non-const
     * gc_array).  
     * 
     * If the pointer is a null pointer, this will be a null iterator,
     * otherwise it will be an iterator past the last element..
     * 
     * @pre `T` is a gc_array.
     */
    template <typename S=T, typename E=std::enable_if_t<is_gc_array<S>::value>>
    auto end() const {
      return _ptr == nullptr ? decltype(_ptr->end()){} : _ptr->end();
    }
    /**
     * Obtain a const iterator to the beginning of a referenced gc_array.
     *
     * @returns a const_iterator into the array.
     * 
     * If the pointer is a null pointer, this will be a null iterator,
     * otherwise it will be an iterator to the first element.
     * 
     * @pre `T` is a gc_array.
     */
    template <typename S=T, typename E=std::enable_if_t<is_gc_array<S>::value>>
    auto cbegin() const {
      return _ptr == nullptr ? decltype(_ptr->cbegin()){} : _ptr->cbegin();
    }
    /**
     * Obtain a const iterator to the end of a referenced gc_array.
     *
     * @returns a const_iterator into the array.
     * 
     * If the pointer is a null pointer, this will be a null iterator,
     * otherwise it will be an iterator past the last element..
     * 
     * @pre `T` is a gc_array.
     */
    template <typename S=T, typename E=std::enable_if_t<is_gc_array<S>::value>>
    auto cend() const {
      return _ptr == nullptr ? decltype(_ptr->cend()){} : _ptr->cend();
    }

    
    /**
     * Obtain a reverse iterator to the end of a referenced gc_array.
     * Incrementing this will enumerate the elements in reverse order.
     *
     * @returns an iterator or const_iterator into the array
     * (depending on whether `T` is a const gc_array or a non-const
     * gc_array).  
     * 
     * If the pointer is a null pointer, this will be a null iterator,
     * otherwise it will be a reverse iterator to the last element.
     * 
     * @pre `T` is a gc_array.
     */
    template <typename S=T, typename E=std::enable_if_t<is_gc_array<S>::value>>
    auto rbegin() const {
      return _ptr == nullptr ? decltype(_ptr->rbegin()){} : _ptr->rbegin();
    }
    /**
     * Obtain a reverse iterator to the beginning of a referenced gc_array.
     * This signals the end of a reverse iteration.
     *
     * @returns an iterator or const_iterator into the array
     * (depending on whether `T` is a const gc_array or a non-const
     * gc_array).  
     * 
     * If the pointer is a null pointer, this will be a null iterator,
     * otherwise it will be a reverse iterator before the first element.
     * 
     * @pre `T` is a gc_array.
     */
    template <typename S=T, typename E=std::enable_if_t<is_gc_array<S>::value>>
    auto rend() const {
      return _ptr == nullptr ? decltype(_ptr->rend()){} : _ptr->rend();
    }
    /**
     * Obtain a const reverse iterator to the end of a referenced
     * gc_array.  Incrementing this will enumerate the elements in
     * reverse order.
     *
     * @returns a const_iterator into the array.  
     * 
     * If the pointer is a null pointer, this will be a null iterator,
     * otherwise it will be a reverse iterator to the last element.
     * 
     * @pre `T` is a gc_array.
     */
    template <typename S=T, typename E=std::enable_if_t<is_gc_array<S>::value>>
    auto crbegin() const {
      return _ptr == nullptr ? decltype(_ptr->crbegin()){} : _ptr->crbegin();
    }
    /**
     * Obtain a const reverse iterator to the beginning of a
     * referenced gc_array.  This signals the end of a reverse
     * iteration.
     *
     * @returns a const_iterator into the array.  
     * 
     * If the pointer is a null pointer, this will be a null iterator,
     * otherwise it will be a reverse iterator before the first element.
     * 
     * @pre `T` is a gc_array.
     */
    template <typename S=T, typename E=std::enable_if_t<is_gc_array<S>::value>>
    auto crend() const {
      return _ptr == nullptr ? decltype(_ptr->crend()){} : _ptr->crend();
    }


    /**
     * Compute the first hash by delegating to the underlying bare pointer.
     *
     * hash1() and hash2() allow gc_ptr to be used as a key in
     * gc_cuckoo_map, as long as there is a specialization for
     * hash1<T*>() and hash2<T*>().
     */
    constexpr std::uint64_t hash1() const {
      return _ptr.hash1();
    }
    /**
     * Compute the second hash by delegating to the underlying bare pointer.
     *
     * hash1() and hash2() allow gc_ptr to be used as a key in
     * gc_cuckoo_map, as long as there is a specialization for
     * hash1<T*>() and hash2<T*>().
     */
    constexpr std::uint64_t hash2() const {
      return _ptr.hash2();
    }
    
    template <typename X, typename Y> friend mpgc::gc_ptr<X> std::static_pointer_cast(const mpgc::gc_ptr<Y> &);
    template <typename X, typename Y> friend mpgc::gc_ptr<X> std::dynamic_pointer_cast(const mpgc::gc_ptr<Y> &);
    template <typename X, typename Y> friend mpgc::gc_ptr<X> std::const_pointer_cast(const mpgc::gc_ptr<Y> &);
    template <typename X, typename Y> friend bool operator ==(const gc_ptr<X> &, const gc_ptr<Y> &);
    template <typename X, typename Y> friend bool operator ==(const X *, const gc_ptr<Y> &);
    template <typename X, typename Y> friend bool operator ==(const gc_ptr<X> &, const Y *);
  };

  /**
   * @related gc_ptr.
   */
  template <typename X, typename Y>
  inline
  bool operator ==(const gc_ptr<X> &lhs, const gc_ptr<Y> &rhs) {
    return lhs._ptr == rhs._ptr;
  }
  /**
   * @related gc_ptr.
   */
  template <typename X, typename Y>
  inline
  bool operator ==(const X *lhs, const gc_ptr<Y> &rhs) {
    return lhs == rhs._ptr;
  }
  /**
   * @related gc_ptr.
   */
  template <typename X, typename Y>
  inline
  bool operator ==(const gc_ptr<X> &lhs, const Y *rhs) {
    return lhs._ptr == rhs;
  }
  /**
   * @related gc_ptr.
   */
  template <typename X, typename Y>
  inline
  bool operator !=(const gc_ptr<X> &lhs, const gc_ptr<Y> &rhs) {
    return !(lhs == rhs);
  }
  /**
   * @related gc_ptr.
   */
  template <typename X, typename Y>
  inline
  bool operator !=(const X *lhs, const gc_ptr<Y> &rhs) {
    return !(lhs == rhs);
  }
  /**
   * @related gc_ptr.
   */
  template <typename X, typename Y>
  inline
  bool operator !=(const gc_ptr<X> &lhs, const Y *rhs) {
    return !(lhs == rhs);
  }
  /**
   * @related gc_ptr.
   */
  template <typename T>
  inline
  bool operator ==(const gc_ptr<T> &lhs, std::nullptr_t) {
    return !lhs;
  }
  /**
   * @related gc_ptr.
   */
  template <typename T>
  inline
  bool operator ==(std::nullptr_t, const gc_ptr<T> &rhs) {
    return !rhs;
  }
  /**
   * @related gc_ptr.
   */
  template <typename T>
  inline
  bool operator !=(const gc_ptr<T> &lhs, std::nullptr_t) {
    return lhs;
  }
  /**
   * @related gc_ptr.
   */
  template <typename T>
  inline
  bool operator !=(std::nullptr_t, const gc_ptr<T> &rhs) {
    return rhs;
  }

  /**
   * A smart pointer into a gc_allocated object.  
   * 
   * This pointer holds an gc_ptr anchor to the enclosing object to
   * ensure that it doesn't get collected.
   *
   * @tparam T the type of the member field.
   *
   * @warning The same rules apply to gc_sub_ptr as to gc_ptr with
   * regard to where these can be put.  If you want to put one in a
   * place where you would use external_gc_ptr rather than gc_ptr, you
   * should use external_gc_sub_ptr instead.
   */
  template <typename T>
  class gc_sub_ptr {
  public:
    using value_type = T;
    using element_type = value_type;
    using reference = gc_sub_ref<T>;
    using size_type = std::size_t;
    using difference_type = std::ptrdiff_t;
    using iterator_category = std::random_access_iterator_tag;
    using pointer = value_type *;
  private:
    /**
     * The enclosing object.
     *
     * Since the gc_sub_ptr holds onto the enclosing object, it is
     * guaranteed that the object will not get collected and the
     * gc_sub_ptr will remain valid.
     */
    gc_anchor _enclosing;
    /**
     * The offset of the field, in chars, from the target of
     * _enclosing.
     *
     * The offset is kept in bytes rather than words so that the
     * gc_sub_ptr can point to members that aren't word-aligned.
     */
    size_type _offset;	

    /**
     * Convert a bare pointer to a byte pointer.
     */
    constexpr static const std::uint8_t *to_char_ptr(const void *ptr) {
      return reinterpret_cast<const std::uint8_t *>(ptr);
    }
    /**
     * Convert a gc_ptr to a byte pointer.
     */
    constexpr static const std::uint8_t *to_char_ptr(const gc_anchor &gcp) {
      return gcp == nullptr ? nullptr : to_char_ptr(gcp.as_bare_pointer());
    }

    /**
     * The number of bytes for a given number of objects.
     *
     * @param diff a (possibly negative) number of objects.
     *
     * This is used by adjust_offset() to compute a new offset when
     * adding or subtracting from a gc_sub_ptr.
     */
    constexpr static difference_type sizeof_n(difference_type diff) {
      return diff*sizeof(T);
    }
    /**
     * Compute a new offset value a number of objects away from this.
     *
     * @param diff a (possibly negative) number of objects.
     *
     * This is used when adding to a pointer.
     * 
     * @pre The difference is either nonnegative or doesn't result in
     * pointing back before the beginning of the enclosing object.
     * (That is, the resulting offset can't be negative).  This is
     * checked by an assertion.
     * @par
     * @pre The resulting offset, if dereferenced, doesn't extend past
     * the boundaries of the member.  This is not checked.
     */
    constexpr size_type adjust_offset(difference_type diff) {
      assert(diff >= 0|| _offset >= sizeof_n(diff));
      return _offset + sizeof_n(diff);
    }
    /**
     * A bare pointer pointing to the referenced member.
     *
     * @warning The pointer returned may become a dangling pointer if
     * the object referred to is garbage collected.  If it is later
     * reconstituted as a gc_ptr by calling gc_ptr_from_bare_ptr(), it
     * could break the MPGC system.  It is usually only safe to use
     * the pointer returned (e.g., as a parameter to a function that
     * requires a bare pointer) while holding on to the gc_ptr to the
     * object.
     */
    constexpr T *as_bare_pointer() const {
      return const_cast<T*>(reinterpret_cast<const T*>(to_char_ptr(_enclosing)+_offset));
    }
    /**
     * An indicator class used to gain access to private ctors.
     */
    class private_ctor{};

    /**
     * Construct a gc_sub_ptr with a given enclosing object and byte offset.
     *
     * @param "(private_ctor)" an indicator.
     * @param e a gc_ptr to the enclosing object.
     * @param o the offset, in bytes.
     * @pre The offset is nonnegative.
     */
    constexpr gc_sub_ptr(private_ctor, const gc_anchor &e, difference_type o)
      : _enclosing{e}, _offset{static_cast<size_type>(o)}
    {
      // GCC Doesn't like constexpr ctors with bodies
      //      assert(o >= 0);
    }
    
  public:
    /**
     * Create a default gc_sub_ptr or a null gc_sub_ptr.
     */
    constexpr gc_sub_ptr(nullptr_t n = nullptr) : _enclosing{}, _offset{0} {}
    /**
     * Create a gc_sub_ptr given a bare pointer to the member and a
     * gc_ptr to the enclosing object.
     *
     * @param p a bare pointer to the member.
     * @param obj a gc_ptr to the enclosing object.
     *
     * @pre The pointed-to member is inside the object.  This is not
     * checked.  
     
     * @warning If this precondition is not met, there is no guarantee
     * that the member will not be collected, which will probably
     * result in MPGC heap corruption.  It is much safer to use
     * gc_sub_ptr(U C::*,const gc_ptr<C>&) when possible.
     */
    constexpr gc_sub_ptr(T *p, const gc_anchor &obj)
      : gc_sub_ptr(private_ctor{}, obj, to_char_ptr(p) - to_char_ptr(obj))
    {}

    /**
     * Create a gc_sub_ptr given a gc_ptr to an enclosing object and a
     * ptr-to-member into the enclosing class.  
     *
     * This is the safe way to construct a non-null gc_sub_ptr.
     *
     * @tparam U the type of the member, which must be ptr-assignment
     * compatible with `T`.
     * @tparam C the type of the enclosing object.
     * @param m a ptr-to-member of type `U` within `C` (`U C::*`).
     * @param e a gc_ptr to the enclosing object of type `C`.
     */
    template <typename U, typename C,
              typename = std::enable_if_t<std::is_assignable<T*&, U*>::value> >
    constexpr gc_sub_ptr(U C::*m, const gc_ptr<C> &e) : gc_sub_ptr(&((*e).*m), e) {}

    /** 
     * Default copy ctor.
     *
     * Note that the enclosing objects do not need to be of the same type.
     */
    gc_sub_ptr(const gc_sub_ptr &) = default;
    /** 
     * Copy ctor when member types are pointer-assignment compatible.
     *
     * Note that the enclosing objects do not need to be of the same type.
     */
    template <typename U, typename = std::enable_if_t<std::is_assignable<T*&, U*>::value> >
    constexpr gc_sub_ptr(const gc_sub_ptr<U> &rhs)
    : _enclosing{rhs._enclosing}, _offset{rhs._offset}
    {}

    /** 
     * Default move ctor.
     *
     * Note that the enclosing objects do not need to be of the same type.
     */
    gc_sub_ptr(gc_sub_ptr &&) = default;

    /** 
     * Move ctor when member types are pointer-assignment compatible.
     *
     * Note that the enclosing objects do not need to be of the same type.
     */
    template <typename U, typename = std::enable_if_t<std::is_assignable<T*&, U*>::value> >
    constexpr gc_sub_ptr(gc_sub_ptr<U> &&rhs)
    : _enclosing{std::move(rhs._enclosing)},
      _offset{std::move(rhs._offset)}
    {}

    /**
     * Print the pointer on an output stream.
     *
     * @param os the stream to print on.
     * 
     * @returns the result of printing (typically, the stream).
     */
    template <typename C, typename Tr>
    std::basic_ostream<C,Tr> &print_on(std::basic_ostream<C,Tr> &os) const {
      return os << _enclosing << "+" << _offset;
    }

    static const auto &descriptor() {
      static gc_descriptor d =
	GC_DESC(gc_sub_ptr)
	.template WITH_FIELD(&gc_sub_ptr::_enclosing)
	.template WITH_FIELD(&gc_sub_ptr::_offset);
      return d;
    }

    /** 
     * Default copy assignment operator.
     *
     * Note that the enclosing objects do not need to be of the same type.
     */
    gc_sub_ptr &operator =(const gc_sub_ptr &) = default;
    /** 
     * Copy assignment operator when member types are pointer-assignment compatible.
     *
     * Note that the enclosing objects do not need to be of the same type.
     */
    template <typename U, typename = std::enable_if_t<std::is_assignable<T*&, U*>::value>>
    gc_sub_ptr &operator =(const gc_sub_ptr<U> &rhs) {
      // TODO: There's a race condition here.  This will go away if
      // we require these to be on the stack objs.
      _offset = rhs._offset;
      _enclosing = rhs._enclosing;
      return *this;
    }

    /** 
     * Default move assignment operator.
     *
     * Note that the enclosing objects do not need to be of the same type.
     */
    gc_sub_ptr &operator =(gc_sub_ptr &&) = default;
    /** 
     * Move assignment operator when member types are pointer-assignment compatible.
     *
     * Note that the enclosing objects do not need to be of the same type.
     */
    template <typename U, typename = std::enable_if_t<std::is_assignable<T*&, U*>::value>>
    gc_sub_ptr &operator =(gc_sub_ptr<U> &&rhs) {
      // TODO: There's a race condition here.  This will go away if
      // we require these to be on the stack objs.
      _offset = std::move(rhs._offset);
      _enclosing = std::move(rhs._enclosing);
    }

    /** 
     * Test whether this is a null gc_sub_ptr.
     *
     * A null gc_sub_ptr has null #_enclosing and zero #_offset.
     */
    constexpr bool is_null() const {
      return _enclosing == nullptr && _offset == 0;
    }

    /**
     * Test whether this equals nullptr.
     *
     * Equivalent to is_null().
     */
    constexpr bool operator ==(nullptr_t) const {
      return is_null();
    }
    template <typename U>
    constexpr bool operator ==(const gc_sub_ptr<U> &rhs) const {
      return _enclosing == rhs._enclosing
	&& _offset == rhs._offset;
    }
    template <typename U>
    bool operator ==(U *ptr) const {
      return as_bare_pointer() == ptr;
    }

    /**
     * Default inequality op that inverts equality.
     */
    template <typename U>
    bool operator !=(U&& rhs) const {
      return !(*this == std::forward<U>(rhs));
    }

    /*
     * Returns true when bound to an object, false when unbound
     * If we allow this, then begin()+5 is technically ambiguous
     * between this->operator +(5) and static_cast<bool>(*this)+5;
     * Dumb.
     */

//    operator bool() const {
//      return _ptr != nullptr;
//    }

    /**
     * Dereference through as_bare_pointer().
     *
     * @pre Pointer is not null.
     */
    value_type *operator ->() const {
      return as_bare_pointer();
    }

    /**
     * A gc_sub_ref to the pointed-to member.
     *
     * The returned gc_sub_ref also holds on to the enclosing object,
     * so the member is guaranteed to stick around as long as the
     * gc_sub_ref does.
     *
     * @pre The pointer is not null.  This is checked by assertion.
     */
    reference operator *() const {
      assert(!is_null());
      return reference{*as_bare_pointer(), _enclosing};
    }

    /**
     * A gc_sub_ref to an element of the referenced array.
     *
     * @param i an index into the array.
     * 
     * @pre The pointer is not null.  This is checked by assertion.
     * @par
     *
     * @pre The pointer points into a (member) array and the index
     * refers to a valid index of the array.  This is not checked.
     *
     * @warning If the index doesn't refer to a valid index of an
     * array, you will probably corrupt the MPGC heap if you try to
     * assign through the resulting gc_sub_ref.
     */
    reference operator [](size_type i) const {
      assert(!is_null());
      return reference{*(as_bare_pointer()+i), _enclosing};
    }

    /**
     * Adjust the offset to point to a different array element.
     *
     * @param diff the number of elements to move.  This may be
     * negative.
     * @pre The pointer is not null.  This is checked by assertion.
     *
     * @warning If the resulting pointer doesn't refer to a valid
     * element of an array, you will probably corrupt the MPGC heap if
     * you try to assign through dereferencing this gc_sub_ptr.
     */
    gc_sub_ptr &operator +=(difference_type diff) {
      assert(!is_null());
      _offset = adjust_offset(diff);
      return *this;
    }
    gc_sub_ptr &operator -=(difference_type diff) {
      return (*this) += (-diff);
    }

    gc_sub_ptr &operator ++() {
      return (*this) += 1;
    }
    gc_sub_ptr &operator --() {
      return (*this) -= 1;
    }

    gc_sub_ptr operator ++(int) {
      gc_sub_ptr old{*this};
      operator++();
      return old;
    }
    gc_sub_ptr operator --(int) {
      gc_sub_ptr old{*this};
      operator--();
      return old;
    }

    constexpr gc_sub_ptr operator +(difference_type diff) const {
      return gc_sub_ptr{private_ctor{}, _enclosing, adjust_offset(diff)};
    }
    constexpr gc_sub_ptr operator -(difference_type diff) const {
      return gc_sub_ptr{private_ctor{}, _enclosing, adjust_offset(-diff)};
    }

    template <typename U>
    constexpr difference_type operator -(const gc_sub_ptr<U> &other) const {
      return as_bare_pointer() - other.as_bare_pointer();
    }

    template <typename U>
    bool operator <(const gc_sub_ptr<U> &other) const {
      return as_bare_pointer() < other.as_bare_pointer();
    }
    template <typename U>
    bool operator >(const gc_sub_ptr<U> &other) const {
      return as_bare_pointer() > other.as_bare_pointer();
    }
    template <typename U>
    bool operator <=(const gc_sub_ptr<U> &other) const {
      return as_bare_pointer() <= other.as_bare_pointer();
    }
    template <typename U>
    bool operator >=(const gc_sub_ptr<U> &other) const {
      return as_bare_pointer() >= other.as_bare_pointer();
    }

  };

  template <typename U>
  inline bool operator ==(nullptr_t, const gc_sub_ptr<U> &rhs) {
    return rhs == nullptr;
  }
  template <typename T, typename U>
  inline bool operator ==(T *lhs, const gc_sub_ptr<U> &rhs) {
    return rhs == lhs;
  }
  template <typename U>
  inline bool operator !=(nullptr_t, const gc_sub_ptr<U> &rhs) {
    return rhs != nullptr;
  }
  template <typename T, typename U>
  inline bool operator !=(T *lhs, const gc_sub_ptr<U> &rhs) {
    return rhs != lhs;
  }

  template <typename T>
  class gc_sub_ref {
    const gc_anchor _enclosing;
    T &_ref;
    template <typename U> friend class gc_sub_ptr;
    gc_sub_ref(T &r, const gc_anchor &obj) : _enclosing{obj}, _ref{r} {}
  public:
    gc_sub_ref &operator =(const T &rhs) {
      _ref = rhs;
      return *this;
    }
    gc_sub_ref &operator =(T &&rhs) {
      _ref = std::move(rhs);
      return *this;
    }
    template <typename U>
    gc_sub_ref &operator =(const gc_sub_ref<U> &rhs) {
      _ref = rhs._ref;
      return *this;
    }
    gc_sub_ref &operator =(gc_sub_ref &rhs) {
      _ref = rhs._ref;
      return *this;
    }

    static const auto &descriptor() {
      static gc_descriptor d =
	GC_DESC(gc_sub_ref)
	.template WITH_FIELD(&gc_sub_ref::_enclosing);
      return d;
    }
    // Note: If you put this into a T& and the anchor goes away,
    // the reference may become invalid.
    operator T &() const {
      return _ref;
    }

    template <typename S = T>
    decltype(std::declval<S>().operator->()) operator ->() const {
      return _ref.operator->();
    }
  };


  /**
   * Explicitly convert a bare pointer to a gc_ptr.
   *
   * @tparam T the type of the object pointed to.
   * @param p a bare pointer to `T`.
   *
   * @warning This is a way that you can obtain a gc_ptr to an object
   * that doesn't derive from gc_allocated.  **DON'T DO THAT**.  It
   * may break the garbage collector.
   */
  template <typename T>
  inline
  gc_ptr<T> gc_ptr_from_bare_ptr(T *p) {
    return gc_ptr<T>(typename gc_ptr<T>::allow_ptr_conversion{}, p);
  }
  
}


namespace ruts {
  template <typename T>
  struct hash1<mpgc::gc_ptr<T>> {
    auto operator()(const mpgc::gc_ptr<T> &ptr) const {
      return ptr.hash1();
    }
  };
  template <typename T>
  struct hash2<mpgc::gc_ptr<T>> {
    auto operator()(const mpgc::gc_ptr<T> &ptr) const {
      return ptr.hash2();
    }
  };

}

namespace std {
  template <typename C, typename T, typename X>
  basic_ostream<C,T> &
  operator <<(basic_ostream<C,T> &os, const mpgc::gc_ptr<X> &ptr) {
    return os << ptr.as_offset_pointer();
  }
  
  template <typename C, typename T, typename X>
  basic_ostream<C,T> &
  operator <<(basic_ostream<C,T> &os, const mpgc::gc_sub_ptr<X> &ptr) {
    return ptr.print_on(os);
  }
  
  template <typename T>
  inline
  void swap(mpgc::gc_ptr<T> &lhs, mpgc::gc_ptr<T> &rhs) {
    lhs.swap(rhs);
  }

  template <typename T, typename U>
  mpgc::gc_ptr<T>
  static_pointer_cast(const mpgc::gc_ptr<U> &r) {
    return mpgc::gc_ptr_from_bare_ptr(static_cast<T*>(r._ptr));
  }

  template <typename T, typename U>
  inline
  mpgc::gc_ptr<T>
  dynamic_pointer_cast(const mpgc::gc_ptr<U> &r) {
    return mpgc::gc_ptr_from_bare_ptr(dynamic_cast<T*>(r._ptr));
  }

  template <typename T, typename U>
  inline
  mpgc::gc_ptr<T>
  const_pointer_cast(const mpgc::gc_ptr<U> &r) {
    return mpgc::gc_ptr_from_bare_ptr(const_cast<T*>(r._ptr));
  }

  template <typename T>
  struct hash<mpgc::gc_ptr<T>> {
    std::size_t operator()(const mpgc::gc_ptr<T> &val) const noexcept {
      return std::hash<T*>()(val.as_bare_pointer());
    }
  };

  template <typename T>
  struct versioned_pointer_traits<mpgc::gc_ptr<T>>
    : pointer_traits<mpgc::gc_ptr<T>>
  {
  private:
    using opvpt = versioned_pointer_traits<mpgc::offset_ptr<T>>;
  public:
    using prim_rep = typename opvpt::prim_rep;

    constexpr static mpgc::gc_ptr<T> from_prim_rep(prim_rep p) {
      return mpgc::gc_ptr<T>::from_offset_ptr(opvpt::from_prim_rep(p));
    }
    constexpr static prim_rep to_prim_rep(mpgc::gc_ptr<T> p) {
      return opvpt::to_prim_rep(p.as_offset_pointer());
    }
    template <typename M, typename OV, typename NV>
    static void modify(M&& mod, OV&& old_val, NV&&new_val) {
      /*
       * old_val() can only be called before mod() is called.
       */
      mpgc::write_barrier(forward<OV>(old_val)().as_offset_pointer(), forward<NV>(new_val)().as_offset_pointer(), mod);
    }
  };

  template <typename T>
  class atomic<mpgc::gc_ptr<T>>   
    : public ruts::default_atomic<mpgc::gc_ptr<T>>
  {
    using base = ruts::default_atomic<mpgc::gc_ptr<T>>;
    using typename base::contained_type;
  public:
    /*
     * All subclasses need to import constructors and 
     * assignment
     */
    using base::load_order;
    using base::base;
    contained_type operator =(const contained_type &desired) {
      store(desired);
      return desired;
    }
    contained_type operator =(const contained_type &desired) volatile {
      store(desired);
      return desired;
    }
    using base::load;
    void store(const mpgc::gc_ptr<T> &desired,
               std::memory_order order = std::memory_order_seq_cst)
    {
      mpgc::write_barrier(load().as_offset_pointer(), desired.as_offset_pointer(), [&] {
        base::store(desired, order);
      });
    }

    void store(const mpgc::gc_ptr<T> &desired,
               std::memory_order order = std::memory_order_seq_cst) volatile
    {
      mpgc::write_barrier(load().as_offset_pointer(), desired.as_offset_pointer(), [&] {
        base::store(desired, order);
      });
    }

    mpgc::gc_ptr<T> exchange(const mpgc::gc_ptr<T> &desired,
                                std::memory_order order = std::memory_order_seq_cst)
    {
      mpgc::gc_ptr<T> ret;
      mpgc::write_barrier(load().as_offset_pointer(), desired.as_offset_pointer(), [&] {
        ret = base::exchange(desired, order);
      });
      return ret;
    }

    mpgc::gc_ptr<T> exchange(const mpgc::gc_ptr<T> &desired,
                           std::memory_order order = std::memory_order_seq_cst) volatile
    {
      mpgc::gc_ptr<T> ret;
      mpgc::write_barrier(load().as_offset_pointer(), desired.as_offset_pointer(), [&] {
        ret = base::exchange(desired, order);
      });
      return ret;
    }

    bool compare_exchange_weak(mpgc::gc_ptr<T> &expected,
                               const mpgc::gc_ptr<T> &desired,
                               std::memory_order success,
                               std::memory_order failure)
    {
      bool ret;
      mpgc::write_barrier(expected.as_offset_pointer(), desired.as_offset_pointer(), [&] {
        ret = base::compare_exchange_weak(expected, desired,
                                          success, failure);
      });
      return ret;
    }

    bool compare_exchange_weak(contained_type &expected,
                               const contained_type &desired,
                               std::memory_order order = std::memory_order_seq_cst)
    {
      return compare_exchange_weak(expected, desired, order, load_order(order));
    }

    bool compare_exchange_weak(mpgc::gc_ptr<T> &expected,
                               const mpgc::gc_ptr<T> &desired,
                               std::memory_order success,
                               std::memory_order failure) volatile
    {
      bool ret;
      mpgc::write_barrier(expected.as_offset_pointer(), desired.as_offset_pointer(), [&] {
        ret = base::compare_exchange_weak(expected, desired,
                                          success, failure);
      });
      return ret;
    }

    bool compare_exchange_weak(contained_type &expected,
                               const contained_type &desired,
                               std::memory_order order = std::memory_order_seq_cst) volatile
    {
      return compare_exchange_weak(expected, desired, order, load_order(order));
    }

    /*
     * If you override one with a name, you have to import the whole
     * set, otherwise you lose the others.
     */
    bool compare_exchange_strong(mpgc::gc_ptr<T> &expected,
				 const mpgc::gc_ptr<T> &desired, 
				 std::memory_order success,
				 std::memory_order failure)
    {
      // mark expected
      bool ret;
      mpgc::write_barrier(expected.as_offset_pointer(), desired.as_offset_pointer(), [&] {
        ret = base::compare_exchange_strong(expected, desired,
                                            success, failure);
      });
      return ret;
    }

    bool compare_exchange_strong(contained_type &expected,
                                 const contained_type &desired,
                                 std::memory_order order = std::memory_order_seq_cst)
    {
      return compare_exchange_strong(expected, desired, order, load_order(order));
    }

    bool compare_exchange_strong(mpgc::gc_ptr<T> &expected,
                                 const mpgc::gc_ptr<T> &desired,
                                 std::memory_order success,
                                 std::memory_order failure) volatile
    {
      bool ret;
      mpgc::write_barrier(expected.as_offset_pointer(), desired.as_offset_pointer(), [&] {
        ret = base::compare_exchange_strong(expected, desired,
                                            success, failure);
      });
      return ret;
    }

    bool compare_exchange_strong(contained_type &expected,
                                 const contained_type &desired,
                                 std::memory_order order = std::memory_order_seq_cst) volatile
    {
      return compare_exchange_strong(expected, desired, order, load_order(order));
    }

  };
}

#endif
