/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#ifndef GC_DESC_H_
#define GC_DESC_H_

/**
 * @file
 *
 * @author Evan Kirshenbaum
 */

#include <atomic>
#include <cstdint>
#include <functional>
#include <type_traits>
#include <utility>
#include <vector>
#include <bitset>
#include "mpgc/offset_ptr.h"
#include "ruts/bit_field.h"
#include "ruts/uniform_key.h"
      

namespace mpgc {
  class gc_allocated;
  template <typename T> class gc_ptr;
  template <typename T> class weak_gc_ptr;
  template <typename T> class gc_array;
  template <typename T> class is_collectible;
  template <typename T, std::size_t NFlags = 0>
  using versioned_gc_ptr = ruts::versioned<gc_ptr<T>, NFlags, base_offset_ptr::used_bits()>;
  template <typename T, std::size_t NFlags = 0>
  using atomic_versioned_gc_ptr = ruts::atomic_versioned<gc_ptr<T>, NFlags, base_offset_ptr::used_bits()>;

  class gc_descriptor;

  /**
   * A traits class to define a gc_descriptor for type `T`.
   *
   * To get a gc_descriptor, gc_descriptor::desc_for<T>() is called.
   * This turns around calls
   * `gc_traits<std::remove_cv_t<T>>::descriptor()`.  The point of
   * this indirectioni (besides removing `const` and `volatile`
   * modifiers from the type) is that classes can have partial
   * specializations, while functions cannot.  (When concepts are
   * available, this will be less important.)

   * In particular, has_descriptor_method<T> can be used as an
   * enabling concept to provide a specialization for all types that
   * define a static descriptor() method.
   *
   * There is no default definition of this class, so attempting to
   * call desc_for<T>() for a `T` that doesn't match any
   * specialization will (intentionally) result in a compile-time
   * error.
   *
   * @tparam T the type.
   * @tparam Enabled an optional concept parameter, typically given as
   * std::enable_if_t.
   */
  template <typename T, typename Enabled = void>
  class gc_traits;


  class ref_field_collector__;

  /**
   * A compact object descriptor.
   *
   * gc_descriptor is a one-word object descriptor placed immediately
   * in front of a GC-allocated object.  It allows the user to
   * determine the size of the described object (in words) and the
   * location of all GC pointers within the object.  It also allows
   * the user to obtain a strong confidence that a random word in the
   * MPGC heap is or is not an object descriptor (and, therefore, that
   * a putative pointer is or is not an actual pointer).
   *
   * To ensure that any object can be described in a single word (or,
   * for an array, in the single word plus the array size in the
   * following word), a variety of compact formats are use.
   * High-order bits 63 and 62 are used to signal the format used.
   * 
   * @par Array Descriptors
   * 
   * Regardless of the format, but 61 is used to signal whether the
   * descriptor is an array descriptor (value `1`) or not (value `0`).
   * For an array descriptor, the remaining bits (i.e., all but bit
   * 61) are used to describe each element of the array, and the word
   * following the descriptor in the MPGC heap contains the number of
   * elements in the array.

   * @note An array in the program may be described by an object
   * descriptor that is not an array descriptor.  (And, theoretically,
   * vice versa.)  This can happen in at least the following cases:
   * + If the elements of a (program) array are known to not contain
   *   any GC pointers (i.e., the elements are _blobs_), the entire
   *   array will therefore not contain any GC pointers and will be
   *   described by a non-array object descriptor.
   * + If the elements of a (program) array are known to contain
   *   objects that consist entirely of GC pointers (i.e., the
   *   elements are _reference arrays_), the entire array will
   *   therefore contain only GC pointers and will be described by a
   *   non-array object descriptor.
   * + If the elements of a (program) array are primitive values that
   *   are (with alignment) smaller than the size of a GC pointer (a
   *   word), the entire array will therefore not contain any GC
   *   pointers and will be described by a non-array object
   *   descriptor.  Note that the size of the described object will be
   *   the number of words the object contains, not the number of
   *   elements.
   *
   * @par Invalid Descriptor

   * If the format bits have the binary value `00`, the object
   * descriptor is invalid.  This can be used as part of the validity
   * check of a putative object descriptor.

   * @par External Descriptor 
   * 
   * If the format bits have the binary value `01`, the rest of the
   * bits are construed as an offset_ptr to an external_descriptor,
   * which can be used to obtain the size, GC pointer offsets, and
   * validity check.
   *
   * @par List Descriptor
   *
   * If the format bits have the binary value `10`, the object
   * descriptor is a _list object descriptor_, which contains a list
   * (the _field list_) enumerating words within the object that
   * contain (or do not contain) GC pointers.
   *
   * + Bit 60 contains an indication of whether the object descriptor
   *   is an _include list descriptor_ (value `1`), which lists GC
   *   pointer fields, or an _exclude list descriptor_ (value `0`),
   *   which list fields that are not GC pointers (and enumerates GC
   *   pointer fields by skipping listed fields.
   * + Bits 57-59 contain the length of the field list.
   * + Bits 22-56 contain the number of fields in the object (in words) 
   *   and the indices of the fields in the field list.
   *
   * @note The number of the fields and the indices pretend that every
   * field is exactly one word long, so the fields don't necessarily
   * correspond to members of the object as seen by the program.  In
   * an object like
   * ~~~
   * class A : public gc_allocated {
   *   bool flag;
   *   int count;
   *   gc_ptr<A> next;
   *   pair<long, gc_ptr<A>> p;
   * };
   * ~~~
   * each `A` is considered to be four fields long, with `flag` and
   * `count` sharing field 0, `next` being field 1, `p.first` being
   * field 2, and `p.second` being field 3.  In this example, an `A`
   * could be described by an include list descriptor whose
   * two-element list contained indices 1 and 3 (corresponding to
   * `next` and `p.second`) or by an exclude list descriptor whose
   * two-element list contained indices 0 and 2 (corresponding to
   * `flag`/`count` and `p.first`).
   *
   * To be able to handle the greatest number of types as list object
   * descriptors, the sizes of the bit-fields that encode the object
   * size and the indexes in the list are dependent on the list
   * length.  The following values are used:
   *
   * |n|bits |max |size  | i0   | i1   | i2   | i3   | i4   | i5   | i6   |
   * |-|----:|:--:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|:----:|
   * |0|35   | 32G|22--56|      |      |      |      |      |      |      |
   * |1|17   |128K|40--56|23--39|      |      |      |      |      |      |
   * |2|11   |  2K|46--56|35--45|24--34|      |      |      |      |      |
   * |3| 8   | 256|49--56|41--48|33--40|25--32|      |      |      |      |
   * |4| 7   | 128|50--56|43--49|36--42|29--36|22--28|      |      |      |
   * |5| 5   |  32|52--56|47--51|42--46|37--41|32--36|27--31|      |      |
   * |6| 5   |  32|52--56|47--51|42--46|37--41|32--36|27--31|22--28|      |
   * |7| 4   |  16|53--56|49--52|45--48|41--44|37--40|33--36|29--32|25--28|
   *
   * @par Bitmap Descriptor
   *
   * If the format bits have the binary value `10`, the object
   * descriptor is a _bimap object descriptor.  Bits 56-60 contain one
   * less than the number of fields in the object (allowing
   * representation of objects containing from 1 through 32 fields),
   * and bits 24-55 contain a bitmap in which a bit value of `1`
   * indicates that the object contains a pointer at the corresponding
   * field, with the least significant bit in the bitmap (i.e., bit
   * 24) representing the first field in the object.
   *
   * @par Check Bits
   * 
   * For list and bitmap object descriptors, bits 0-21 contain
   * information that can be used to check the validity of a putative
   * object descriptor in the MPGC heap.  For an actual object
   * descriptor, these will contain bits 3-25 (i.e., shifting off bits
   * that would be zero due to alignment) of an offset pointer
   * pointing to the word containing the object descriptor.
   *
   * 
   * @sa external_descriptor
   */

  class gc_descriptor {
    /**
     * The internal representation is a 64-bit unsigned integer.
     */
    using rep_type = uint64_t;
    using bool_field = bits::field<bool>;
    using size_field = bits::field<std::size_t>;

    /**
     * The internal representation, a 64-bit unsigned integer.
     */
    rep_type _rep;

    friend class gc_allocated;
    friend class ref_field_collector__;

    /**
     * An enum representing the format category based on bits 63 and 62.
     */
    enum struct cat {
      illegal = 0b00,   /**< Not a valid object descriptor.*/
        external = 0b01,  /**< An external object descriptor.*/
        list = 0b10,      /**< A list object descriptor.*/
        bitmap = 0b11       /**< A bitmap object descriptor.*/
    };

    /** 
     * A 22-bit field (bits 0--22) used to check validity.
     *
     * If the object descriptor is valid, this field will hold bits
     * 3--25 of an offset_ptr pointing to the descriptor's location.
     */
    constexpr static auto check_bits_fld = size_field(0, 22);

    /**
     * A 1-bit field (bit 63) indicating that the object descriptor is _compact_.
     *
     * If this is `1`, the object is fully described by this word.  If
     * `0`, it is an external descriptor.
     */
    constexpr static auto is_compact_fld = bool_field(63);
    /**
     * A 1-bit field (bit 62) indicating that the object descriptor is a bitmap descriptor.
     *
     * If this is `1`, the object descriptor is a bitmap descriptor.
     * If `0`, it is an external descriptor.
     * @pre This is only valid if the object descriptor is compact, as
     * indicated by #is_compact_fld.
     */
    constexpr static auto is_bitmap_fld = bool_field(62);
    /**
     * A 1-bit field (bit 62) indicating that the object descriptor is
     * an external descriptor.
     *
     * If this is `1`, the object descriptor is an external
     * descriptor.  If `0`, it is not a valid object descriptor.  @pre
     * This is only valid if the object descriptor is not compact, as
     * indicated by #is_compact_fld.
     */
    constexpr static auto external_check_fld = is_bitmap_fld;

    /**
     * A 2-bit field (bits 62--63) indicating the format category of
     * the object descriptor.
     *
     * The value is a #cat.
     */
    constexpr static auto cat_fld = bits::field<cat>(62,2);

    /**
     * A 1-bit field (bit 61) indicating that the object descriptor is
     * an array descriptor.
     *
     * If this is `1`, the object descriptor otherwise describes each
     * array element, and the number of elements in the array is taken
     * from the word following the object descriptor.
     */
    constexpr static auto is_array_fld = bool_field(61);

    /**
     * A 5-bit field (bits 56--60) indicating the number of fields in
     * the object.
     *
     * The value in this field is one less than the actual number of
     * fields, so that objects with 1 to 32 fields can be described.
     * (There is no need to worry about zero-field objects, as they
     * are necessarily blobs.)
     *
     * @pre This is only valid if the object descriptor is a bitmap
     * object descriptor, as indicated by #cat_fld.
     */
    constexpr static auto bitmap_size_fld = size_field(56, 5);
    /**
     * A 32-bit field (bits 24--55) indicating the fields containing
     * references.
     *
     * Each bit corresponds to a field of the described object, with
     * the low-order bit (bit 24) being the first field (field 0).  A
     * `1` value indicates that the corresponding field contains a
     * (possibly-null) reference.
     *
     * @pre This is only valid if the object descriptor is a bitmap
     * object descriptor, as indicated by #cat_fld.
     */
    constexpr static auto bitmap_map_fld = size_field(24, 32);

    /**
     * A 1-bit field (bit 60) indicating that the object descriptor is
     * an include list descriptor.
     *
     * If the value is `1`, the field idicies in the list represent
     * fields that contain (possibly-null) references.  If it is `0`,
     * the field indices represent all fields that _do not_ contain
     * references and should be skipped when enumerating reference
     * fields.
     *
     * @pre This is only valid if the object descriptor is a list
     * object descriptor, as indicated by #cat_fld.
     */
    constexpr static auto include_fields_fld = bool_field(60);
    /**
     * A 3-bit field (bits 57--59) that holds the number of field
     * indices in the list.
     *
     * Three bits allow lists of length 0--7.
     *
     * @pre This is only valid if the object descriptor is a list
     * object descriptor, as indicated by #cat_fld.
     */
    constexpr static auto n_fields_fld = size_field(57, 3);

    /**
     * The bit position to use as a base for finding size and index fields. 
     */
    constexpr static std::size_t list_base = 57;
    /**
     * Bit-field widths to use for lists of sizes given by #n_fields_fld.
     */
    constexpr static std::size_t list_width[] = { 35, 17, 11, 8, 7, 5, 5, 4};

    /**
     * A 35-bit field (bits 22-56) that holds the number of fields for
     * a blob (or reference array).
     *
     * @pre This is only valid if the object descriptor is a list
     * object descriptor, as indicated by #cat_fld and the list
     * length (as given by #n_fields_fld) is zero.
     */
    constexpr static auto blob_size_fld = size_field(22, 35);
    /**
     * A 17-bit field (bits 40-56) that holds the number of fields for
     * a 1-item list object descriptor.
     *
     * @pre This is only valid if the object descriptor is a list
     * object descriptor, as indicated by #cat_fld and the list
     * length (as given by #n_fields_fld) is one.
     */
    constexpr static auto l1_size_fld = size_field(40, 17);
    /**
     * A 17-bit field (bits 40-56) that holds the (single) field index
     * for a 1-item list object descriptor.
     *
     * @pre This is only valid if the object descriptor is a list
     * object descriptor, as indicated by #cat_fld and the list
     * length (as given by #n_fields_fld) is one.
     */
    constexpr static auto l1_f1_fld = size_field(23, 17);


    /*
     * These cannot be defined until gc_descriptor is complete
     */
    class array_descriptor;	// Contains the size (from gc_array) and first field
    class scalar_descriptor;	// Contains the first field.

    const array_descriptor &as_array() const;
    const scalar_descriptor &as_scalar() const;

  public:
    class external_descriptor;
    class include_list_external_descriptor;
  private:
    /**
     * Get the external_descriptor object for an external object descriptor. 
     * 
     * @returns the referenced external_descriptor object.
     *
     * @pre This is only valid if the object descriptor is an external
     * object descriptor, as indicated by #cat_fld.
     */
    offset_ptr<const external_descriptor> as_external_descriptor() const;


    /**
     * An indicator class used in constructors to convert a rep_type
     * to a gc_descriptor.
     */
    class direct {};
    /**
     * An indicator class used in constructors to convert a rep_type
     * to a gc_descriptor and ensure that the check bits are set
     * correctly.
     */
    class install {};

    /**
     * Convert a rep_type to a gc_descriptor.
     *
     * @param "(direct)" an indicator to select the correct ctor.
     * @param rep the representation for the gc_descriptor.
     *
     * We use an indicator in the ctor to make it less likely that an
     * accidental conversion will take place.
     */
    constexpr gc_descriptor(direct, rep_type rep)
      : _rep{rep}
    {}


    /**
     * The correct check bits for a given word on the MPGC heap.
     *
     * @param p a pointer to the word.
     */
    constexpr static std::size_t check_bits_for(const base_offset_ptr &p) {
      return p.val() >> 3;
    }

    /**
     * The correct check bits for an object descriptor on the MPGC heap.
     *
     * @pre The object descriptor is on the MPGC heap.
     */
    std::size_t correct_check_bits() const {
      return check_bits_for(base_offset_ptr(this));
    }

    /**
     * Install a gc_descriptor on the MPGC heap, setting the correct
     * check bits in #check_bits_fld.
     *
     * @param "(install)" an indicator to select the correct ctor.
     * @param other the gc_descriptor to use.  It's check bits are
     * ignored.
     *
     * @pre The object being constructed is on the MPGC heap.  This is
     * checked by an assertion.
     *
     */
    gc_descriptor(install, const gc_descriptor &other)
    {
      const base_offset_ptr &temp = reinterpret_cast<const base_offset_ptr&>(_rep);
      assert(!temp.is_valid());
      _rep = other.is_compact() ? check_bits_fld.replace(other._rep,
                                                         correct_check_bits())
             : other._rep;
    }

    /**
     * An indicator class used in constructors to create a list object
     * descriptor.
     */
    class as_list {};
    /**
     * An indicator class used in constructors to create a bitmap
     * object descriptor.
     */
    class as_bitmap {};
    /**
     * An indicator class used in constructors to create an external
     * object descriptor.
     */
    class as_indirect {};
    
    /**
     * Construct an external object descriptor.
     *
     * @param "(as_indirect)" an indicator to select the correct ctor.
     * @param ptr a pointer to the external_descriptor.
     */
    constexpr gc_descriptor(as_indirect, const base_offset_ptr &ptr) 
      : _rep(cat_fld.encode(cat::external)
	     | ptr.val())
    {}

    /**
     * Construct a blob object descriptor.
     *
     * @param "(as_list)" an indicator to select the correct ctor.
     * @param words the number of words in the blob.
     *
     * A blob object descriptor is an include list object descriptor
     * with a list length of zero.  This is called by blob().
     */
    constexpr gc_descriptor(as_list, std::size_t words) 
      : _rep(is_compact_fld.encode(true)
	     | is_bitmap_fld.encode(false)
	     | n_fields_fld.encode(0)
	     | include_fields_fld.encode(true)
	     | blob_size_fld.encode(words))
    {
    }

    
    /**
     * Construct a length-one include list object descriptor.
     *
     * @param "(as_list)" an indicator to select the correct ctor.
     * @param words the number of fields in the object.
     * @param field the index of the single reference field.
     *
     * This is primarily for the convenence of for_ref(), which calls
     * it with `words` equal to `1` and `field` equal to `0`.
     */
    constexpr gc_descriptor(as_list, std::size_t words, std::size_t field) 
      : _rep(is_compact_fld.encode(true)
	     | is_bitmap_fld.encode(false)
	     | n_fields_fld.encode(1)
	     | include_fields_fld.encode(true)
	     | l1_size_fld.encode(words)
	     | l1_f1_fld.encode(field))
    {
    }

    /**
     * The maximum number of fields that a list object descriptor can support.
     *
     * @param refs the length of the field index list.
     * @returns the maximum number of fields.
     */
    constexpr static std::size_t max_size_for_list(std::size_t refs) {
      return size_field(list_base, list_width[refs]).max_val();
    }

    /**
     * Create a list object descriptor given a range containing indices.
     *
     * @tparam Iter a forward iterator type.
     * @param words the number of fields in the object.
     * @param refs the number of indices in the range.
     * @param includep `true` for an include list descriptor, `false`
     * for an exclude list descriptor
     * @param from,to the bounds of the range.
     * @returns the representation of the descriptor if the number of
     * fields is no bigger than the maximum size given the list length
     * (as given by max_size_for_list()), zero otherwise.

     */
    template <typename Iter>
    static rep_type list_rep(std::size_t words, std::size_t refs, bool includep,
		      Iter from, Iter to)
    {
      const std::size_t w = list_width[refs];
      auto sf = size_field(list_base-w, w);
      if (words > sf.max_val()) {
	return 0;
      }
      rep_type r = is_compact_fld.encode(true)
	| is_bitmap_fld.encode(false)
	| n_fields_fld.encode(refs)
	| include_fields_fld.encode(includep)
	| sf.encode(words);
      for (std::size_t shift = list_base-2*w; 
	   from < to; 
	   from++, shift -= w) 
	{
	  r |= size_field(shift, w).encode(*from);
	}
      return r;
    }

    /**
     * Create a bitmap object descriptor given a range containing indices.
     *
     * @tparam Iter a forward iterator type.
     * @param words the number of fields in the object.
     * @param from,to the bounds of the range.
     * @returns the representation of the descriptor.
     * @pre words<=32 
     */
    template <typename Iter>
    static rep_type bitmap_rep(std::size_t words, Iter from, Iter to)
    {
      std::size_t bitmap = 0;
      for (; from < to; from++) {
	bitmap |= (1 << *from);
      }
      rep_type r = is_compact_fld.encode(true)
	| is_bitmap_fld.encode(true)
	| bitmap_size_fld.encode(words-1)
	| bitmap_map_fld.encode(bitmap);
      return r;
    }


    /**
     * The category of the descriptor .
     * @returns the category as indicated by #cat_fld.
     */
    constexpr cat category() const {
      return cat_fld[_rep];
        }

    /**
     * Is this an array descriptor?
     * @returns `true` if this is an array descriptor, as indicated by
     * #is_array_fld.
     */
    constexpr bool is_array() const {
      return is_array_fld[_rep];
    }

    /**
     * Is this a compact (non-external) descriptor?
     * @returns `true` if this is a compact descriptor, as indicated
     * by #is_compact_fld.
     */
    constexpr bool is_compact() const {
      return is_compact_fld[_rep];
    }

    /**
     * Is this an external descriptor?
     * @returns `true` if this is an external descriptor, as indicated
     * by category().
     */
    constexpr bool is_external() const {
      return category() == cat::external;
    }

    /**
     * Is this a bitmap descriptor?
     * @returns `true` if this is a bitmap descriptor, as indicated
     * by category().
     */
    constexpr bool is_bitmap() const {
      return category() == cat::bitmap;
    }

    /**
     * Is this a list descriptor?
     * @returns `true` if this is a list descriptor, as indicated
     * by category().
     */
    constexpr bool is_list() const {
      return category() == cat::list;
    }

    /**
     * The length of a list descriptor's list.
     * @returns the length of the list, as indicated by #n_fields_fld.
     * @pre this is a list descriptor.
     */
    constexpr std::size_t n_fields() const {
      return n_fields_fld[_rep];
    }
    /**
     * Is this an include list descriptor.
     * @returns `true` if this is an include list descriptor, as
     * indicated by #include_fields_fld, `false` if it is an exclude
     * list descriptor.
     * @pre this is a list descriptor.
     */
    constexpr bool include_fields() const {
      return include_fields_fld[_rep];
    }
    /**
     * The number of words in a blob.
     * @returns the number of words in the described blob, as
     * indicated by #blob_size_fld.
     * @pre this is a blob descriptor.
     */
    constexpr std::size_t blob_size() const {
      return blob_size_fld[_rep];
    }

    /** 
     * Delegates is_valid() to the referenced external_descriptor (via
     * as_external_descriptor()).
     * @pre this is an external descriptor.
     */
    bool external_is_valid() const;
    /** 
     * Delegates object_size() to the referenced external_descriptor (via
     * as_external_descriptor()).
     * @pre this is an external descriptor.
     */
    std::size_t external_object_size() const;
    /** 
     * Delegates for_each_ref_index() to the referenced external_descriptor (via
     * as_external_descriptor()).
     * @pre this is an external descriptor.
     */
    void external_for_each_ref_index(const std::function<void(std::size_t)> &) const;

  public:
    /** 
     * Is a type too small to contain a GC pointer?
     *
     * @tparam T the type
     * @returns `true` if the type is too small to contain a GC pointer.
     */
    template <typename T>
    constexpr static bool is_tiny() {
      return sizeof(T) < 8;
    }

    /**
     * Is this an illegal descriptor?
     * @returns `true` if this is an illegal descriptor, as indicated
     * by category().
     */
    constexpr bool is_illegal() const {
      return category() == cat::illegal;
    }

    /**
     * The number of words consumed by a given number of bytes
     *
     * @param bytes the number of bytes
     * @returns the number of words
     */
    constexpr static std::size_t size_in_words(std::size_t bytes) {
      return (bytes>>3) + (bytes % 8 == 0 ? 0 : 1);
    }

    /**
     * The number of words consumed by a given type.
     *
     * @tparam T the type
     * @returns the number of words
     */
    template <typename T>
    constexpr static std::size_t size_in_words() {
      return size_in_words(sizeof(T));
    }

    /**
     * An object descriptor for a blob of a given size.
     */
    constexpr static gc_descriptor blob(std::size_t words) {
      return gc_descriptor(as_list{}, words);
    }

    /**
     * An object descriptor for a blob type
     *
     * @tparam T the type
     */
    template <typename T>
    constexpr static gc_descriptor blob_for() {
      return blob(size_in_words<T>);
    }

    /**
     * An object descriptor for a single reference
     */
    constexpr static gc_descriptor for_ref() {
      return gc_descriptor(as_list{}, 1, 0);
    }

    /**
     * Is this a blob descriptor?
     *
     * @returns `true` if this is a blob descriptor.
     */
    constexpr bool is_blob() const {
      return is_compact()
	&& is_list()
	&& n_fields() == 0
	&& include_fields_fld[_rep]
	&& !is_array();
    }


    /**
     * An object descriptor for an array containing objects described
     * by this descriptor.
     *
     * @tparam T the type this object descriptor describes.
     *
     * The caller, who will be the array allocator, passes in T (which
     * should be the class this is a descriptor for) because if T is
     * too small to hold a reference, the alignment won't be right,
     * and so the total number of words in the blob won't be our size
     * (i.e., 1) times the length of the array.
     */
    template <typename T>
    constexpr gc_descriptor in_array(std::size_t length) const { 
      /*
       * If we're a blob, we coalesce the whole array into one blob, unless
       * that would be too big.
       */
      return is_tiny<T>() ? blob(size_in_words(sizeof(T)*length) + 1)
	: (is_blob() && blob_size()*length+1 <= blob_size_fld.max_val())
	? blob(blob_size()*length+1)
	: gc_descriptor(direct{}, 
			_rep | is_array_fld.encode(true));
    }


    /**
     * Apply a function to every ref index in the object.
     *
     * @param fn A function that can take a `std::size_t`.
     *
     * The field indexes in the desribed object that contain (possibly
     * null) GC pointers are enumerated and passed to the given
     * function.
     */
    template <typename Fn>
    void for_each_ref_index(Fn&& fn) const {
      switch (category()) {
      case cat::illegal:
        {
          assert(false);
          break;
        }
      case cat::external:
        {
          external_for_each_ref_index(fn);
          break;
        }
      case cat::list:
        {
          std::size_t nf = n_fields();
          if (include_fields()) {
            if (nf > 0) {
              std::size_t w = list_width[nf];
              std::size_t shift = list_base-2*w;
              for (std::size_t i=0; i<nf; i++, shift-=w) {
                std::size_t f = size_field(shift, w)[_rep];
                std::forward<Fn>(fn)(f);
              }
            }
          } else {
	    std::size_t w = list_width[nf];
	    std::size_t shift = list_base-w;
	    std::size_t total_fields = size_field(shift, w)[_rep];
	    std::size_t f = 0;
	    shift -= w;
	    for (std::size_t i=0; i<nf; i++, f++, shift-=w) {
	      std::size_t next_omit = size_field(shift, w)[_rep];
	      for (; f<next_omit; f++) {
		std::forward<Fn>(fn)(f);
	      }
	    }
	    for (; f<total_fields; f++) {
	      std::forward<Fn>(fn)(f);
	    }
          }
          break;
        }
      case cat::bitmap:
        {
          std::size_t total_fields = bitmap_size_fld[_rep];
          std::size_t bm = bitmap_map_fld[_rep];
          std::size_t f = 1;
          for (std::size_t i=0; i<total_fields; i++,f<<=1) {
            if (bm & f) {
              std::forward<Fn>(fn)(i);
            }
          }
        }
      default:
        assert(0);
      }
    }

    /**
     * Conditionally call a function and dump a description of this descriptor.
     *
     * @param b the control value
     * @param fn the nullary function to call
     * @returns the control value.
     *
     * If `b` is `false`, calls `fn` and then calls trace().
     * This is designed to be used inside an `assert()` call to print
     * out useful information on an assertion value.  For example,
     * deep_validity_check() includes
     * ~~~
     * assert(trace_on_false(f < nf, [&]{cout << "field " << f << " too big" << endl;}));
     * ~~~
     */
    template <typename Fn>
    bool trace_on_false(bool b, Fn fn) const {
      if (!b) {
	fn();
	trace("unknown");
      }
      return b;
    }

    /**
     * Perform non-trivial checks of the validity of this descriptor.
     *
     * @returns only if the checks pass.  Otherwise fails an assertion.
     *
     * Currently fails with an assertion failure if
     * + the end of the object would extend past the end of the MPGC heap.
     *
     * + this is a bitmap descriptor and there's a bit set in the
     *   bitmap that corresponds to a field that's too big for the
     *   number of fields.
     *
     * + this is a list descriptor and there's a field index that's
     *   too big for the number of fields.
     *
     * + this is a list descriptor and the field indexes are not in
     *   strictly ascending order.
     *
     * @pre The object is on the MPGC heap.
     */
    void deep_validity_check() const;

    /**
     * Perform simple checks of the validity of this descriptor
     *
     * @returns `true` if checks pass, `false` otherwise.
     *
     * Currently checks that
     *
     * + `this` is not a null pointer.
     * 
     * + the format bits are not `00`
     *
     * + if this is an external descriptor, the pointer to the
     *   external descriptor object is valid, and the external
     *   descriptor object contains a pointer to itself.
     *
     * + if this is a list or bitmap descriptor, the check bits are
     *   correct.
     */
    bool is_valid() const {
      /*
       * We could also test that list elements are in the correct order.
       */
      /*
       * GCC 6.1 warns that "if (this == nullptr)" can't be false, but
       * we actually need to check that we're not following a null
       * pointer.
       */
      auto me = this;
      if (me == nullptr || (reinterpret_cast<std::uintptr_t>(me) & 0x7) != 0)
        return false;
      switch (category()) {
      case cat::illegal:
        return false;
      case cat::external:
	return external_is_valid();
      default:
        break;
      }
      if ((_rep & check_bits_fld.mask()) != check_bits_fld.encode(correct_check_bits())) {
	return false;
      }
      /*
       * For debugging, we can turn on a deep validity check, which should fail if we
       * get a false positive with the simple test.
       */
      //deep_validity_check();
      return true;
    }

    /**
     * The number of fields in the described object.
     * 
     * @returns the number of fields.
     * 
     * This is the number of fields in the described object. 
     * object_size() will be one more than this for scalars and this
     * multiplied by the length + 2 for arrays.
     */
    std::size_t object_n_fields() const {
      switch (category()) {
      case cat::illegal:
        assert(false);
        return 0;
      case cat::external:
	return external_object_size();
      case cat::list:
        {
          std::size_t nf = n_fields();
          /* This holds whether we're including or excluding all */
          switch (nf) {
          case 0:
            return blob_size();
          case 1:
            return l1_size_fld[_rep];
          default:
            {
              std::size_t w = list_width[nf];
              return size_field(list_base-w, w)[_rep];
            }
          }
        }
      case cat::bitmap:
	return bitmap_size_fld[_rep]+1;
      default:
        assert(false);
      }
    }

   /**
    * The number of words contained in the described object.
    *
    * @returns 
    * + if this is an array descriptor, object_n_fields()*the array
    *   length+2 (for the descriptor and the array length)
    * + otherwise, object_n_fields()+1 (for the array length).
    *
    * @pre If this is an array descriptor, this is on the MPGC heap (so
    * that the next word contains the array length).
    */
    /*
     * Different behavior for scalars and arrays, so we define these after the subclasses.
     */
    std::size_t object_size() const;

    /**
     * Apply a function for each GC pointer contained in the described object.
     *
     * @params fn the function to call.
     *
     * Calls `fn` for each contained (possibly null) GC pointer,
     * passing in the a const reference to to each pointer as a 
     * base_offset_ptr.  If this is an external descriptor, also passes in
     * a reference to this descriptor, reinterpred as a 
     * base_offset_ptr.
     *
     * @pre This is on the GC heap, immediately before the object it describes.
     */
    template <typename Fn>
    void for_each_ref(Fn&& fn) const;

    /**
     * Print out useful debugging information about this descriptor.
     *
     * @param type_name the name of the type described by this descriptor.
     *
     * Prints out a verbose description of the descriptor.  Includes 

     * + the passed-in name	
     *
     * + the number of fields in the object or array element
     *
     * + is this a blob descriptor?
     *
     * + is this an array descriptor?
     *
     * + the overall size of the object
     *
     * + the address of the object in the heap
     *
     * + if this is an external descriptor:
     *   - the number of fields
     *   - the reference field indexes in the list
     *
     * + if this is a bitmap descriptor:
     *   - the value of the size field (one less than the object size)
     *   - the bitmap, in hex
     *
     * + if this is a list descriptor:
     *   - is this an include list?
     *   - the length of the list
     *   - the elements of the list
     */
    void trace(const char *type_name) const;

    /**
     * Call trace() statically.
     *
     * @param r the internal representation (`uint64_t`) of a descriptor
     * @param type_name the parameter to pass to trace() 
     */
    static void trace_desc(rep_type r, const char *type_name) {
      gc_descriptor(direct{}, r).trace(type_name);
    }
  };

  /**
   * A reinterpretation of gc_descriptor when it's known not to be an
   * array descriptor.
   *
   * No instances of scalar_descriptor are created.  Rather,
   * gc_descriptor::for_each_ref() calls as_scalar() to recast its
   * `this` pointer as a reference to a scalar_descriptor and then
   * calls walk() on the result.
   *
   * The point of this class that it pretends that the following word
   * (the first field of the object) is actually a member of this
   * object (#first_field_proxy).  This makes it possible to index
   * from that field to obtain a reference to each reference field of
   * the object.
   */
  class gc_descriptor::scalar_descriptor : public gc_descriptor {
    /**
     * The first field of the described object, reinterpred as a
     * base_offset_ptr belonging to this object.
     */
    base_offset_ptr first_field_proxy;
  public:
    /**
     * An implementation of for_each_ref() for non-array descriptors.
     *
     * @param fn a function that can take a const reference to a
     * base_offset_ptr.
     *
     * Calls for_each_ref_index() to enumerate the indices of fields
     * containing GC references and (in the lambda argument to that
     * function), offsets the enumerated amount from
     * #first_field_proxy to obtain a reference to the field to pass
     * in to the function.
     */
    template <typename Fn>
    void walk(Fn&& fn) const {
      const base_offset_ptr *p = &first_field_proxy;
      for_each_ref_index([&](size_t i) {
	  std::forward<Fn>(fn)(p+i);
	});
    }
  };

  /**
   * Reinterpret `this` as a reference to a scalar_descriptor.
   *
   * @pre This object is on the MPGC heap.
   *
   * @pre This object is not an array object descriptor, as indicated
   * by #is_array_fld.
   */
  inline
  const gc_descriptor::scalar_descriptor &
  gc_descriptor::as_scalar() const {
    return static_cast<const scalar_descriptor &>(*this);
  }
  

  /**
   * A reinterpretation of gc_descriptor when it's known to be an
   * array descriptor.
   *
   * No instances of array_descriptor are created.  Rather,
   * gc_descriptor::for_each_ref() calls as_array() to recast its
   * `this` pointer as a reference to an array_descriptor and then
   * calls walk() on the result.  Also gc_descriptor::object_size()
   * calls as_array() and then length() to get the number of elements
   * in the array.
   *
   * The point of this class that it pretends that the following two
   * words (the array length and the first field of the object) are
   * actually members of this object (#array_length and
   * #first_field_proxy).  This makes it possible to index from that
   * field to obtain a reference to each reference field of the
   * object and also to obtain the length of the array.
   */
  class gc_descriptor::array_descriptor : public gc_descriptor {
    /** The number of elements in the array. */
    std::size_t array_length;
    /**
     * The first field of the described object, reinterpred as a
     * base_offset_ptr belonging to this object.
     */
    base_offset_ptr first_field_proxy;
  public:
    /**
     * The number of elements in the array.
     */
    std::size_t length() const {
      return array_length;
    }
    
    /**
     * An implementation of for_each_ref() for array object
     * descriptors.
     *
     * @param fn a function that can take a const reference to a
     * base_offset_ptr.
     *
     * For each element in the array, calls for_each_ref_index() to
     * enumerate the indices of fields containing GC references and
     * (in the lambda argument to that function), offsets the
     * enumerated amount from #first_field_proxy to obtain a reference
     * to the field to pass in to the function.
     */
    template <typename Fn>
    void walk(Fn&& fn) const {
      const std::size_t stride = object_n_fields();
      const base_offset_ptr *p = &first_field_proxy;
      for (std::size_t i=0; i<array_length; i++, p+=stride) {
	for_each_ref_index([&](size_t i) {
	    std::forward<Fn>(fn)(p+i);
	  });
      }
    }
  };

  /**
   * Reinterpret `this` as a reference to a scalar_descriptor.
   *
   * @pre This object is on the MPGC heap.
   *
   * @pre This object is an array object descriptor, as indicated by
   * #is_array_fld.
   */
  inline
  const gc_descriptor::array_descriptor &
  gc_descriptor::as_array() const {
    return static_cast<const array_descriptor &>(*this);
  }


  inline
  std::size_t 
  gc_descriptor::object_size() const {
    if (is_array()) {
      std::size_t nf = object_n_fields();
      std::size_t len = as_array().length();
      return nf*len+2;
    } else {
      return object_n_fields()+1;
    }
  }

  template <typename Fn>
  inline
  void gc_descriptor::for_each_ref(Fn&& fn) const
  {
    if (is_blob()) {
      return;
    }
    if (is_external()) {
      const base_offset_ptr *base_ptr = reinterpret_cast<const base_offset_ptr*>(this);
      std::forward<Fn>(fn)(base_ptr);
    }
    if (is_array()) {
      as_array().walk(std::forward<Fn>(fn));
    } else {
      as_scalar().walk(std::forward<Fn>(fn));
    }

  }

  /**
   * Obtain the gc_descriptor for a class.
   *
   * @relatedalso gc_descriptor
   *
   * @tparam T the class
   * @returns the gc_descriptor for the class.
   *
   * The default implementation is
   *
   * ~~~
   *  template <typename T>
   *  inline
   *  const auto &desc_for() {
   *    return gc_traits<std::remove_cv_t<T>>::descriptor();
   *  }
   * ~~~
   *
   * but this can be overridden by specialization or (more commonly),
   * by specializing gc_traits<T>.
   * @sa gc_traits<T>
s   */
  template <typename T>
  inline
  const auto &desc_for() {
    return gc_traits<std::remove_cv_t<T>>::descriptor();
  }


  /**
   * An object that collects a indications of GC reference fields and creates a gc_descriptor.
   *
   * This object is used in desc_spec<T,Fields>::operator gc_descriptor().
   */
  class ref_field_collector__ {
  protected:
    /** The number of fields in the described object */
    const std::size_t n_fields;
    /** Indices of GC reference fields */
    std::vector<std::size_t> field_offsets;
    friend class gc_descriptor;

    /**
     * Create a ref_field_collector__ for a type with the given number of fields.
     * @params nf the number of fields in the type.
     */
    explicit ref_field_collector__(std::size_t nf)
      : n_fields(nf)
    {
    }

    /**
     * Note a reference field index.
     * @param the field index of a reference field.
     */
    void add_ref(std::size_t offset) {
      field_offsets.push_back(offset);
    }

    /**
     * Note reference field indexes based on a gc_descriptor.
     *
     * This is used to note fields in a superclass or member field, as
     * described by a gc_descriptor.
     * @param other the gc_descriptor of the member or superclass.
     * @param offset the field index of the first field of the member
     * or superclass.
     */
    void add(const gc_descriptor &other, std::size_t offset) {
      other.for_each_ref_index([&](std::size_t i) {
	  add_ref(i+offset);
	});
    }

    /**
     * Note reference field indexes based on a compile-time type.
     *
     * Same as add(const gc_descriptor&,std::size_t), but uses a static type
     * param and calls desc_for<T>() to get the descriptor.
     * @tparam T the type of the member or superclass.
     * @param offset the field index of the first field of the member
     * or superclass.
     */
    template <typename T>
    void add(std::size_t offset) {
      add(desc_for<T>(), offset);
    }

    gc_descriptor to_descriptor();
  private:
    gc_descriptor make_external() const;

  };

  /**
   * A representation of a field of a particular type at a particular
   * offset (as a member or superclass).
   *
   * @tparam X the type of the field.
   * @tparam Offset the offset of the field, in words, from the first
   * word of the containing object.
   */
  template <typename X, std::size_t Offset>
  struct field_spec {
    constexpr static std::size_t offset = Offset;
    using type = X;
    /** The offset, in words, from the beginning of the enclosing object. */
    constexpr std::size_t off() {
      return offset;
    }
    /** The gc_descriptor for the type of the field. */
    constexpr gc_descriptor desc() {
      return desc_for<X>();
    }
  };

  /**
   * A helper class for determining that all words within an object
   * have been accounted for.
   *
   * @tparam Fields... zero or more field_spec objects.
   *
   * The logic is that a caller will (at compile time) call #mark() on
   * this object passing in a mask value that has bits set to `1` for
   * each field in the object.  This function will walk through all of
   * the field_spec objects in Fields and reset the bits
   * corresponding to them.  If the result isn't zero, a static
   * assertion can fail at compile time.
   *
   * @warning This currently only handles object sizes up to 64 words
   * (due to the use of std::size_t for the mask).
   */
  template <typename...Fields> class field_marker;

  /**
   * The base case for field_marker<Fields>.
   */
  template <>
  struct field_marker<> {
    /**
     * When there are no field_spec objects in Fields, mark() simply
     * returns its mask unchanged.
     *
     * @param mask the input mask.
     * @returns the input mask unchanged.
     */
    constexpr static std::size_t mark(std::size_t mask) {
      return mask;
    }
  };

  /**
   * A field_marker with one or more field_spec template parameters
   * @tparam X the type of the first field_spec.
   * @tparam Offset the offset of the first field_spec.
   * @tparam More... the rest of the field_spec params.
   */
  template <typename X, std::size_t Offset, typename...More>
  struct field_marker<field_spec<X,Offset>, More...> {
    /**
     * Mark a first field_spec in the mask
     *
     * @param mask the input mask.
     * @param width the number of words covered by the field_spec
     * (and, hence, the number of bits covered by it in the mask).
     * @param offset the offset of the first word covered by the
     * field_spec.
     *
     * @returns the mask with `width` bits starting from `offset`
     * (counting from the right) set to zero.
     */
    constexpr static
    std::size_t mark_one(std::size_t mask,
			 std::size_t width,
			 std::size_t offset)
    {
      return sizeof(X) == 0 ? mask : (mask & ~bits::mask(width, offset));
    }
    /**
     * The width of the first field_spec.
     *
     * @returns gc_descriptor::size_in_words<X>().
     */
    constexpr static
    std::size_t width() {
      return gc_descriptor::size_in_words<X>();
    }

    /**
     * Clear bits in the provided mask.
     *
     * @param mask the input mask.
     * @returns the input mask with bits cleared based on the
     * field_spec objects.
     *
     * Calls mark_one() to clear bits for the first field_spec.  Then
     * creates a (compile-time) temporary field_marker with the same
     * parameters except without the first and calls mark() on it to
     * clear the rest.
     */
    constexpr static std::size_t mark(std::size_t mask) {
      return field_marker<More...>::mark(mark_one(mask, width(), Offset));
    }
  };
  

  /**
   * The portions of desc_spec<T,Fields> that do not depend on the
   * particular field_spec objects.
   * @tparam T the type of the object being described.
   */
  template <typename T>
  struct desc_spec_base {
    /** The number of words covered by an object of type X. */
    template <typename X>
    constexpr static
    std::size_t width() {
      return gc_descriptor::size_in_words<X>();
    }

    /**
     * Is the object being described GC-allocated.
     *
     * @returns `true` iff `T` derives from gc_allocated.
     */
    constexpr static
    bool is_gc_allocated() {
      return std::is_base_of<gc_allocated, T>::value;
    }

    /**
     * Clear bits from a mask.
     *
     * @param mask the input mask.
     * @param width the number of bits to clear.
     * @param offset the index of the rightmost bit to clear.
     *
     * @returns the updated mask.
     */
    constexpr static
    std::size_t mark(std::size_t mask,
		     std::size_t width,
		     std::size_t offset)
    {
      return mask & ~bits::mask(width, offset);
    }

    /**
     * Clear the bit for the descriptor if the described object is
     * gc_allocated.
     *
     * If the described object is_gc_allocated(), clear the bit
     * corresponding to the gc_descriptor.  This means that the
     * programmer need not specify gc_allocated as a superclass.
     * @param mask the input mask.
     * @returns the updated mask.
     */
    constexpr static
    std::size_t mark_descriptor(std::size_t mask) {
      return is_gc_allocated() ? mark(mask, 1, 0) : mask;
    }

    /**
     * The initial mask to use for coverage checking.
     *
     * @returns an initial mask of size width<T>(), updated by
     * mark_descriptor().
     */
    constexpr static
    std::size_t initial_mask() {
      return mark_descriptor(bits::mask(width<T>()));
    }

    /**
     * A mask containing a bit for every word _not_ covered by any field_spec in Fields.
     *
     * @tparam Fields... a set of field_spec objects. 
     */
    template <typename ... Fields>
    constexpr static
    std::size_t coverage_mask() {
      return field_marker<Fields...>::mark(initial_mask());
    }

    /**
     * A helper class for super_offset<S>().
     * @tparam S the superclass.
     */
    template <typename S>
    constexpr static std::size_t super_offset(const T &obj) {
      return (reinterpret_cast<const char *>(&static_cast<const S &>(obj))
	      - reinterpret_cast<const char *>(&obj))/8;
    }

    /**
     * The offset of superclass `S` in class `T`.
     *
     * @tparam S the superclass.
     * @returns the index of the word that superclass `S` starts on in class `T`.
     *
     * @note Calls super_offset<S>(const T&) with an argument of
     * `*static_cast<const T*>(nullptr)` since GCC can't seem to deal
     * with just using the definition of super_offset<S>(const T&)
     * with that arg being inlined here.
     * 
     *
     * @pre Class `S` is a superclass of class `T`.
     * @pre `static_cast<const S&>(const T&)` is well-defined.
     */
    template <typename S>
    constexpr static std::size_t super_offset() {
      return super_offset<S>(*static_cast<const T*>(nullptr));
    }

    /**
     * The offset of field `Field` in type `T`.
     *
     * @tparam X the type of field `Field`.
     * @tparam Field a field in `T`.
     * @returns the index of the word that field `Field` starts on in class `T`.
     */
    template <typename X, X T::*Field>
    constexpr static std::size_t field_offset() {
      return reinterpret_cast<std::size_t>(&(static_cast<T*>(nullptr)->*Field))/8;
    }


#ifdef GC_FRIENDLY_TUPLES
    template <std::size_t I>
    constexpr static std::size_t tuple_element_offset(T &tuple,
                                                      std::tuple_element_t<I,T> &element)
    {
      return (reinterpret_cast<const char *>(&element)
	      - reinterpret_cast<const char *>(&tuple))/8;
    }

    /**
     * A helper class for tuple_element_offset<I>().
     * @tparam I the tuple element index.
     * @param tuple a reference to a (null) object of type T.
     * @returns the index of the word that element `I` starts on in class `T`.
     * @note This doesn't compile in GCC 4.9.2. 
     */
    template <std::size_t I>
    constexpr static std::size_t tuple_element_offset(const T &tuple) {
      return (reinterpret_cast<const char *>(&std::get<I>(tuple))
	      - reinterpret_cast<const char *>(&tuple))/8;
    }

    /**
     * The offset of tuple element `I` in type `T`.
     *
     * @tparam I the tuple element index.
     * @returns the index of the word that element `I` starts on in class `T`.
     * @note This doesn't compile in GCC 4.9.2. 
     */

    template <std::size_t I>
    constexpr static std::size_t tuple_element_offset() {
      return tuple_element_offset<I>(*static_cast<T*>(nullptr));
    }
#endif

    /**
     * A field_spec for a superclass `S` of `T`.
     *
     * @tparam S the superclass.
     * @returns a field_spec corresponding to superclass `S` of `T`.
     * @pre `S` is a superclass of `T`.  Checked by static_assert().
     */
    template <typename S>
    constexpr static auto super_as_field() {
      static_assert(std::is_base_of<S,T>::value, "Not a supertype");
      return field_spec<S, super_offset<S>()>();
    }

    /**
     * A field_spec for a member `Field` of `T`.
     *
     * @tparam X the type of `Field`.
     * @tparam Field the field.
     * @returns a field_spec corresponding to member `Field` of `T`.
     */
    template <typename X, X T::*Field>
    constexpr static auto member_as_field() {
      return field_spec<X, field_offset<X, Field>()>();
    }

#ifdef GC_FRIENDLY_TUPLES
    template <typename X, std::size_t I>
    constexpr static auto tuple_element_as_field() {
      return field_spec<X, tuple_element_offset<I>()>();
    }
#endif    
  };

  /**
   * A "descriptor specifier" for a type `T` having superclasses and members `Fields...`.
   *
   * @tparam T the type.
   * @tparam Fields... field_spec objects corresponding to superclasses and members.
   *
   * The point of desc_spec<T,Fields> is two-fold:
   *
   * 1. At compile time, it can check that all of the words within
   * type `T` have been covered by superclasses and members in
   * `Fields...`.
   *
   * 2. At runtime, it can create a gc_descriptor corresponding to `T`.
   *
   * The expectation is that a class will construct a desc_spec
   * incrementally during the construction of its descriptor by
   * chaining calls to a series of macros, as in:
   *
   * ~~~
   * gc_descriptor d =
   *   GC_DESC(this_type)
   *   .WITH_SUPER(base)
   *   .WITH_FIELD(&this_type::field_1)
   *   .WITH_FIELD(&this_type::field_2);
   * ~~~
   *
   * The GC_DESC() call creates a desc_spec with no field_spec
   * objects.  Each call to WITH_SUPER() and WITH_FIELD() creates a
   * new one with an extra field_spec representing the superclass or
   * member.  Finally, the conversion to gc_descriptor creates a
   * #collector that uses static_assert() to check coverage at compile
   * time and calls collector::to_descriptor() to create the
   * gc_descriptor at runtime.
   */
  template <typename T, typename...Fields>
  struct desc_spec : desc_spec_base<T> {
    using dsb = desc_spec_base<T>;
    using desc_spec_base<T>::super_as_field;

    /**
     * A desc_spec-specific ref_field_collector__.
     */
    struct collector : ref_field_collector__ {
      friend class desc_spec;

    /**
     * Is type `S` GC-allocated?
     *
     * @tparam S the type.
     * @returns `true` iff `S` derives from gc_allocated.
     */
      template <typename S>
      constexpr static bool is_gc_allocated() {
	return std::is_base_of<gc_allocated,S>::value;
      }

      /**
       * Adjust a field index based on whether the object being
       * described has a gc_descriptor.
       *
       * If type `T` is GC allocated, word `n` is field `n-1`,
       * otherwise, it's field `n`.
       * @param n a word offset within type `T`.
       * @returns the adjusted field offset.
       */
      constexpr static std::size_t adjust(std::size_t n) {
	return is_gc_allocated<T>() ? n-1 : n;
      }

      /**
       * The number of fields in type `T`, not including any
       * gc_descriptor.
       *
       * @returns the size in words, adjusted to subtract `1` if `T`
       * is gc_allocated.
       */
      constexpr static std::size_t n_fields() {
	return adjust(gc_descriptor::size_in_words<T>());
      }


      /**
       * The base case for add_fields<X,Offset,More>().
       *
       * Does nothing.
       */
      static void add_fields() {}

      /**
       * Note a a reference field index when the first field_spec is
       * for a const gc_ptr<X> member.  Then note the rest.
       *
       * @tparam X the type of object referred to by the gc_ptr<X>
       * member.
       * @tparam Offset the word offset of the member.
       * @tparam More... the rest of the fields.
       */
      template <typename X, std::size_t Offset, typename...More>
      void add_fields(field_spec<const gc_ptr<X>,Offset>, More...more) {
	std::size_t adjusted = adjust(Offset);
	add_ref(adjusted);
	add_fields(more...);
      }
      /**
       * Note a reference field index when the first field_spec is for
       * a non-const gc_ptr<X> member.  Then note the rest.
       *
       * @tparam X the type of object referred to by the gc_ptr<X>
       * member.
       * @tparam Offset the word offset of the member.
       * @tparam More... the rest of the fields.
       */
      template <typename X, std::size_t Offset, typename...More>
      void add_fields(field_spec<gc_ptr<X>,Offset>, More...more) {
	std::size_t adjusted = adjust(Offset);
	add_ref(adjusted);
	add_fields(more...);
      }


      /**
       * Check to see whether a member or superclass of type `X` is
       * allowed at a particular offset.
       * 
       * The rule is that gc_allocated members are not allowed and
       * gc_allocated superclasses must be the leftmost superclass, to
       * guarantee that the gc_descriptor is the first word in the
       * object.  This boils down to allowing gc_allocated fields only
       * at offset zero and then only if the type itself
       * is_gc_allocated().
       *
       * This is meant to be used in a static_assert to flag illegal
       * classes at compile time.  The collector will not be able to
       * add fields for the field_spec and so the compilation will
       * fail when a call to gc_allocate() for a type requiring the
       * type's gc_descriptor() is compiled.
       */
      template <typename X>
      constexpr static bool allowed_field(std::size_t offset) {
	return ((!is_gc_allocated<X>())
		|| (offset == 0 && is_gc_allocated<T>()));
      }
      /**
       * Note reference field indexes for a first field_spec (member or superclass), then note the rest.
       *
       * @tparam X the type of the first field_spec.
       * @tparam Offset the word offset of the first field_spec.
       * @tparam More... the rest of the fields.
       *
       * @pre allowed_field<X>() passes.  This is checked by static_assert.
       */
      template <typename X, std::size_t Offset, typename...More>
      void add_fields(field_spec<X,Offset>, More...more) {
	static_assert(allowed_field<X>(Offset),
		      "gc_allocated member, superclass of non-gc_allocated, or non-first superclass");
	// If X is gc_allocated, then T is and Offset==0.  We don't
	// adjust. Otherwise, we have to adjust if T is gc_allocated.
	std::size_t adjusted = is_gc_allocated<X>() ? Offset : adjust(Offset);
	add(desc_for<X>(), adjusted);
	add_fields(more...);
      }

      /**
       * Create a collector based on the enclosing template
       * parameters.
       */
      collector() : ref_field_collector__(n_fields()) {
	add_fields(Fields()...);
      }
    };

    /**
     * A desc_spec like this one but with a given superclass.
     *
     * @tparam S the superclass.
     */
    template <typename S> 
    auto with_super() {
      static_assert(is_collectible<S>::value,
                    "Has non-trivial destructor and no is_collectible<T> specialization");
      return desc_spec<T, Fields..., decltype(desc_spec_base<T>::template super_as_field<S>())>();
    }

    /**
     * A desc_spec like this one but with a given member.
     *
     * @tparam X the member type.
     * @tparam Field a member of `T`.
     */
    template <typename X, X T::*Field>
    auto with_field() {
      static_assert(is_collectible<X>::value,
                    "Has non-trivial destructor and no is_collectible<T> specialization");

      return desc_spec<T, Fields...,
		       decltype(desc_spec_base<T>::template member_as_field<X,Field>())>();
    }

#ifdef GC_FRIENDLY_TUPLES
    /**
     * A desc_spec like this one but with a given tuple element.
     * 
     * @tparam I the element index.
     * @note This doesn't work under GCC 4.9.2.
     */
    template <std::size_t I> 
    auto with_tuple_element() {
      using ET = std::tuple_element_t<I, T>;
      using X = std::remove_pointer_t<ET>;
      return desc_spec<T, Fields...,
                       decltype(desc_spec_base<T>::template tuple_element_as_field<X, I>())>();
    }
#endif

    /**
     * A desc_spec for the named type, with no field_spec parameters.
     */    
#define GC_DESC(c) desc_spec<c>()
    /**
     * A desc_spec like this one, with the named superclass.
     *
     * Defers to desc_spec::with_super().
     */
#define WITH_SUPER(s) with_super<s>()
    /**
     * A desc_spec like this one, with the named member.
     *
     * Defers to desc_spec::with_field().  The point of this (rather
     * than just calling desc_spec::with_field()) is that we need to do
     * some magic to pull out the member's type.
     */
#define WITH_FIELD(f) with_field<std::remove_pointer_t<decltype(mem_fn_ptr_return(f))>, f>()

    /**
     * Fail a static assert if the enclosing field_spec parameters
     * don't cover all of the words in the type.
     *
     * @tparam Size the number of fields in the type.
     * @tparam Mask.  The result of calling coverage_mask().
     * @pre `Mask == 0`.  Fails static assert otherwise.
     * @note `Size` is currently ignored.  (It used to be needed but
     * no longer is and should probably be removed.)
     */
    template <std::size_t Size, std::size_t Mask>
    static void check_coverage() {
      static_assert(Mask == 0, "Not all fields covered");
    }
    
    /**
     * Convert the collector to a gc_descriptor.
     *
     * Calls check_coverage() to ensure complete coverage at compile
     * time and then calls to_descriptor() to compile the
     * gc_descriptor().
     *
     * @returns the equivalent gc_descriptor.
     * @pre check_coverage() doesn't fail.
     */
    operator gc_descriptor() const {
      check_coverage<desc_spec_base<T>::template width<T>(), desc_spec_base<T>::template coverage_mask<Fields...>()>();
      collector c;
      gc_descriptor d = c.to_descriptor();
      // d.trace(typeid(T).name());
      return d;
    }
  };

  /**
   * A helper function to allow us to get the type of a
   * pointer-to-member.
   *
   * @tparam T the enclosing class.
   * @tparam X the member type.
   * @returns a `nullptr` of type `X`.
   *
   * This is only called within a decltype() context to create a
   * template parameter by the WITH_FIELD() macro.
   */
  template <typename T, typename X>
  constexpr inline X *mem_fn_ptr_return(X T::*Field) {
    return nullptr;
  }
  

  /**
   * A convenience base class for gc_traits for types that are known
   * to not contain GC references.
   *
   * @tparam T the type, used to obtain the number of fields.
   *
   * @warning deriving from no_ref_descriptor is an assertion that there
   * are no GC references at all in the type, including in supertypes.
   * Being wrong about this is bad, as those references will not be
   * followed for marking.
   */
  template <typename T>
  class no_ref_descriptor {
  public:
    constexpr static std::size_t blob_size() {
      /**
       * The number of fields in the blob.
       * 
       * @returns the size in words, minus one if the type is GC
       * allocated, since the fields don't't include the descriptor.
       */
      return (gc_descriptor::size_in_words<T>()
	      -
	      std::is_base_of<gc_allocated,T>() ? 1 : 0);
    }
    /**
     * A blob gc_descriptor of the appropriate size.
     * 
     * @returns a reference to a blob gc_descriptor.
     */
    static const auto &descriptor() {
      static gc_descriptor d = gc_descriptor::blob(blob_size());
      return d;
    }
  };

  /**
   * A convenience base class for gc_traits for types that are to be
   * treated as a single GC reference.
   *
   * @warning deriving from is_ref_descriptor is an assertion that
   * this type is one word long and contains something that can be
   * interpreted as a gc_ptr (or, at least, an offset_ptr) in its
   * lower bits.  Being wrong about either of these would be bad.
   */
  struct is_ref_descriptor {
  public:
    /**
     * A single-field reference array gc_descriptor.
     * 
     * @returns a reference to a gc_descriptor for a one-word object
     * with a single GC reference.
     */
    static const auto &descriptor() {
      static gc_descriptor d = gc_descriptor::for_ref();
      return d;
    }
  };

  /**
   * A concept class to tell whether a class has a descriptor() method.
   *
   * Uses SFINAE to set #value to `true` if T::descriptor() exists and
   * false otehrwise.
   */
  template <typename T>
  class has_descriptor_method {
    /**
     * This is only defined if `decltype(T::descriptor())` is defined.
     *
     * The second member of the pair is of type std::true_type.
     */
    template <typename X=T>
    static std::pair<decltype(X::descriptor()),std::true_type> check(nullptr_t);
    /**
     * The default case, which will be used if the first one isn't defined.
     *
     * The second member of the pair is of type std::false_type.
     */
    static std::pair<void*, std::false_type> check(...);
    /**
     * This will be a std::pair whose second member is either
     * std::true_type or std::false_type.
     */
    using pt = decltype(check(nullptr));
  public:
    /**
     * `true` iff T::descriptor() is well-formed.
     */
    constexpr static bool value = pt::second_type::value;
  };

  /**
   * A specialization of gc_traits for all classes for which
   * `T::descriptor()` is well-defined.
   */
  template <typename T>
  struct gc_traits<T,std::enable_if_t<has_descriptor_method<T>::value>> {
    /** Return `T::descriptor()` */
    static const auto &descriptor() {
      return T::descriptor();
    }
  };

  /** 
   * A specialization of gc_traits for all zero-size classes.
   * 
   * Such classes are necessarily blobs.
   */
  template <typename T>
  struct gc_traits<T,std::enable_if_t<std::is_empty<T>::value>> 
    : no_ref_descriptor<T>
  {};

  /**
   * A specialization of gc_traits for all scalar types.
   *
   * This covers arithmetic types, pointer types, enums, and
   * `nullptr_t`.
   * 
   * Such classes are necessarily blobs.
   */
  template <typename T>
  struct gc_traits<T,std::enable_if_t<std::is_scalar<T>::value>>
    : no_ref_descriptor<T>
  {};


  /**
   * A specialization of gc_traits for reference types.
   * 
   * Such classes are necessarily blobs.
   */
  template <typename T>
  struct gc_traits<T,std::enable_if_t<std::is_reference<T>::value>> 
    : no_ref_descriptor<T>
  {};

  /**
   * A specialization of gc_traits for offset_ptr.
   * 
   * offset_ptr doesn't count as a GC reference, so this is a blob.
   */
  template <typename T>
  struct gc_traits<offset_ptr<T>> : no_ref_descriptor<offset_ptr<T>> {};

  /**
   * A specialization of gc_traits for gc_ptr<T>.
   *
   * This is a single GC reference.
   */
  template <typename T>
  struct gc_traits<gc_ptr<T>> : is_ref_descriptor {};

  template <typename T>
  struct gc_traits<weak_gc_ptr<T>> : is_ref_descriptor {};


  /**
   * A specialization of gc_traits for versioned_gc_ptr<T,NFlags>.
   *
   * This is a single GC reference.
   */
  template <typename T, std::size_t NFlags>
  struct gc_traits<versioned_gc_ptr<T,NFlags>> : is_ref_descriptor {};

  /**
   * A specialization of gc_traits for atomic_versioned_gc_ptr<T,NFlags>.
   *
   * This is a single GC reference.
   */
  template <typename T, std::size_t NFlags>
  struct gc_traits<atomic_versioned_gc_ptr<T,NFlags>> 
    : is_ref_descriptor {};

  /**
   * A specialization of gc_traits for std::atomic<T>.
   *
   * delegates to gc_traits<T>.
   */
  template <typename T>
  struct gc_traits<std::atomic<T>> {
    /** delegates to gc_traits<T>::descriptor() */
    static const auto &descriptor() {
      return gc_traits<T>::descriptor();
    }
  };

  /**
   * A specialization of gc_traits for std::pair<X,Y>.
   *
   * Covers both members of the pair.
   */
  template <typename T1, typename T2>
  struct gc_traits<std::pair<T1,T2>> {
    static const auto &descriptor() {
      using this_type = std::pair<T1,T2>;
      static gc_descriptor d =
	GC_DESC(this_type)
	.template WITH_FIELD(&this_type::first)
	.template WITH_FIELD(&this_type::second);
      return d;
    }
  };

#ifdef GC_FRIENDLY_TUPLES
  template <std::size_t N, typename Tuple>
  struct enumerate_tuple_elements {
    static auto desc() {
      auto prior = enumerate_tuple_elements<N-1, Tuple>::desc();
      return prior.template with_tuple_element<N-1>();
    }
  };

  template <typename Tuple>
  struct enumerate_tuple_elements<0, Tuple> {
    static auto desc() {
      return desc_spec<Tuple>();
    }
  };

  /**
   * A specialization of gc_traits for std::tuple.
   *
   * @note Doesn't seem to work under GCC 4.9.2.
   */
  template <typename...Types>
  struct gc_traits<std::tuple<Types...>> {
    static const auto &descriptor() {
      using this_type = std::tuple<Types...>;
      static gc_descriptor d =
        enumerate_tuple_elements<std::tuple_size<this_type>::value, this_type>
        ::desc();
      return d;
    }
  };
#endif

  /**
   * A specialization of gc_traits for ruts::uniform_key.
   * 
   * ruts::uniform_key is a blob.
   */
  template <>
  struct gc_traits<ruts::uniform_key> : no_ref_descriptor<ruts::uniform_key> {};

  /**
   * A specialization of gc_traits for ruts::with_uniform_id.
   * 
   * ruts::with_uniform_id is a blob.  Note that this only refers to
   * the base class itself.  Subclasses may add other fields.
   */
  template <>
  struct gc_traits<ruts::with_uniform_id> : no_ref_descriptor<ruts::with_uniform_id> {};



};

#endif
