/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#ifndef GC_STRING_H_
#define GC_STRING_H_

#include "mpgc/gc.h"
#include "mpgc/gc_vector.h"
#include <string>
#include <ostream>
#include <istream>
#include <sstream>
#include <algorithm>
#include <iterator>

namespace mpgc {
  template <typename CharT, typename Traits, typename PC=internal_pointers  >
  class gc_basic_string {
    template <typename C,typename T,typename P> friend class gc_basic_string;
    using rep_type = gc_basic_vector<CharT,PC>;
    template <typename Alloc> using std_string = std::basic_string<CharT, Traits, Alloc>;
    
  public:
    using traits_type = Traits;
    using value_type = typename Traits::char_type;
    using size_type = long;
    using difference_type = std::ptrdiff_t;
    using reference = typename rep_type::reference;
    using const_reference = typename rep_type::const_reference;
    using iterator = typename rep_type::iterator;
    using const_iterator = typename rep_type::const_iterator;
    using reverse_iterator = typename rep_type::reverse_iterator;
    using const_reverse_iterator = typename rep_type::const_reverse_iterator;
    constexpr static size_type npos = -1;
  private:
    /*
     * An empty _rep indicates an empty string.  Otherwise, _rep
     * contains all of the characters in the string, plus a null at
     * the end.  We only actually create the single null for an empty
     * string if somebody calls data() or c_str();
     */
    rep_type _rep;

    [[noreturn]] void throw_out_of_range(size_type pos, size_type n = size()) const;

    void check_pos(size_type pos, size_type n) const {
      if (pos < 0 || pos > n) {
        throw_out_of_range(pos, n);
      }
    }

    void check_pos(size_type pos) const {
      check_pos(pos, size());
    }

    size_type range_length(size_type pos, size_type count) const {
      size_type n = size();
      check_pos(pos, n);
      if (count == npos || pos+count > n) {
        count = n-pos;
      }
      return count;
    }
    template <typename Iter>
    gc_basic_string &assign_n(Iter from, size_type n) {
      resize(n);
      std::copy_n(from, n, _rep.begin());
      return *this;
    }
  public:
    gc_basic_string() noexcept {}
    template <typename PC2>
    gc_basic_string(const gc_basic_string<CharT,Traits,PC2> &other)
      : _rep(other._rep)
    {
    }
    template <typename PC2>
    gc_basic_string(gc_basic_string<CharT,Traits,PC2> &&other)
      : _rep(std::move(other._rep))
    {
    }
    gc_basic_string(size_type count, value_type ch)
    {
      assign(count, ch);
    }
    template <typename PC2>
    gc_basic_string(const gc_basic_string<CharT,Traits,PC2> &other,
                    size_type pos, size_type count = npos)
    {
      assign(other, pos, count);
    }
    template <typename Alloc>
    gc_basic_string(const std_string<Alloc> &s,
                    size_type pos = 0, size_type count = npos)
    {
      assign(s, pos, count);
    }
    gc_basic_string(const value_type *s, size_type count)
    {
      assign(s, count);
    }
    gc_basic_string(const value_type *s)
    {
      assign(s);
    }
    template <typename InputIt>
    gc_basic_string(InputIt first, InputIt last)
    {
      assign(first, last);
    }
    gc_basic_string(std::initializer_list<value_type> init)
    {
      assign_n(init.cbegin(), init.size());
    }

    static const auto &descriptor() {
      static gc_descriptor d =
	GC_DESC(gc_basic_string)
	.template WITH_FIELD(&gc_basic_string::_rep);
      return d;
    }

    gc_basic_string &assign(size_type count, value_type ch) {
      resize(count);
      std::fill(_rep.begin(), _rep.end()-1, ch);
      return *this;
    }
    
    template <typename PC2>
    gc_basic_string &assign(const gc_basic_string<CharT,Traits,PC2> &str) {
      return assign_n(str.begin(), str.size());
    }

    template <typename PC2>
    gc_basic_string &assign(const gc_basic_string<CharT,Traits,PC2> &str,
                            size_type pos, size_type count = npos)
    {
      return assign_n(str.cbegin(), str.range_length(pos, count));
    }

    template <typename Alloc>
    gc_basic_string &assign(const std_string<Alloc> &str,
                            size_type pos = 0,
                            size_type count = npos)
    {
      size_type n = str.size();
      check_pos(pos, n);
      if (count == npos || pos+count > n) {
        count = n-pos;
      }
      return assign_n(str.cbegin(), count);
    }

    gc_basic_string &assign(const value_type *s, size_type count) {
      return assign_n(s, count);
    }

    gc_basic_string &assign(const value_type *s) {
      return assign_n(s, traits_type::length(s));
    }

    template <typename Iter>
    gc_basic_string &assign(Iter first, Iter last) {
      return assign_n(first, std::distance(first, last));
    }

    gc_basic_string &assign(std::initializer_list<value_type> ilist) {
      return assign(ilist.begin(), ilist.size());
    }

    template <typename PC2>
    gc_basic_string &operator =(const gc_basic_string<CharT,Traits,PC2> &str) {
      return assign(str);
    }

    template <typename PC2>
    gc_basic_string &operator =(gc_basic_string<CharT,Traits,PC2> &&str) {
      _rep = std::move(str._rep);
      return *this;
    }

    template <typename Alloc>
    gc_basic_string &operator =(const std_string<Alloc> &str) {
      return assign(str);
    }

    gc_basic_string &operator =(const value_type *s) {
      return assign(s);
    }

    gc_basic_string &operator =(std::initializer_list<value_type> ilist) {
      return assign(ilist);
    }

    gc_basic_string &operator =(value_type ch) {
      return assign({ch});
    }
        
    
    size_type size() const {
      size_type n = _rep.size();
      return n == 0 ? 0 : n-1;
    }

    size_type length() const {
      return size();
    }

    bool empty() const {
      return size() == 0;
    }

    /*
     * We don't currently implement the shrinking here.
     */
    void reserve(size_type new_cap = 0) {
      _rep.reserve(new_cap+1);
    }

    size_type capacity() const {
      size_type n = _rep.capacity();
      return n == 0 ? 0 : n-1;
    }

    void shrink_to_fit() {
      _rep.shrink_to_fit();
    }

    iterator begin() {
      return _rep.begin();
    }
    const_iterator begin() const {
      return _rep.cbegin();
    }
    const_iterator cbegin() const {
      return begin();
    }

    iterator end() {
      return empty() ? iterator{} : _rep.end()-1;
    }
    const_iterator end() const {
      return empty() ? const_iterator() : _rep.end()-1;
    }
    const_iterator cend() const {
      return end();
    }

    iterator rbegin() {
      return reverse_iterator(end());
    }
    const_iterator rbegin() const {
      return reverse_iterator(end());
    }
    const_iterator crbegin() const {
      return rbegin();
    }

    iterator rend() {
      return _rep.rend();
    }
    const_iterator rend() const {
      return _rep.rend();
    }
    const_iterator crend() const {
      return _rep.crend();
    }

    reference at(size_type pos) {
      check_pos(pos);
      return _rep.at(pos);
    }

    const_reference at(size_type pos) const {
      check_pos(pos);
      return _rep.at(pos);
    }

    reference operator[](size_type pos) {
      return _rep[pos];
    }
      
    const_reference operator[](size_type pos) const {
      return _rep[pos];
    }

    reference front() {
      assert(!empty());
      return _rep.front();
    }

    const_reference front() const {
      return _rep.front();
    }

    reference back() {
      return _rep[size()-1];
    }

    const_reference back() const {
      return _rep[size()-1];
    }

    /*
     * WARNING: The pointers handed out by data() and c_str() are
     * not anchored.  They must be used with care!
     */

    value_type *data() {
      if (_rep.empty()) {
        _rep = {value_type{}};
      }
      return begin().as_bare_pointer();
    }
      
    const value_type *data() const {
      if (_rep.empty()) {
        gc_basic_string *nc_this = const_cast<gc_basic_string*>(this);
        nc_this->_rep = {value_type{}};
      }
      return &(*cbegin());
    }

    value_type *c_str() {
      return data();
    }

    const value_type *c_str() const {
      return data();
    }

    void clear() {
      _rep.clear();
    }

    gc_basic_string &insert(size_type index, size_type count, value_type ch) {
      check_pos(index);
      insert(cbegin()+index, count, ch);
      return *this;
    }

    gc_basic_string &insert(size_type index, const value_type *s, size_type count) {
      check_pos(index);
      insert(cbegin()+index, s, s+count);
      return *this;
    }

    gc_basic_string &insert(size_type index, const value_type *s) {
      return insert(index, s, traits_type::length(s));
    }

    template <typename PC2>
    gc_basic_string &insert(size_type index,
                            const gc_basic_string<CharT,Traits,PC2> &str,
                            size_type from = 0, size_type count = npos)
    {
      check_pos(index);
      size_type n = str.range_length(from, count);
      insert(cbegin()+index, str.cbegin()+from, str.cbegin()+from+n);
      return *this;
    }

    template <typename Alloc>
    gc_basic_string &insert(size_type index, const std_string<Alloc> &str,
                            size_type from = 0, size_type count = npos)
    {
      check_pos(index);
      size_type n = str.size();
      auto start = str.cbegin()+from;
      auto end = start+count;
      if (count == npos || from+count > n) {
        end = str.cend();
      }
      insert(cbegin()+index, start, end);
      return *this;
    }

    iterator insert(const_iterator pos, size_type count, value_type ch) {
      if (count == 0) {
        return begin()+(pos-cbegin());
      }
      if (empty()) {
        assert(pos == cend());
        assign(count, ch);
        return begin();
      } else {
        return _rep.insert(pos, count, ch);
      }
    }

    iterator insert(const_iterator pos, value_type ch) {
      if (empty()) {
        assert(pos == cend());
        assign(1, ch);
        return begin();
      } else {
        return _rep.insert(pos, 1, ch);
      }
    }

    iterator insert(const_iterator pos, std::initializer_list<value_type> init) {
      return insert(pos, init.begin(), init.end());
    }
    

    template <typename Iter>
    iterator insert(const_iterator pos, Iter first, Iter last) {
      if (first == last) {
        return begin()+(pos-cbegin());
      }
      if (empty()) {
        assert(pos == cend());
        assign(first, last);
        return begin();
      } else {
        return _rep.insert(pos, first, last);
      }
    }

    gc_basic_string &erase(size_type index = 0, size_type count = npos) {
      size_type n = range_length(index, count);
      const_iterator from = cbegin()+index;
      const_iterator to = from+count;
      erase(from, to);
      return *this;
    }

    iterator erase(const_iterator position) {
      return _rep.erase(position);
    }

    iterator erase(const_iterator from, const_iterator to) {
      return _rep.erase(from, to);
    }

    void push_back(value_type ch) {
      if (empty()) {
        assign(1, ch);
      } else {
        _rep.back() = ch;
        _rep.push_back(value_type{});
      }
    }

    void pop_back() {
      if (!empty()) {
        _rep.pop_back();
        _rep.back() = value_type{};
      }
    }

    gc_basic_string &append(size_type count, value_type ch) {
      return insert(size(), count, ch);
    }

    template <typename PC2>
    gc_basic_string &append(const gc_basic_string<CharT,Traits,PC2> &str,
                            size_type from = 0, size_type count = npos)
    {
      return insert(size(), str, from, count);
    }

    template <typename Alloc>
    gc_basic_string &append(const std_string<Alloc> &str,
                            size_type from = 0, size_type count = npos)
    {
      return insert(size(), str, from, count);
    }

    gc_basic_string &append(const value_type *s, size_type count) {
      return insert(size(), s, count);
    }

    gc_basic_string &append(const value_type *s) {
      return insert(size(), s);
    }

    template <typename Iter>
    gc_basic_string &append(Iter first, Iter last) {
      insert(cend(), first, last);
      return *this;
    }

    gc_basic_string &append(std::initializer_list<value_type> init) {
      insert(cend(), init);
      return *this;
    }

    template <typename PC2>
    gc_basic_string &operator +=(const gc_basic_string<CharT,Traits,PC2> &str) {
      return append(str);
    }

    template <typename PC2>
    gc_basic_string &operator +=(gc_basic_string<CharT,Traits,PC2> &&str) {
      if (empty()) {
        assign(std::move(str));
        return *this;
      }
      gc_basic_string rhs{std::move(str)};
      return append(str);
    }

    template <typename Alloc>
    gc_basic_string &operator +=(const std_string<Alloc> &str)
    {
      return append(str);
    }

    gc_basic_string &operator +=(value_type ch) {
      push_back(ch);
      return *this;
    }

    gc_basic_string &operator +=(const value_type *str) {
      return append(str);
    }

    gc_basic_string &operator +=(std::initializer_list<value_type> ilist) {
      return append(ilist);
    }
  private:

  public:
    template <typename PC2>
    int compare(const gc_basic_string<CharT,Traits,PC2> &str) const {
      return compare(0, npos, str);
    }

    template <typename PC2>
    int compare(size_type p1, size_type c1,
                const gc_basic_string<CharT,Traits,PC2> &str,
                size_type p2 = 0, size_type c2 = npos) const
    {
      if (c2 == npos) {
        c2 = str.size()-p2;
      }
      const_iterator i = str.cbegin()+p2;
      return compare(p1, c1, i.as_bare_pointer(), c2);
    }

    template <typename Alloc>
    int compare(const std_string<Alloc> &str) const {
      return compare(0, npos, str);
    }

    template <typename Alloc>
    int compare(size_type p1, size_type c1,
                const std_string<Alloc> &str,
                size_type p2 = 0, size_type c2 = npos) const
    {
      if (c2 == npos) {
        c2 = str.size()-p2;
      }
      return compare(p1, c1, str.data()+p2, c2);
    }

    int compare(const value_type *s) const {
      return compare(0, npos, s);
    }

    int compare(size_type p, size_type c, const value_type *s) const {
      return compare(p, c, s, traits_type::length(s));
    }

    int compare(size_type p1, size_type c1,
                const value_type *s,
                size_type c2) const
    {
      if (c1 == npos) {
        c1 = size()-p1;
      }
      size_type len = std::min(c1, c2);
      const_iterator i = cbegin()+p1;
      const value_type *bp = i.as_bare_pointer();
      int cmp = traits_type::compare(bp, s, len);
      return cmp == 0 ? c1-c2 : cmp;
    }

    template <typename Iter>
    gc_basic_string &replace(size_type pos, size_type count,
                             Iter source, Iter last)
    {
      size_type hole_size = range_length(pos, count);
      iterator dest = begin()+pos;
      for (;
           source != last && count > 0;
           source++, hole_size--, pos++) {
        *dest = *source;
      }

      if (hole_size > 0) {
        /*
         * We copied over everything, but we didn't fill the hole
         */
        erase(dest, dest+hole_size);
      } else if (source != last) {
        /*
         * We filled the hole, but there's more to copy
         */
        insert(pos, source, last);
      } else {
        /*
         * We exactly filled.  There's nothing to do.
         */
      }
      return *this;
    }
    
    template <typename Iter>
    gc_basic_string &replace(const_iterator first, const_iterator last,
                             Iter source, Iter last2)
    {
      return replace(first-cbegin(), last-first, source, last2);
    }

    template <typename PC2>
    gc_basic_string &replace(size_type pos, size_type count,
                             const gc_basic_string<CharT,Traits,PC2> &str,
                             size_type pos2 = 0, size_type count2 = npos)
    {
      size_type c2 = str.range_length(pos2, count2);
      const_iterator source = str.begin()+pos2;
      const_iterator last = source + c2;
      return replace(pos, count, source, last);
    }

    template <typename PC2>
    gc_basic_string &replace(const_iterator first, const_iterator last,
                             const gc_basic_string<CharT,Traits,PC2> &str,
                             size_type pos2 = 0, size_type count2 = npos)
    {
      return replace(first-begin(), last-first, str, pos2, count2);
    }

    template <typename Alloc>
    gc_basic_string &replace(size_type pos, size_type count,
                             const std_string<Alloc> &str,
                             size_type pos2 = 0, size_type count2 = npos)
    {
      if (count2 == str.npos || pos2+count2 > str.size()) {
        count2 = str.size()-pos2;
      }
      auto source = str.begin()+pos2;
      auto last = source + count2;
      return replace(pos, count, source, last);
    }

    template <typename Alloc>
    gc_basic_string &replace(const_iterator first, const_iterator last,
                             const std_string<Alloc> &str,
                             size_type pos2 = 0, size_type count2 = npos)
    {
      return replace(first-begin(), last-first, str, pos2, count2);
    }
    
    gc_basic_string &replace(size_type pos, size_type count,
                             const value_type *str, size_type count2)
    {
      return replace(pos, count, str, str+count2);
    }

    gc_basic_string &replace(const_iterator first, const_iterator last,
                             const value_type *str, size_type count2)
    {
      return replace(first-begin(), last-first, str, count2);
    }

    gc_basic_string &replace(size_type pos, size_type count,
                             const value_type *str)
    {
      return replace(pos, count, str, traits_type::length(str));
    }

    gc_basic_string &replace(const_iterator first, const_iterator last,
                             const value_type *str)
    {
      return replace(first-begin(), last-first, str);
    }

    gc_basic_string &replace(size_type pos, size_type count,
                             std::initializer_list<value_type> init)
    {
      return replace(pos, count, init.begin(), init.end());
    }

    gc_basic_string &replace(const_iterator first, const_iterator last,
                             std::initializer_list<value_type> init)
    {
      return replace(first-begin(), last-first, init);
    }

    gc_basic_string substr(size_type pos = 0, size_type count = npos)
    {
      return gc_basic_string(*this, pos, count);
    }

    template <typename Iter>
    size_type copy(Iter dest, size_type count, size_type pos = 0) {
      size_type n = range_length(pos, count);
      std::copy_n(begin()+pos, n, dest);
      return n;
    }
    
    void resize(size_type count) {
      if (count == 0) {
        _rep.clear();
      } else {
        _rep.resize(count+1);
        _rep[count] = value_type{};
      }
    }

    void resize(size_type count, value_type ch) {
      if (count == 0) {
        _rep.clear();
      } else {
        _rep.resize(count+1, ch);
        _rep[count] = value_type{};
      }
    }

    void swap(gc_basic_string &other) noexcept {
      _rep.swap(other._rep);
    }


    std::pair<const_iterator, const_iterator> begin_and_end() const {
      const_iterator cb = cbegin();
      const_iterator ce = cend();
      for (const_iterator cb2 = cbegin(); cb != cb2; cb = cb2) {
        ce = cend();
      }
      return std::make_pair(cb,ce);
    }
    
    std::pair<size_type, const_iterator> size_and_begin() const {
      const_iterator cb;
      const_iterator ce;
      std::tie(cb, ce) = begin_and_end();
      return std::make_pair(ce-cb, cb);
    }

  private:

    template <typename Fn>
    size_type find_match_forward(size_type start_pos,
                                 size_type match_size, Fn &&func) const
    {
      const_iterator cb;
      size_type my_size;
      std::tie(my_size, cb) = size_and_begin();
      size_type last_possible = my_size-match_size;
      const value_type *first = cb.as_bare_pointer();
      for (size_type p = start_pos; p<=last_possible; p++) {
        if (std::forward<Fn>(func)(first+p)) {
          return p;
        }
      }
      return npos;
    }

    template <typename Fn>
    size_type find_match_backward(size_type start_pos,
                                  size_type match_size, Fn &&func) const
    {
      const_iterator cb;
      size_type my_size;
      std::tie(my_size, cb) = size_and_begin();
      size_type first_possible = my_size-match_size;
      const value_type *first = cb.as_bare_pointer();
      for (size_type p = first_possible; p>=0; p--) {
        if (std::forward<Fn>(func)(first+p)) {
          return p;
        }
      }
      return npos;
    }

  public:
    size_type find(const value_type *s, size_type pos, size_type count) const {
      return find_match_forward(pos, count,
                                [=](const value_type *p) {
                                  return traits_type::compare(p,s,count) == 0;
                                });
    }

    size_type find(const value_type *s, size_type pos = 0) const {
      return find(s, pos, traits_type::length(s));
    }

    size_type find(value_type ch, size_type pos = 0) const {
      return find(&ch, pos, 1);
    }

    template <typename PC2>
    size_type find(const gc_basic_string<CharT,Traits,PC2> &s, size_type pos = 0) const noexcept {
      const_iterator cb;
      size_type his_size;
      std::tie(his_size, cb) = s.size_and_begin();
      return find(cb.as_bare_pointer(), pos, his_size);
    }

    template <typename Alloc>
    size_type find(const std::basic_string<CharT,Traits,Alloc> &s,
                   size_type pos = 0) const noexcept {
      return find(s.data(), pos, s.size());
    }
      
    size_type find_first_of(const value_type *s, size_type pos, size_type count) const {
      return find_match_forward(pos, 1,
                                [=](const value_type *p) {
                                  value_type target = *p;
                                  auto pred = [=](value_type c) {
                                    return traits_type::eq(c,target);
                                  };
                                  auto last = s+count;
                                  return std::find_if(s,last,pred)!=last;
                                });
    }

    size_type find_first_of(const value_type *s, size_type pos = 0) const {
      return find_first_of(s, pos, traits_type::length(s));
    }

    size_type find_first_of(value_type ch, size_type pos = 0) const {
      return find_first_of(&ch, pos, 1);
    }

    template <typename PC2>
    size_type find_first_of(const gc_basic_string<CharT,Traits,PC2> &s,
                            size_type pos = 0) const noexcept {
      const_iterator cb;
      size_type his_size;
      std::tie(his_size, cb) = s.size_and_begin();
      return find_first_of(cb.as_bare_pointer(), pos, his_size);
    }

    template <typename Alloc>
    size_type find_first_of(const std::basic_string<CharT,Traits,Alloc> &s,
                   size_type pos = 0) const noexcept {
      return find_first_of(s.data(), pos, s.size());
    }

    size_type find_first_not_of(const value_type *s, size_type pos, size_type count) const {
      return find_match_forward(pos, 1,
                                [=](const value_type *p) {
                                  value_type target = *p;
                                  auto pred = [=](value_type c) {
                                    return traits_type::eq(c,target);
                                  };
                                  auto last = s+count;
                                  return !std::find_if(s,last,pred)!=last;
                                });
    }

    size_type find_first_not_of(const value_type *s, size_type pos = 0) const {
      return find_first_not_of(s, pos, traits_type::length(s));
    }

    size_type find_first_not_of(value_type ch, size_type pos = 0) const {
      return find_first_not_of(&ch, pos, 1);
    }

    template <typename PC2>
    size_type find_first_not_of(const gc_basic_string<CharT,Traits,PC2> &s,
                                size_type pos = 0) const noexcept {
      const_iterator cb;
      size_type his_size;
      std::tie(his_size, cb) = s.size_and_begin();
      return find_first_not_of(cb.as_bare_pointer(), pos, his_size);
    }

    template <typename Alloc>
    size_type find_first_not_of(const std::basic_string<CharT,Traits,Alloc> &s,
                   size_type pos = 0) const noexcept {
      return find_first_not_of(s.data(), pos, s.size());
    }

    size_type rfind(const value_type *s, size_type pos, size_type count) const {
      return find_match_backward(pos, count,
                                 [=](const value_type *p) {
                                   return traits_type::compare(p,s,count) == 0;
                                 });
    }

    size_type rfind(const value_type *s, size_type pos = 0) const {
      return rfind(s, pos, traits_type::length(s));
    }

    size_type rfind(value_type ch, size_type pos = 0) const {
      return rfind(&ch, pos, 1);
    }

    template <typename PC2>
    size_type rfind(const gc_basic_string<CharT,Traits,PC2> &s,
                    size_type pos = 0) const noexcept {
      const_iterator cb;
      size_type his_size;
      std::tie(his_size, cb) = s.size_and_begin();
      return rfind(cb.as_bare_pointer(), pos, his_size);
    }

    template <typename Alloc>
    size_type rfind(const std::basic_string<CharT,Traits,Alloc> &s,
                   size_type pos = 0) const noexcept {
      return rfind(s.data(), pos, s.size());
    }
      
    size_type find_last_of(const value_type *s, size_type pos, size_type count) const {
      return find_match_backward(pos, 1,
                                 [=](const value_type *p) {
                                   value_type target = *p;
                                   auto pred = [=](value_type c) {
                                     return traits_type::eq(c,target);
                                   };
                                   auto last = s+count;
                                   return std::find_if(s,last,pred)!=last;
                                 });
    }

    size_type find_last_of(const value_type *s, size_type pos = 0) const {
      return find_last_of(s, pos, traits_type::length(s));
    }

    size_type find_last_of(value_type ch, size_type pos = 0) const {
      return find_last_of(&ch, pos, 1);
    }

    template <typename PC2>
    size_type find_last_of(const gc_basic_string<CharT,Traits,PC2> &s,
                           size_type pos = 0) const noexcept {
      const_iterator cb;
      size_type his_size;
      std::tie(his_size, cb) = s.size_and_begin();
      return find_last_of(cb.as_bare_pointer(), pos, his_size);
    }

    template <typename Alloc>
    size_type find_last_of(const std::basic_string<CharT,Traits,Alloc> &s,
                   size_type pos = 0) const noexcept {
      return find_last_of(s.data(), pos, s.size());
    }

    size_type find_last_not_of(const value_type *s, size_type pos, size_type count) const {
      return find_match_backward(pos, 1,
                                 [=](const value_type *p) {
                                   value_type target = *p;
                                   auto pred = [=](value_type c) {
                                     return traits_type::eq(c,target);
                                   };
                                   auto last = s+count;
                                   return !std::find_if(s,last,pred)!=last;
                                 });
    }

    size_type find_last_not_of(const value_type *s, size_type pos = 0) const {
      return find_last_not_of(s, pos, traits_type::length(s));
    }

    size_type find_last_not_of(value_type ch, size_type pos = 0) const {
      return find_last_not_of(&ch, pos, 1);
    }

    template <typename PC2>
    size_type find_last_not_of(const gc_basic_string<CharT,Traits,PC2> &s,
                               size_type pos = 0) const noexcept {
      const_iterator cb;
      size_type his_size;
      std::tie(his_size, cb) = s.size_and_begin();
      return find_last_not_of(cb.as_bare_pointer(), pos, his_size);
    }

    template <typename Alloc>
    size_type find_last_not_of(const std::basic_string<CharT,Traits,Alloc> &s,
                   size_type pos = 0) const noexcept {
      return find_last_not_of(s.data(), pos, s.size());
    }

    template <typename Fn>
    auto to_number(Fn&& func,
                   std::size_t *pos = nullptr,
                   int base = 10) const
    {
      const_iterator cb;
      size_type size;
      std::tie(size, cb) = size_and_begin();
      const value_type *start = cb.as_bare_pointer();
      value_type *end;
      auto val = std::move(func)(start, &end, base);
      if (pos != nullptr) {
        *pos = end-start;
      }
      return val;
    }
  };

  template <typename C, typename T, typename PC>
  void gc_basic_string<C,T,PC>::throw_out_of_range(size_type pos, size_type n) const {
    std::ostringstream ss;
    ss << "Pos: " << pos << "; len: " << n;
    throw std::out_of_range{ss.str()};
  }
  
  using gc_string = gc_basic_string<char, std::char_traits<char>, internal_pointers>;
  using gc_wstring = gc_basic_string<wchar_t, std::char_traits<wchar_t>, internal_pointers>;
  using gc_uc16string = gc_basic_string<char16_t, std::char_traits<char16_t>, internal_pointers>;
  using gc_uc32string = gc_basic_string<char32_t, std::char_traits<char32_t>, internal_pointers>;

  using external_gc_string = gc_basic_string<char, std::char_traits<char>, external_pointers>;
  using external_gc_wstring = gc_basic_string<wchar_t, std::char_traits<wchar_t>, external_pointers>;
  using external_gc_uc16string = gc_basic_string<char16_t, std::char_traits<char16_t>, external_pointers>;
  using external_gc_uc32string = gc_basic_string<char32_t, std::char_traits<char32_t>, external_pointers>;

  template <typename C, typename T, typename PC, typename SC, typename ST>
  inline
  std::basic_ostream<SC,ST> &
  operator <<(std::basic_ostream<SC,ST> &os,
              const gc_basic_string<C,T,PC> &s)
  {
    if (!s.empty()) {
      /*
       * We use the bare pointer from the iterator rather than data()
       * to ensure that nobody resizes behind our back.  
       */
      auto anchor = s.cbegin();
      os << anchor.as_bare_pointer();
    }
    return os;
  }

  /*
   * There's almost certainly a better way to do this.
   */
  template <typename C, typename T, typename PC, typename SC, typename ST>
  std::basic_istream<SC,ST> &
  operator >>(std::basic_istream<SC,ST> &is,
              gc_basic_string<C,T,PC> &s)
  {
    std::basic_string<C,T> buf;
    is >> buf;
    s = buf;
    return is;
  }

  template <typename C, typename T, typename PC, typename PC2>
  inline
  gc_basic_string<C,T,PC>
  operator +(const gc_basic_string<C,T,PC> &lhs,
             const gc_basic_string<C,T,PC2> &rhs)
  {
    gc_basic_string<C,T,PC> res(lhs);
    res += rhs;
    return res;
  }

  template <typename C, typename T, typename PC>
  inline
  gc_basic_string<C,T,PC>
  operator +(const C *lhs,
             const gc_basic_string<C,T,PC> &rhs)
  {
    gc_basic_string<C,T,PC> res(lhs);
    res += rhs;
    return res;
  }

  template <typename C, typename T, typename PC>
  inline
  gc_basic_string<C,T,PC>
  operator +(const gc_basic_string<C,T,PC> &lhs,
             const C *rhs)
  {
    gc_basic_string<C,T,PC> res(lhs);
    res += rhs;
    return res;
  }
  
  template <typename C, typename T, typename PC, typename A>
  inline
  gc_basic_string<C,T,PC>
  operator +(const std::basic_string<C,T,A> &lhs,
             const gc_basic_string<C,T,PC> &rhs)
  {
    gc_basic_string<C,T,PC> res(lhs);
    res += rhs;
    return res;
  }

  template <typename C, typename T, typename PC, typename A>
  inline
  gc_basic_string<C,T,PC>
  operator +(const gc_basic_string<C,T,PC> &lhs,
             const std::basic_string<C,T,A> &rhs)
  {
    gc_basic_string<C,T,PC> res(lhs);
    res += rhs;
    return res;
  }
  
  template <typename C, typename T, typename PC>
  inline
  gc_basic_string<C,T,PC>
  operator +(C lhs,
             const gc_basic_string<C,T,PC> &rhs)
  {
    gc_basic_string<C,T,PC> res(lhs);
    res += rhs;
    return res;
  }

  template <typename C, typename T, typename PC>
  inline
  gc_basic_string<C,T,PC>
  operator +(const gc_basic_string<C,T,PC> &lhs,
             C rhs)
  {
    gc_basic_string<C,T,PC> res(lhs);
    res += rhs;
    return res;
  }
  
  template <typename C, typename T, typename PC>
  inline
  gc_basic_string<C,T,PC>
  operator +(gc_basic_string<C,T,PC> &&lhs,
             const gc_basic_string<C,T,PC> &rhs)
  {
    gc_basic_string<C,T,PC> res(std::move(lhs));
    res += rhs;
    return res;
  }

  template <typename C, typename T, typename PC>
  inline
  gc_basic_string<C,T,PC>
  operator +(const gc_basic_string<C,T,PC> &lhs,
             gc_basic_string<C,T,PC> &&rhs)
  {
    gc_basic_string<C,T,PC> res(lhs);
    res += std::move(rhs);
    return res;
  }

  template <typename C, typename T, typename PC>
  inline
  gc_basic_string<C,T,PC>
  operator +(gc_basic_string<C,T,PC> &&lhs,
             gc_basic_string<C,T,PC> &&rhs)
  {
    gc_basic_string<C,T,PC> res(std::move(lhs));
    res += std::move(rhs);
    return res;
  }

  template <typename C, typename T, typename PC>
  inline
  gc_basic_string<C,T,PC>
  operator +(const C *lhs,
             gc_basic_string<C,T,PC> &&rhs)
  {
    gc_basic_string<C,T,PC> res(lhs);
    res += std::move(rhs);
    return res;
  }

  template <typename C, typename T, typename PC>
  inline
  gc_basic_string<C,T,PC>
  operator +(gc_basic_string<C,T,PC> &&lhs,
             const C *rhs)
  {
    gc_basic_string<C,T,PC> res(std::move(lhs));
    res += rhs;
    return res;
  }
  
  template <typename C, typename T, typename PC, typename A>
  inline
  gc_basic_string<C,T,PC>
  operator +(const std::basic_string<C,T,A> &lhs,
             gc_basic_string<C,T,PC> &&rhs)
  {
    gc_basic_string<C,T,PC> res(lhs);
    res += std::move(rhs);
    return res;
  }

  template <typename C, typename T, typename PC, typename A>
  inline
  gc_basic_string<C,T,PC>
  operator +(gc_basic_string<C,T,PC> &&lhs,
             const std::basic_string<C,T,A> &rhs)
  {
    gc_basic_string<C,T,PC> res(std::move(lhs));
    res += rhs;
    return res;
  }
  
  template <typename C, typename T, typename PC>
  inline
  gc_basic_string<C,T,PC>
  operator +(C lhs,
             gc_basic_string<C,T,PC> &&rhs)
  {
    gc_basic_string<C,T,PC> res(lhs);
    res += std::move(rhs);
    return res;
  }

  template <typename C, typename T, typename PC>
  inline
  gc_basic_string<C,T,PC>
  operator +(gc_basic_string<C,T,PC> &&lhs,
             C rhs)
  {
    gc_basic_string<C,T,PC> res(std::move(lhs));
    res += rhs;
    return res;
  }

  template <typename C, typename T, typename PC, typename PC2>
  inline
  bool operator ==(const gc_basic_string<C,T,PC> &lhs,
                   const gc_basic_string<C,T,PC2> &rhs) noexcept
  {
    return lhs.compare(rhs) == 0;
  }
  template <typename C, typename T, typename PC>
  inline
  bool operator ==(nullptr_t, const gc_basic_string<C,T,PC> &rhs) noexcept
  {
    return rhs.empty();
  }
  template <typename C, typename T, typename PC>
  inline
  bool operator ==(const gc_basic_string<C,T,PC> &lhs, nullptr_t) noexcept
  {
    return lhs.empty();
  }
  template <typename C, typename T, typename PC>
  inline
  bool operator ==(const gc_basic_string<C,T,PC> &lhs, const C *rhs)
  {
    return lhs.compare(rhs) == 0;
  }
  template <typename C, typename T, typename PC>
  inline
  bool operator ==(const C *lhs, const gc_basic_string<C,T,PC> &rhs)
  {
    return rhs.compare(rhs) == 0;
  }
  template <typename C, typename T, typename PC, typename A>
  inline
  bool operator ==(const gc_basic_string<C,T,PC> &lhs,
                   const std::basic_string<C,T,A> &rhs) noexcept
  {
    return lhs.compare(rhs) == 0;
  }
  template <typename C, typename T, typename PC, typename A>
  inline
  bool operator ==(const std::basic_string<C,T,A> &lhs,
                   const gc_basic_string<C,T,PC> &rhs) noexcept
  {
    return rhs.compare(rhs) == 0;
  }
  
  template <typename C, typename T, typename PC, typename PC2>
  inline
  bool operator !=(const gc_basic_string<C,T,PC> &lhs,
                   const gc_basic_string<C,T,PC2> &rhs) noexcept
  {
    return lhs.compare(rhs) != 0;
  }
  template <typename C, typename T, typename PC>
  inline
  bool operator !=(nullptr_t lhs, const gc_basic_string<C,T,PC> &rhs) noexcept
  {
    return !rhs.empty();
  }
  template <typename C, typename T, typename PC>
  inline
  bool operator !=(const gc_basic_string<C,T,PC> &lhs, nullptr_t rhs) noexcept
  {
    return !lhs.empty();
  }
  template <typename C, typename T, typename PC>
  inline
  bool operator !=(const gc_basic_string<C,T,PC> &lhs, const C *rhs)
  {
    return lhs.compare(rhs) != 0;
  }
  template <typename C, typename T, typename PC>
  inline
  bool operator !=(const C *lhs, const gc_basic_string<C,T,PC> &rhs)
  {
    return rhs.compare(rhs) != 0;
  }
  template <typename C, typename T, typename PC, typename A>
  inline
  bool operator !=(const gc_basic_string<C,T,PC> &lhs,
                   const std::basic_string<C,T,A> &rhs) noexcept
  {
    return lhs.compare(rhs) != 0;
  }
  template <typename C, typename T, typename PC, typename A>
  inline
  bool operator !=(const std::basic_string<C,T,A> &lhs,
                   const gc_basic_string<C,T,PC> &rhs) noexcept
  {
    return rhs.compare(rhs) != 0;
  }
  
  template <typename C, typename T, typename PC, typename PC2>
  inline
  bool operator <(const gc_basic_string<C,T,PC> &lhs,
                  const gc_basic_string<C,T,PC2> &rhs) noexcept
  {
    return lhs.compare(rhs) < 0;
  }
  template <typename C, typename T, typename PC>
  inline
  bool operator <(nullptr_t lhs, const gc_basic_string<C,T,PC> &rhs) noexcept
  {
    return !rhs.empty();
  }
  template <typename C, typename T, typename PC>
  inline
  bool operator <(const gc_basic_string<C,T,PC> &lhs, nullptr_t rhs) noexcept
  {
    return false;
  }
  template <typename C, typename T, typename PC>
  inline
  bool operator <(const gc_basic_string<C,T,PC> &lhs, const C *rhs)
  {
    return lhs.compare(rhs) < 0;
  }
  template <typename C, typename T, typename PC>
  inline
  bool operator <(const C *lhs, const gc_basic_string<C,T,PC> &rhs)
  {
    return rhs.compare(rhs) >= 0;
  }
  template <typename C, typename T, typename PC, typename A>
  inline
  bool operator <(const gc_basic_string<C,T,PC> &lhs,
                  const std::basic_string<C,T,A> &rhs) noexcept
  {
    return lhs.compare(rhs) < 0;
  }
  template <typename C, typename T, typename PC, typename A>
  inline
  bool operator <(const std::basic_string<C,T,A> &lhs,
                  const gc_basic_string<C,T,PC> &rhs) noexcept
  {
    return rhs.compare(rhs) >= 0;
  }
  
  template <typename C, typename T, typename PC, typename PC2>
  inline
  bool operator <=(const gc_basic_string<C,T,PC> &lhs,
                   const gc_basic_string<C,T,PC2> &rhs) noexcept
  {
    return lhs.compare(rhs) <= 0;
  }
  template <typename C, typename T, typename PC>
  inline
  bool operator <=(nullptr_t lhs, const gc_basic_string<C,T,PC> &rhs) noexcept
  {
    return true;
  }
  template <typename C, typename T, typename PC>
  inline
  bool operator <=(const gc_basic_string<C,T,PC> &lhs, nullptr_t rhs) noexcept
  {
    return lhs.empty();
  }
  template <typename C, typename T, typename PC>
  inline
  bool operator <=(const gc_basic_string<C,T,PC> &lhs, const C *rhs)
  {
    return lhs.compare(rhs) <= 0;
  }
  template <typename C, typename T, typename PC>
  inline
  bool operator <=(const C *lhs, const gc_basic_string<C,T,PC> &rhs)
  {
    return rhs.compare(rhs) > 0;
  }
  template <typename C, typename T, typename PC, typename A>
  inline
  bool operator <=(const gc_basic_string<C,T,PC> &lhs,
                   const std::basic_string<C,T,A> &rhs) noexcept
  {
    return lhs.compare(rhs) <= 0;
  }
  template <typename C, typename T, typename PC, typename A>
  inline
  bool operator <=(const std::basic_string<C,T,A> &lhs,
                  const gc_basic_string<C,T,PC> &rhs) noexcept
  {
    return rhs.compare(rhs) > 0;
  }

  template <typename C, typename T, typename PC, typename PC2>
  inline
  bool operator >(const gc_basic_string<C,T,PC> &lhs,
                  const gc_basic_string<C,T,PC2> &rhs) noexcept
  {
    return lhs.compare(rhs) > 0;
  }
  template <typename C, typename T, typename PC>
  inline
  bool operator >(nullptr_t lhs, const gc_basic_string<C,T,PC> &rhs) noexcept
  {
    return false;
  }
  template <typename C, typename T, typename PC>
  inline
  bool operator >(const gc_basic_string<C,T,PC> &lhs, nullptr_t rhs) noexcept
  {
    return !lhs.empty();
  }
  template <typename C, typename T, typename PC>
  inline
  bool operator >(const gc_basic_string<C,T,PC> &lhs, const C *rhs)
  {
    return lhs.compare(rhs) > 0;
  }
  template <typename C, typename T, typename PC>
  inline
  bool operator >(const C *lhs, const gc_basic_string<C,T,PC> &rhs)
  {
    return rhs.compare(rhs) <= 0;
  }
  template <typename C, typename T, typename PC, typename A>
  inline
  bool operator >(const gc_basic_string<C,T,PC> &lhs,
                  const std::basic_string<C,T,A> &rhs) noexcept
  {
    return lhs.compare(rhs) > 0;
  }
  template <typename C, typename T, typename PC, typename A>
  inline
  bool operator >(const std::basic_string<C,T,A> &lhs,
                  const gc_basic_string<C,T,PC> &rhs) noexcept
  {
    return rhs.compare(rhs) <= 0;
  }
  
  template <typename C, typename T, typename PC, typename PC2>
  inline
  bool operator >=(const gc_basic_string<C,T,PC> &lhs,
                   const gc_basic_string<C,T,PC2> &rhs) noexcept
  {
    return lhs.compare(rhs) <= 0;
  }
  template <typename C, typename T, typename PC>
  inline
  bool operator >=(nullptr_t lhs, const gc_basic_string<C,T,PC> &rhs) noexcept
  {
    return rhs.empty();
  }
  template <typename C, typename T, typename PC>
  inline
  bool operator >=(const gc_basic_string<C,T,PC> &lhs, nullptr_t rhs) noexcept
  {
    return true;
  }
  template <typename C, typename T, typename PC>
  inline
  bool operator >=(const gc_basic_string<C,T,PC> &lhs, const C *rhs)
  {
    return lhs.compare(rhs) >= 0;
  }
  template <typename C, typename T, typename PC>
  inline
  bool operator >=(const C *lhs, const gc_basic_string<C,T,PC> &rhs)
  {
    return rhs.compare(rhs) < 0;
  }
  template <typename C, typename T, typename PC, typename A>
  inline
  bool operator >=(const gc_basic_string<C,T,PC> &lhs,
                   const std::basic_string<C,T,A> &rhs) noexcept
  {
    return lhs.compare(rhs) >= 0;
  }
  template <typename C, typename T, typename PC, typename A>
  inline
  bool operator >=(const std::basic_string<C,T,A> &lhs,
                  const gc_basic_string<C,T,PC> &rhs) noexcept
  {
    return rhs.compare(rhs) < 0;
  }

    

}

namespace std {
  template <typename C, typename T, typename PC>
  inline
  void swap(mpgc::gc_basic_string<C,T,PC> &lhs,
            mpgc::gc_basic_string<C,T,PC> &rhs)
  {
    lhs.swap(rhs);
  }

  template <typename C, typename T, typename PC>
  basic_istream<C,T> &getline(basic_istream<C,T> &is,
                              mpgc::gc_basic_string<C,T,PC> &s,
                              C delim)
  {
    istream::sentry stry(is);
    if (stry) {
      s.erase();
      bool read = false;
      for (C c = is.get(); c != T::eof(); c = is.get()) {
        read = true;
        if (T::eq(c,delim)) {
          break;
        }
        s.push_back(c);
      }
      if (!read) {
        is.setstate(is.failbit);
      }
    }
    return is;
  }

  template <typename C, typename T, typename PC>
  inline
  basic_istream<C,T> &getline(basic_istream<C,T> &is,
                              mpgc::gc_basic_string<C,T,PC> &s)
  {
    return getline(is, s, is.widen('\n'));
  }  

  template <typename C, typename T, typename PC>
  inline
  basic_istream<C,T> &getline(basic_istream<C,T> &&is,
                              mpgc::gc_basic_string<C,T,PC> &s,
                              C delim)
  {
    return getline(is, s, delim);
  }

  template <typename C, typename T, typename PC>
  inline
  basic_istream<C,T> &getline(basic_istream<C,T> &&is,
                              mpgc::gc_basic_string<C,T,PC> &s)
  {
    return getline(is, s);
  }

  template <typename T, typename PC>
  int stoi(const mpgc::gc_basic_string<char,T,PC> &str,
           std::size_t *pos = nullptr,
           int base = 10)
  {
    return str.to_number(std::strtol, pos, base);
  }
    
  template <typename T, typename PC>
  int stoi(const mpgc::gc_basic_string<wchar_t,T,PC> &str,
           std::size_t *pos = nullptr,
           int base = 10)
  {
    return str.to_number(std::wcstol, pos, base);
  }
    
  template <typename T, typename PC>
  long stol(const mpgc::gc_basic_string<char,T,PC> &str,
           std::size_t *pos = nullptr,
           int base = 10)
  {
    return str.to_number(std::strtol, pos, base);
  }
    
  template <typename T, typename PC>
  long stol(const mpgc::gc_basic_string<wchar_t,T,PC> &str,
           std::size_t *pos = nullptr,
           int base = 10)
  {
    return str.to_number(std::wcstol, pos, base);
  }
    
  template <typename T, typename PC>
  long long stoll(const mpgc::gc_basic_string<char,T,PC> &str,
                  std::size_t *pos = nullptr,
                  int base = 10)
  {
    return str.to_number(std::strtoll, pos, base);
  }
    
  template <typename T, typename PC>
  long long stoll(const mpgc::gc_basic_string<wchar_t,T,PC> &str,
                  std::size_t *pos = nullptr,
                  int base = 10)
  {
    return str.to_number(std::wcstoll, pos, base);
  }
    
    
  template <typename T, typename PC>
  long stoul(const mpgc::gc_basic_string<char,T,PC> &str,
             std::size_t *pos = nullptr,
             int base = 10)
  {
    return str.to_number(std::strtoul, pos, base);
  }
    
  template <typename T, typename PC>
  long stoul(const mpgc::gc_basic_string<wchar_t,T,PC> &str,
             std::size_t *pos = nullptr,
             int base = 10)
  {
    return str.to_number(std::wcstoul, pos, base);
  }
    
  template <typename T, typename PC>
  long long stoull(const mpgc::gc_basic_string<char,T,PC> &str,
                   std::size_t *pos = nullptr,
                   int base = 10)
  {
    return str.to_number(std::strtoull, pos, base);
  }
    
  template <typename T, typename PC>
  long long stoull(const mpgc::gc_basic_string<wchar_t,T,PC> &str,
                   std::size_t *pos = nullptr,
                   int base = 10)
  {
    return str.to_number(std::wcstoull, pos, base);
  }
    
  template <typename T, typename PC>
  float stof(const mpgc::gc_basic_string<char,T,PC> &str,
             std::size_t *pos = nullptr,
             int base = 10)
  {
    return str.to_number(std::strtod, pos, base);
  }
    
  template <typename T, typename PC>
  float stof(const mpgc::gc_basic_string<wchar_t,T,PC> &str,
             std::size_t *pos = nullptr,
             int base = 10)
  {
    return str.to_number(std::wcstod, pos, base);
  }
    
  template <typename T, typename PC>
  double stod(const mpgc::gc_basic_string<char,T,PC> &str,
              std::size_t *pos = nullptr,
              int base = 10)
  {
    return str.to_number(std::strtod, pos, base);
  }
    
  template <typename T, typename PC>
  double stod(const mpgc::gc_basic_string<wchar_t,T,PC> &str,
              std::size_t *pos = nullptr,
              int base = 10)
  {
    return str.to_number(std::wcstod, pos, base);
  }
    
  template <typename T, typename PC>
  long double stold(const mpgc::gc_basic_string<char,T,PC> &str,
                    std::size_t *pos = nullptr,
                    int base = 10)
  {
    return str.to_number(std::strtold, pos, base);
  }
    
  template <typename T, typename PC>
  long double stold(const mpgc::gc_basic_string<wchar_t,T,PC> &str,
                    std::size_t *pos = nullptr,
                    int base = 10)
  {
    return str.to_number(std::wcstold, pos, base);
  }
    
}


#endif

