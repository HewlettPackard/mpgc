/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#ifndef OFFSET_PTR_H
#define OFFSET_PTR_H

#include <cassert>
#include <iterator>
#include <type_traits>
#include <utility>
#include <cstdint>
#include <cstddef>
#include <ostream>
#include "ruts/versioned_ptr.h"
#include "ruts/hashes.h"
#include "ruts/util.h"

namespace mpgc {
  namespace gc_handshake {
    template <typename Fn, typename ...Args> void process_stack(const std::size_t*, const std::size_t*, Fn&&, Args&& ...);
  }

  template <typename T> class offset_ptr;

  class base_offset_ptr {
  private:
    /* We will support maximum 48-bit heaps as
     * the machine is going to have 48-bit address
     * spaces in the beginning.
     */
    constexpr static uint8_t _offset_bits = 52;
    constexpr static uint8_t _signature_bits = 4;
    constexpr static uint8_t _signature = 0xA;
    constexpr static uint8_t _signature_mask = 0xF;
    
    static uint8_t* _real_base;
    static uint8_t* _signed_base;
    static uint8_t* _heap_end;
    static std::size_t _heap_size;
    
    constexpr static uint8_t* const &_base = _real_base;
    constexpr static uint8_t* const &_internal_base = _signed_base;
    constexpr static uint8_t* const &_end = _heap_end;
    constexpr static std::size_t const &_heap_size_in_bytes = _heap_size;

    std::size_t _offset;

    /*
     * To allow access to val() and ctor for checking
     */
    friend class gc_descriptor;
    friend class mark_bitmap;


    constexpr static std::size_t offset_mask() {
      return (static_cast<std::size_t>(1) << _offset_bits) - 1;
    }

    constexpr static std::size_t used_mask() {
      return (std::size_t(1) << used_bits()) - 1;
    }
    constexpr static std::size_t signature() {
      return static_cast<std::size_t>(_signature) << _offset_bits;
    }

    template <typename T>
    constexpr static std::size_t compute_val(T *p) {
      return !p ? 0 : (reinterpret_cast<const uint8_t*>(p) - _internal_base);
    }

    constexpr bool static is_null(std::size_t offset) {
      return used_val(offset) == 0;
    }

    constexpr static std::size_t used_val(std::size_t offset) {
      return offset & used_mask();
    }
    constexpr static bool is_inside_heap(std::size_t offset) {
      return _internal_base + used_val(offset) < end();
    }

    //returns the offset which can directly be added to base() to get a real pointer
    constexpr std::size_t offset() const {
      return _offset & offset_mask();
    }

  protected:
    constexpr static bool is_valid(uint8_t *p)  {
      return p >= _base && p < _heap_end;
    }

    constexpr static bool is_signature_valid(std::size_t offset) {
      return ((offset >> _offset_bits) & _signature_mask) == _signature;
    }
    constexpr bool is_signature_valid() const {
      return is_signature_valid(_offset); 
    }

    constexpr bool is_inside_heap() const {
      return is_inside_heap(_offset);
    }

    constexpr static bool is_ok(std::size_t offset) {
      return is_null(offset) || (is_signature_valid(offset) && is_inside_heap(offset));
    }
    constexpr bool is_ok() const {
      return is_ok(_offset);
    }

    template <typename T>
    T* as_bare_pointer() const noexcept {
      assert(is_null() || is_signature_valid());
      return is_null() ? nullptr : reinterpret_cast<T*>(_internal_base + used_val());
    }

    template <typename T>
    constexpr bool is_equal(const T *rhs) const {
      return rhs == nullptr ? is_null() : reinterpret_cast<const uint8_t*>(rhs) - _internal_base == static_cast<ptrdiff_t>(used_val());
    }

    //returns the bare value which includes signature and other msb bits.
    constexpr std::size_t val() const { return _offset;}

    constexpr std::size_t used_val() const {
      return used_val(_offset);
    }

    //The incoming value is already set with signature. Just need to assign.
    void set_val(std::size_t o) {
      _offset = o;
    }

    template <typename T>
    void set_val(T *p) {
      set_val(compute_val(p));
    }

    struct assert_failure
    {
      template <typename Fn>
      assert_failure(Fn fn) {
	fn();
      }
    };

    constexpr static std::size_t checked_offset(std::size_t o) {
      return is_ok(o) ? o : throw assert_failure([=]{assert(is_ok(o));});
    }

    constexpr base_offset_ptr(std::size_t o = 0) noexcept : _offset(o) {}
    
    template <typename T>
    constexpr base_offset_ptr(T *p) noexcept : base_offset_ptr(compute_val(p)) {}
    base_offset_ptr(const base_offset_ptr&rhs) = default;
    base_offset_ptr(base_offset_ptr&&rhs) = default;
    
    base_offset_ptr &operator =(const base_offset_ptr &rhs) = default;
    base_offset_ptr &operator =(base_offset_ptr &&rhs) = default;
  public:
    constexpr static uint8_t* base() { return _base; }
    constexpr static uint8_t* end()  { return _end;  }

    constexpr static std::size_t used_bits() {
      return _offset_bits + _signature_bits;
    }

    constexpr static std::size_t heap_size() {
      return _heap_size_in_bytes;
    }

    static void initialize(uint8_t *p, std::size_t size) {
      _heap_size = size;
      _real_base = p;
      _heap_end = p + size;
      _signed_base = p - signature();
    }

  public:
    template <typename T>
    constexpr static bool is_valid(const T *p)  {
      return is_valid(reinterpret_cast<uint8_t*>(const_cast<T*>(p)));
    }
    
    constexpr bool is_valid() const {
      return val() && is_signature_valid() && is_inside_heap();
    }

    constexpr static bool could_be_offset_ptr(std::size_t offset) {
      return is_signature_valid(offset) && is_inside_heap(offset);
    }

    constexpr bool is_null() const {
      return is_null(_offset);
    }

    constexpr std::size_t as_number() const {
      return used_val();
    }

  };

  template <typename T>
  class offset_ptr : public base_offset_ptr {
    template <typename U> friend class offset_ptr;
    friend class std::versioned_pointer_traits<offset_ptr<T>>;  
    friend class gc_descriptor;
    template <typename Fn, typename ...Args> friend void gc_handshake::process_stack(const std::size_t*, const std::size_t*, Fn&&, Args&& ...);
    friend class gc_allocator;

    constexpr explicit offset_ptr(std::size_t o) : base_offset_ptr(o) {}
    
  public:

    using difference_type = std::ptrdiff_t;
    using value_type = T;
    using pointer = value_type *;
    using reference = value_type &;
    using iterator_category = std::random_access_iterator_tag;

    constexpr offset_ptr() noexcept : base_offset_ptr() {}
    constexpr offset_ptr(std::nullptr_t) noexcept : offset_ptr() {}
    offset_ptr(T *p) noexcept : base_offset_ptr(p) {}

    offset_ptr(const offset_ptr &) = default;
    offset_ptr(offset_ptr &&rhs) = default;

    offset_ptr &operator =(const offset_ptr &rhs) = default;
    offset_ptr &operator =(offset_ptr &&rhs) = default;

    template <typename U, typename = std::enable_if_t<std::is_base_of<U, T>::value &&
                                                      (std::is_const<U>::value ||
                                                       (!std::is_const<U>::value &&
                                                       !std::is_const<T>::value))>>
    operator const offset_ptr<U>&() const {
      return *reinterpret_cast<const offset_ptr<U>*>(this);
    }

    template <typename U, typename = std::enable_if_t<std::is_assignable<T*&,U*>::value> >
    offset_ptr(const offset_ptr<U> &rhs) noexcept : base_offset_ptr{rhs.val()} {}

    template <typename U, typename = std::enable_if_t<std::is_assignable<T*&,U*>::value> >
    offset_ptr(offset_ptr<U> &&rhs) noexcept : base_offset_ptr{std::move(rhs.val())} {}

    template <typename U, typename = std::enable_if_t<std::is_assignable<T*&,U*>::value> >
    offset_ptr &operator =(const offset_ptr<U> &rhs) noexcept {
      set_val(rhs.val());
      return *this;
    }

    template <typename U, typename = std::enable_if_t<std::is_assignable<T*&,U*>::value> >
    offset_ptr &operator =(offset_ptr<U> &&rhs) noexcept {
      set_val(std::move(rhs.val()));
      return *this;
     }

    offset_ptr &operator =(T *p) noexcept {
      set_val(p);
      return *this;
    }
    
    offset_ptr &operator =(std::nullptr_t) noexcept {
      set_val(0);
      return *this;
    }

    T* as_bare_pointer() const noexcept {
      return base_offset_ptr::as_bare_pointer<T>();
    }

    T &operator *() const {
      return *as_bare_pointer();
    }

    T *operator ->() const noexcept {
      return as_bare_pointer();
    }

    void swap (offset_ptr &other) noexcept {
      std::size_t temp = val();
      set_val(other.val());
      other.set_val(temp);
    }

    constexpr operator bool() const noexcept {
      return val() != 0;
    }

    template <typename U>
    constexpr bool is_equal(const offset_ptr<U> &rhs) const {
      return val() == rhs.val();
    }
    template <typename U>
    constexpr bool is_equal(const U *rhs) const {
      return !rhs ? !*this: base_offset_ptr::is_equal(rhs);
    }

    template <typename U>
    explicit operator U*() const {
      return reinterpret_cast<U*>(as_bare_pointer());
    }

    offset_ptr &operator +=(difference_type delta) {
      set_val(val() + sizeof(T) * delta);
      return *this;
    }
    offset_ptr &operator -=(difference_type delta) {
      set_val(val() - sizeof(T) * delta);
      return *this;
    }
    offset_ptr &operator ++() {
      return (*this) += 1;
    }
    offset_ptr &operator --() {
      return (*this) -= 1;
    }
    offset_ptr operator ++(int) {
      offset_ptr pre = *this;
      (*this)++;
      return pre;
    }
    offset_ptr operator --(int) {
      offset_ptr pre = *this;
      (*this)--;
      return pre;
    }

    offset_ptr operator +(difference_type delta) const {
      return offset_ptr(val() + delta * sizeof(T));
    }
    offset_ptr operator -(difference_type delta) const {
      return offset_ptr(val() - delta * sizeof(T));
    }

    difference_type operator -(const offset_ptr &rhs) const {
      return (used_val() - rhs.used_val())/sizeof(T);
    }

    template <typename U>
    bool operator >(const offset_ptr<U> &other) const {
      return as_bare_pointer() > other.as_bare_pointer();
    }

    template <typename U>
    bool operator <(const offset_ptr<U> &other) const {
      return as_bare_pointer() < other.as_bare_pointer();
    }

    template <typename U>
    bool operator >=(const offset_ptr<U> &other) const {
      return as_bare_pointer() >= other.as_bare_pointer();
    }

    template <typename U>
    bool operator <=(const offset_ptr<U> &other) const {
      return as_bare_pointer() <= other.as_bare_pointer();
    }
    
    constexpr std::uint64_t hash1() const {
      return ruts::hash1<T*>()(as_bare_pointer());
    }
    constexpr std::uint64_t hash2() const {
      return ruts::hash2<T*>()(as_bare_pointer());
    }
  };

  template <typename T, typename U>
  inline
  bool operator ==(const offset_ptr<T> &lhs, const offset_ptr<U> &rhs) {
    return lhs.is_equal(rhs);
  }
  template <typename T, typename U>
  inline
  bool operator ==(const offset_ptr<T> &lhs, const U *rhs) {
   return lhs.is_equal(rhs);
  }
  template <typename T, typename U>
  inline
  bool operator ==(const T *lhs, const offset_ptr<U> &rhs) {
    return rhs == lhs;
  }
  template <typename T, typename U>
  inline
  bool operator !=(const offset_ptr<T> &lhs, const offset_ptr<U> &rhs) {
    return !(lhs == rhs);
  }
  template <typename T, typename U>
  inline
  bool operator !=(const T *lhs, const offset_ptr<U> &rhs) {
    return !(lhs == rhs);
  }
  template <typename T, typename U>
  inline
  bool operator !=(const offset_ptr<T> &lhs, const U *rhs) {
    return !(lhs == rhs);
  }
  template <typename T>
  inline
  bool operator ==(const offset_ptr<T> &lhs, std::nullptr_t) {
    return !lhs;
  }
  template <typename T>
  inline
  bool operator ==(std::nullptr_t, const offset_ptr<T> &rhs) {
    return !rhs;
  }
  template <typename T>
  inline
  bool operator !=(const offset_ptr<T> &lhs, std::nullptr_t) {
    return lhs;
  }
  template <typename T>
  inline
  bool operator !=(std::nullptr_t, const offset_ptr<T> &rhs) {
    return rhs;
  }

}

namespace ruts {

  template <typename T>
  struct hash1<mpgc::offset_ptr<T>> {
    auto operator()(const mpgc::offset_ptr<T> &ptr) const {
      return ptr.hash1();
    }
  };
  template <typename T>
  struct hash2<mpgc::offset_ptr<T>> {
    auto operator()(const mpgc::offset_ptr<T> &ptr) const {
      return ptr.hash2();
    }
  };

}

namespace std {
  template <typename C, typename T, typename X>
  basic_ostream<C,T> &
  operator <<(basic_ostream<C,T> &os, const mpgc::offset_ptr<X> &ptr) {
    ruts::reset_flags_on_exit reset(os);
    return os << hex << ptr.as_number()
      //              << " (" << ptr.as_bare_pointer() << ")"
      ;
  }

  template <typename T>
  inline
  void swap(mpgc::offset_ptr<T> &lhs, mpgc::offset_ptr<T> &rhs) {
    lhs.swap(rhs);
  }

  template <typename T, typename U>
  mpgc::offset_ptr<T>
  static_pointer_cast(const mpgc::offset_ptr<U> &r) {
    return mpgc::offset_ptr<T>(static_cast<T*>(r.as_bare_pointer()));
  }

  template <typename T, typename U>
  inline
  mpgc::offset_ptr<T>
  dynamic_pointer_cast(const mpgc::offset_ptr<U> &r) {
    return mpgc::offset_ptr<T>(dynamic_cast<T*>(r.as_bare_pointer()));
  }

  template <typename T, typename U>
  inline
  mpgc::offset_ptr<T>
  const_pointer_cast(const mpgc::offset_ptr<U> &r) {
    return mpgc::offset_ptr<T>(const_cast<T*>(r.as_bare_pointer()));
  }
  template <typename T>
  struct hash<mpgc::offset_ptr<T>> : ruts::delegate_hash<mpgc::offset_ptr<T>> {};

  template <typename T>
  struct versioned_pointer_traits<mpgc::offset_ptr<T>>
    : pointer_traits<mpgc::offset_ptr<T>>
  {
    using prim_rep = size_t;
    constexpr static mpgc::offset_ptr<T> from_prim_rep(prim_rep p) { return mpgc::offset_ptr<T>(p);}
    constexpr static prim_rep to_prim_rep(mpgc::offset_ptr<T> p) { return p.val();}
    template <typename M, typename OV, typename NV>
    static void modify(M&& mod, OV&& old_val, NV&&new_val) {
      std::forward<M>(mod)();
    }
  };



}

#endif
