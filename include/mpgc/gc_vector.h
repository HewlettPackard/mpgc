/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * gc_basic_vector.h
 *
 *  Created on: Apr 29, 2015
 *      Author: Evan
 */

#ifndef GC_BASIC_VECTOR_H_
#define GC_BASIC_VECTOR_H_

#include "mpgc/gc.h"
#include <algorithm>
#include <type_traits>
#include <iterator>
#include <limits>

/*
 * A gc_basic_vector<T> is not itself allocated (see gc_allocated_vector<T>), but it can sit inside
 * something that is.
 */

namespace mpgc {
  template <typename T, typename PC>
  class gc_basic_vector {
    template <typename X,typename P> friend class gc_basic_vector;
    using rep_type = gc_array<T>;
    using rep_ptr_type = typename PC::template ptr_t<rep_type>;
  public:
    using value_type = typename rep_type::value_type;
    using size_type = typename rep_type::size_type;
    using difference_type = typename rep_type::difference_type;
    using reference = typename rep_type::reference;
    using const_reference = typename rep_type::const_reference;
    using iterator = typename rep_type::iterator;
    using const_iterator = typename rep_type::const_iterator;
    using reverse_iterator = typename rep_type::reverse_iterator;
    using const_reverse_iterator = typename rep_type::const_reverse_iterator;
  private:
    constexpr static double growth_factor = 1.5;
    constexpr static size_type min_grow_to = 8;
    rep_ptr_type _rep = nullptr;
    size_type _size = 0;



    void ensure_capacity(size_type count) {
      size_type c = capacity();
      if (count < c) {
        return;
      }
      /*
       * If we have no rep, it's the first insertion.  It might
       * be the last, so we use the exact size.
       * Otherwise, we grow by growth_factor, but
       * to at least min_grow_to;
       */
      if (c == 0) {
        c = count;
      } else {
        if (c < min_grow_to) {
          c = min_grow_to;
        }
        while (c < count) {
          /*
           * There must be a faster way.
           * TODO
           * Basically, exponent is ceil(log(desired/current)/log(gf))).
           * Maybe check d/c < gf, and then dispatch. Perhaps with a
           * check against a constexpr bound.
           * This should probably all be delegated to a non-inline
           * (and non-template) function.
           */
          c *= growth_factor;
        }
      }
      /*
       * We originally had this in the opposite order (save old_rep,
       * assign a new array to _rep, then move, but when optimized,
       * the handle on old_rep disappeared during the move (since it
       * was no longer needed).
       *
       * ERK: I switched around old_rep and new_rep again when I added
       * the single ctor that does the grow and copy (and this changes
       * from an after-the-fact move to an uninitialized copy, which
       * should be more efficient). The iterators involved are
       * gc_array iterators, so they should hold onto the old rep
       * throughout the allocation.
       */
      auto old_begin = _rep.begin();
      auto new_rep = make_gc<rep_type>(c, old_begin, old_begin+_size);
      // TODO: This should probably be atomic.
      _rep = new_rep;
    }
    [[noreturn]] void throw_out_of_range(size_type pos, size_type n = size()) const;

    void check_pos(size_type pos, size_type n) const {
      if (pos < 0 || pos > n) {
        throw_out_of_range(pos, n);
      }
    }

    void check_pos(size_type pos) const {
      check_pos(pos, _size);
    }

  public:
    static const auto &descriptor() {
      static gc_descriptor d =
	GC_DESC(gc_basic_vector)
	.template WITH_FIELD(&gc_basic_vector::_rep)
	.template WITH_FIELD(&gc_basic_vector::_size);
      return d;
    }

    void assign(size_type count, const value_type &value) {
      ensure_capacity(count);
      if (_rep != nullptr) {
        if (count > 0) {
          std::fill(_rep->begin(), _rep->begin()+count, value);
        }
        std::fill(_rep->begin()+count, _rep->end(), value_type{});
      }
      _size = count;
    }

    void assign(std::initializer_list<value_type> init) {
      assign(init.begin(), init.end());
    }
    /*
     * If Iter is arithmetic, we assume that this is actually
     * a count/value construction.
     */
    template <typename Iter, typename = std::enable_if_t<!std::is_arithmetic<Iter>::value> >
    void assign(Iter first, Iter last)
    {
      size_type count = std::distance(first, last);
      ensure_capacity(count);
      if (_rep != nullptr) {
        if (count > 0) {
          std::copy(first, last, _rep->begin());
        }
        std::fill(_rep->begin()+count, _rep->end(), value_type{});
      }
      _size = count;
    }

    gc_basic_vector() : _rep{nullptr}, _size{0} {}
    explicit gc_basic_vector(size_type count)
    {
      assign(count, value_type{});
    }
    gc_basic_vector(size_type count, const value_type &value)
    {
      assign(count, value);
    }
    /*
     * If Iter is arithmetic, we assume that this is actually
     * a count/value construction.
     */
    template <typename Iter, typename = std::enable_if_t<!std::is_arithmetic<Iter>::value> >
    gc_basic_vector(Iter first, Iter last)
    {
      assign(first, last);
    }
    
    template <typename T2, typename PC2,
              typename=std::enable_if_t<std::is_assignable<T*&,T2*>::value> >
    gc_basic_vector(const gc_basic_vector<T2,PC2> &other)
      : gc_basic_vector{other.begin(), other.end()} {}
    template <typename PC2>
    gc_basic_vector(gc_basic_vector<T,PC2> &&other)
      : _rep{std::move(other._rep)}, _size{other._size} {
      other._size = 0;
      other._rep = nullptr;
    }

    gc_basic_vector(std::initializer_list<value_type> init) : gc_basic_vector{init.begin(), init.end()} {}


    template <typename T2, typename PC2,
              typename=std::enable_if_t<std::is_assignable<T*&,T2*>::value> >
    gc_basic_vector &operator =(const gc_basic_vector<T2,PC2> &other) {
      assign(other.begin(), other.end());
      return *this;
    }
    gc_basic_vector &operator =(std::initializer_list<value_type> init) {
      assign(init);
      return *this;
    }

    template <typename PC2>
    gc_basic_vector &operator =(gc_basic_vector<T,PC2> &&other) {
      _rep = std::move(other._rep);
      _size = other._size;
      other._size = 0;
      other._rep = nullptr;
      return *this;
    }
    reference at(size_type pos) {
      check_pos(pos);
      return (*this)[pos];
    }

    const_reference at(size_type pos) const {
      check_pos(pos);
      return (*this)[pos];
    }

    reference operator[](size_type pos) {
      return _rep[pos];
    }
    const_reference operator[](size_type pos) const {
      return _rep[pos];
    }

    reference front() {
      return (*this)[0];
    }
    const_reference front() const {
      return (*this)[0];
    }

    reference back() {
      return (*this)[_size-1];
    }
    const_reference back() const {
      return (*this)[_size-1];
    }

    // Not implementing data();

    iterator begin() {
      return _rep == nullptr ? iterator{} : _rep->begin();
    }
    const_iterator cbegin() const {
      return _rep == nullptr ? const_iterator{} : _rep->cbegin();
    }
    const_iterator begin() const {
      return cbegin();
    }
    iterator end() {
      return begin()+_size;
    }
    const_iterator cend() const {
      return begin()+_size;
    }
    const_iterator end() const {
      return cend();
    }

    reverse_iterator rbegin() {
      return reverse_iterator(end());
    }
    const_reverse_iterator crbegin() const {
      return reverse_iterator(cend());
    }
    const_reverse_iterator rbegin() const {
      return crbegin();
    }
    reverse_iterator rend() {
      return reverse_iterator(begin());
    }
    const_reverse_iterator crend() const {
      return reverse_iterator(cbegin());
    }
    const_reverse_iterator rend() const {
      return crend();
    }

    bool empty() const noexcept {
      return _size==0;
    }

    size_type size() const noexcept {
      return _size;
    }

    size_type max_size() const noexcept {
      return std::numeric_limits<size_type>::max();
    }

    void reserve(size_type new_cap) {
      ensure_capacity(new_cap);
    }

    size_type capacity() const noexcept {
      return _rep.size();
    }

    void shrink_to_fit() {
      if (_size < capacity()) {
        _rep = make_gc_array(begin(), end());
      }
    }

    void clear() {
      if (_size > 0) {
        size_type old_size = _size;
        _size = 0;
        std::fill_n(begin(), old_size, value_type{});
      }
    }

  private:
    iterator move_right(size_type pos, size_type count) {
      size_type old_size = _size;
      resize(_size+count);
      /*
       * We have to us move_backward, because the beginning of the
       * destination range is in the middle of the part being moved
       */
      iterator start = begin()+pos;
      std::move_backward(start, begin()+old_size, end());
      return start;
    }

    iterator move_right(const_iterator from, size_type count) {
      return move_right(from-cbegin(), count);
    }
  public:

    iterator insert(const_iterator pos, size_type count, const value_type &value) {
      size_type i = pos-cbegin();
      if (count == 0) {
        return begin()+i;;
      }
      iterator from = move_right(i, count);
      if (count == 1) {
        *from = value;
      } else {
        std::fill(from, from+count, value);
      }
      return from;
    }
    iterator insert(const_iterator pos, const value_type &value) {
      iterator from = move_right(pos, 1);
      *from = value;
      return from;
    }
    iterator insert(const_iterator pos, value_type &&value) {
      iterator from = move_right(pos, 1);
      *from = std::move(value);
      return from;
    }

    template <typename Iter, typename = std::enable_if_t<!std::is_arithmetic<Iter>::value> >
    iterator insert(const_iterator pos, Iter first, Iter last) {
      size_type count = std::distance(first, last);
      size_type i = pos-cbegin();
      iterator from = begin()+i;
      if (count > 0) {
        from = move_right(from, count);
        std::copy(first, last, from);
      }
      return from;
    }

    iterator insert(const_iterator pos, std::initializer_list<value_type> ilist) {
      return insert(pos, ilist.begin(), ilist.end());
    }

  private:
    template <typename S=rep_type, typename... Args>
    void emplace_aux(std::enable_if_t<S::holds_direct_values, value_type&> ref, Args &&...args) {
      /*
       * Since we don't have uninitialized storage, there was necessarily an object there.
       * We need to get rid of it.
       *
       * TODO: What if the GC walks the slot as it's being destructed?
       */
      ref.~value_type();
      new (&ref) value_type(std::forward<Args>(args)...);
    }
    template <typename S=rep_type, typename... Args>
    void emplace_aux(std::enable_if_t<!S::holds_direct_values, value_type&> ref, Args &&...args) {
      ref = make_gc<T>(std::forward<Args>(args)...);
    }
  public:
    template <typename... Args>
    iterator emplace(const_iterator pos, Args&&...args) {
      iterator from = move_right(pos, 1);
      emplace_aux(*from, std::forward<Args>(args)...);
      return from;
    }

    iterator erase(const_iterator pos) {
      size_type i = pos-cbegin();
      iterator from = begin()+i;
      auto res = std::move(from+1, end(), from);
      resize(_size-1);
      return res;
    }

    iterator erase(const_iterator first, const_iterator last) {
      iterator i_from = begin()+(first-cbegin());
      auto n = last-first;
      iterator i_last = i_from+n;
      auto res = std::move(i_last, end(), i_from);
      resize(_size-n);
      return res;
    }
    
    void push_back(const value_type &value) {
      resize(_size+1);
      back() = value;
    }
    void push_back(value_type &&value) {
      resize(_size+1);
      back() = std::move(value);
    }
    template <typename... Args>
    iterator emplace_back(Args&&...args) {
      resize(_size+1);
      back() = value_type{};
      new (&back()) value_type(std::forward<Args>(args)...);
      return begin()+(_size-1);
    }

    void pop_back() {
      if (_size > 0) {
        back() = value_type{};
        _size--;
      }
    }

    void resize(size_type count) {
      if (_size == count) {
        return;
      } else if (count > _size) {
        ensure_capacity(count);
        // elements > _size are always default.
      } else if (count == _size-1) {
        *(begin()+count) = value_type{};
      } else {
        std::fill(begin()+count, end(), value_type{});
      }
      _size = count;
    }

    void resize(size_type count, const value_type &value) {
      if (_size == count) {
        return;
      } else if (count > size) {
        ensure_capacity(count);
        std::fill(end(), begin()+count, value);
      } else {
        std::fill(begin()+count, end(), value_type{});
      }
      _size = count;
    }

    void swap(gc_basic_vector &other) {
      std::swap(_size, other._size);
      std::swap(_rep, other._rep);
    }
  };

  template <typename T, typename PC>
  void gc_basic_vector<T, PC>::throw_out_of_range(size_type pos, size_type n) const {
    std::ostringstream ss;
    ss << "Pos: " << pos << "; len: " << n;
    throw std::out_of_range{ss.str()};
  }

  template <typename T> using gc_vector = gc_basic_vector<T,internal_pointers>;
  template <typename T> using external_gc_vector = gc_basic_vector<T,external_pointers>;

  template <typename T>
  struct is_collectible<gc_vector<T>> : is_collectible<T>
  {};

}

namespace std {
  template <typename T, typename PC>
  void swap(mpgc::gc_basic_vector<T,PC> &lhs, mpgc::gc_basic_vector<T,PC> &rhs) {
    lhs.swap(rhs);
  }
}



#endif /* GC_VECTOR_H_ */
