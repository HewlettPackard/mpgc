/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * gc_basic_vector.h
 *
 *  Created on: Apr 29, 2015
 *      Author: Evan
 */

#ifndef GC_STACK_H_
#define GC_STACK_H_

#include "ruts/cas_loop.h"
#include "mpgc/gc.h"
#include "mpgc/gc_versioned.h"
#include <atomic>

namespace mpgc {

  template <typename T>
  class gc_threaded_node : public gc_allocated
  {
  public:
    using value_type = T;

    value_type value;
    gc_ptr<gc_threaded_node> next;

  private:
    struct emplace_t {};
    template <typename...Args>
    gc_threaded_node(gc_token &gc, const gc_ptr<gc_threaded_node> &n,
                     emplace_t, Args&&...args)
      : gc_allocated{gc}, value{std::forward<Args>(args)...},
        next{n}
    {}


  public:
    gc_threaded_node(gc_token &gc, const value_type &v,
                     const gc_ptr<gc_threaded_node> &n = nullptr)
      : gc_allocated{gc}, value{v}, next{n}
    {}

    gc_threaded_node(gc_token &gc, value_type &&v,
                     const gc_ptr<gc_threaded_node> &n = nullptr)
      : gc_allocated{gc}, value{std::move(v)}, next{n}
    {}

    static const auto &descriptor() {
      static gc_descriptor d =
        GC_DESC(gc_threaded_node)
        .template WITH_FIELD(&gc_threaded_node::value)
        .template WITH_FIELD(&gc_threaded_node::next);
      return d;
    }

    template <typename...Args>
    static gc_ptr<gc_threaded_node> emplaced_before(const gc_ptr<gc_threaded_node> &n,
                                                    Args&&...args)
    {
      return make_gc<gc_threaded_node>(n, emplace_t{}, std::forward<Args>(args)...);
    }

    template <typename...Args>
    static gc_ptr<gc_threaded_node> emplaced(Args&&...args) {
      return emplaced_before(nullptr, std::forward<Args>(args)...);
    }

    template <typename Fn>
    static bool for_each_while(const gc_ptr<gc_threaded_node> &from,
                               const gc_ptr<gc_threaded_node> &to,
                               Fn&& fn) 
    {
      for (gc_ptr<gc_threaded_node> n = from; n != nullptr && n != to; n = n->next) {
        if (!std::forward<Fn>(fn)(n->value)) {
          return false;
        }
      }
      return true;
    }

    template <typename Fn>
    static void for_each(const gc_ptr<gc_threaded_node> &from,
                         const gc_ptr<gc_threaded_node> &to,
                         Fn&& fn) 
    {
      for_each_while(from, to, [&](const value_type &v) {
          std::forward<Fn>(fn)(v);
          return true;
        });
    }
    template <typename Fn>
    static bool for_each_while(const gc_ptr<gc_threaded_node> &from,
                               Fn&& fn) 
    {
      return for_each_while(from, nullptr, std::forward<Fn>(fn));
    }
    template <typename Fn>
    static void for_each(const gc_ptr<gc_threaded_node> &from,
                         Fn&& fn) 
    {
      for_each(from, nullptr, std::forward<Fn>(fn));
    }

    template <typename Pred>
    static gc_ptr<gc_threaded_node>
    skip_satisfying(gc_ptr<gc_threaded_node> n, Pred&& pred)
    {
      for (; n != nullptr; n = n->next)
        {
          if (!std::forward<Pred>(pred)(n->value)) {
            return n;
          }
        }
      return nullptr;
    }

  };

  template <typename T>
  class gc_atomic_stack {
  public:
      using value_type = T;
  private:
    using node = gc_threaded_node<T>;


    atomic_versioned_gc_ptr<node> _head;
  public:

    gc_atomic_stack() : _head{nullptr} {}

    static const auto &descriptor() {
      static gc_descriptor d =
        GC_DESC(gc_atomic_stack)
        .template WITH_FIELD(&gc_atomic_stack::_head);
      return d;
    }
    void clear() {
      _head.inc_and_set(gc_ptr<node>{});
    }

    bool empty() const {
      return _head == nullptr;
    }

    void push(const gc_ptr<node> &new_node) {
      _head.update([&](auto current) {
          new_node->next = current;
          current.inc_and_set(new_node);
          return current;
        });
    }

    void push(const value_type &v) {
      push(make_gc<node>(v));
    }

    void push(value_type &&v) {
      push(make_gc<node>(std::move(v)));
    }

    template <typename...Args>
    void emplace(Args&&...args) {
      push(node::emplaced(std::forward<Args>(args)...));
    }

    template <typename Fn>
    void push_if(const value_type &v, Fn&& fn, bool push_if_empty = true) {
      gc_ptr<node> new_node = nullptr;
      _head.try_update([&](const auto &current) {
          if (current == nullptr) {
            return push_if_empty;
          }
          return std::forward<Fn>(fn)(current->value);
        },
        [&](auto current) {
          if (new_node == nullptr) {
            new_node = make_gc<node>(v);
          }
          new_node->next = current;
          current.inc_and_set(new_node);
          return current;
        });
    }
    template <typename Pred>
    void push_if_empty_or(const value_type &v, Pred&& pred) {
      push_if(v, std::forward<Pred>(pred), true);
    }

    std::pair<bool, value_type> pop() {
      auto rr = _head.try_update([&](const auto &current) {
          return current != nullptr;
        }, [&](auto current) {
          current.inc_and_set(current->next);
          return current;
        });
      if (rr) {
        return std::make_pair(true, rr.prior_value->value);
      } else {
        return std::make_pair(false, value_type{});
      }
    }

    template <typename Fn>
    std::pair<bool, value_type> pop_after(Fn&& fn) {
      auto rr = _head.try_update([](const auto &current) {
          return current != nullptr;
        }, [&](auto current) {
          std::forward<Fn>(fn)(current->value);
          current.inc_and_set(current->next);
          return current;
        });
      if (rr) {
        return std::make_pair(true, rr.prior_value->value);
      } else {
        return std::make_pair(false, value_type{});
      }
    }

    template <typename Fn>
    void apply_and_pop_all(Fn&& fn) {
      gc_ptr<node> last = nullptr;
      _head.try_update([](const gc_ptr<node> &current) {
          return current != nullptr;
        }, [&](const gc_ptr<node> &current) {
          node::for_each(current, last, std::forward<Fn>(fn));
          last = current;
          return nullptr;
        });
    }

    template <typename Pred>
    void prune_initial_satisfying(Pred&& pred) {
      _head.try_update([&](const auto &current) {
          return current != nullptr
            && std::forward<Pred>(pred)(current->value);
        }, [&](auto current) {
          /*
           *  If we get here, we know we need to pop the first one.
           */
          current.inc_and_set(node::skip_satisfying(current->next,
                                                    std::forward<Pred>(pred)));
          return current;
        });
    }

    template <typename Pred>
    void prune_and_push(const gc_ptr<node> &new_node, Pred&& pred) {
      _head.update([&](auto current) {
          new_node->next = node::skip_satisfying(current, std::forward<Pred>(pred));
          current.inc_and_set(new_node);
          return current;
        });
    }

    template <typename Pred>
    void prune_and_push(const value_type &v, Pred&& pred) {
      prune_and_push(make_gc<node>(v), std::forward<Pred>(pred));
    }

    template <typename Pred>
    void prune_and_push(value_type &&v, Pred&& pred) {
      prune_and_push(make_gc<node>(std::move(v)), std::forward<Pred>(pred));
    }


    

    template <typename Fn>
    void for_each(Fn&& fn) const {
      node::for_each(_head, std::forward<Fn>(fn));
    }

    template <typename Fn>
    void for_each_while(Fn&& fn) const {
      node::for_each_while(_head, std::forward<Fn>(fn));
    }
  }; // gc_atomic_stack

  template <typename T>
  class gc_threaded_list {
    using node = gc_threaded_node<T>;

    gc_ptr<node> _head;
    explicit gc_threaded_list(const gc_ptr<node> &h) : _head{h} {}
  public:
    using value_type = typename node::value_type;

    gc_threaded_list() : _head{nullptr} {}
    explicit gc_threaded_list(const value_type &val,
                              const gc_threaded_list &next = gc_threaded_list{})
      : _head(make_gc<node>(val, next._head))
    {}
    explicit gc_threaded_list(value_type &&val,
                              const gc_threaded_list &next = gc_threaded_list{})
      : _head(make_gc<node>(std::move(val), next._head))
    {}

    static const auto &descriptor() {
      static gc_descriptor d =
        GC_DESC(gc_threaded_list)
        .template WITH_FIELD(&gc_threaded_list::_head);
      return d;
    }

    gc_threaded_list push(const value_type &val) {
      return gc_threaded_list{val, *this};
    }
    gc_threaded_list push(value_type &&val) {
      return gc_threaded_list{std::move(val), *this};
    }

    bool empty() const {
      return _head == nullptr;
    }

    template <typename Pred>
    gc_threaded_list skip_satisfying(Pred &&pred) const {
      return gc_threaded_list{node::skip_satisfying(_head,
                                                    std::forward<Pred>(pred))};
    }

    template <typename Fn>
    void for_each(const gc_threaded_list &bound, Fn&& fn) const {
      node::for_each(_head, bound._head, std::forward<Fn>(fn));
    }
                  
    template <typename Fn>
    void for_each(Fn&& fn) const {
      node::for_each(_head, std::forward<Fn>(fn));
    }
                  
    template <typename Fn>
    bool for_each_while(const gc_threaded_list &bound, Fn&& fn) const {
      return node::for_each_while(_head, bound._head, std::forward<Fn>(fn));
    }
                  
    template <typename Fn>
    bool for_each_while(Fn&& fn) const {
      return node::for_each_while(_head, std::forward<Fn>(fn));
    }

    bool operator==(const gc_threaded_list &other) const {
      return _head == other._head;
    }
    bool operator!=(const gc_threaded_list &other) const {
      return _head != other._head;
    }
                  
    
  }; // gc_threaded_node
}

#endif // GC_STACK_H_
