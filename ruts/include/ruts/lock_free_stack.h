/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * lock_free_queue.h
 *
 *  Created on: Aug 7, 2016
 *      Author: gidra
 */

#ifndef LF_STACK_H_
#define LF_STACK_H_

#include "atomic16B.h"

#include<cstddef>
#include<atomic>
#include<memory>
#include<cassert>
/*
 * This class provides a lock-free unbounded stack implemented
 * using a singly linked-list.
 */

namespace ruts {
  template <typename T, typename A = std::allocator<T>>
  class lf_stack {
   public:
     template<typename U>
     using pointer
     = std::conditional_t<std::is_const<U>::value,
                          typename std::allocator_traits<A>
                          ::template rebind_alloc<std::remove_const_t<U>>
                          ::const_pointer,
                          typename std::allocator_traits<A>
                          ::template rebind_alloc<std::remove_const_t<U>>
                          ::pointer>;
   private:
     struct entry {
       T value;
       pointer<entry> next;
     };

     struct alignas(16) versioned_head {
       pointer<entry> ptr;
       std::size_t version;

       versioned_head() : ptr(nullptr), version(0) {}
       versioned_head(pointer<entry> p, std::size_t v) : ptr(p), version(v) {}
     };

     using entry_allocator_type = typename std::allocator_traits<A>::template rebind_alloc<entry>;

     atomic16B<versioned_head> _head;
     entry_allocator_type alloc;

  public:
     lf_stack() : _head(versioned_head()), alloc() {
     }

     ~lf_stack() {
       clear();
     }

     constexpr pointer<T> head() const {
       pointer<entry> p = _head.load().ptr;
       return p ? &p->value : nullptr;
     }

     constexpr bool empty() const { return _head.load().ptr == nullptr;}

     void clear() {
       versioned_head temp = _head;
       if (temp.ptr == nullptr)
         return;

       while (true) {
         while(!_head.compare_exchange_weak(temp, versioned_head(temp.ptr->next, temp.version + 1)));
         if (temp.ptr) {
           temp.ptr->value.~T();
           alloc.deallocate(temp.ptr, 1);
         } else {
           break;
         }
       }
     }

     template <typename ...Args>
     pointer<T> allocate(Args&&... args) {
       pointer<entry> e = alloc.allocate(1);
       T* p = &(e->value);
       new (p) T(std::forward<Args>(args)...);
       e->next = nullptr;
       return p;
     }
     //NOTE:We must ensure that we convert pointer<T> to void* using static_cast and not reinterpret_cast. This is
     //because typecast operator may be overloaded (like in offset_ptr) in some cases.
     void push(pointer<T> p) {
       pointer<entry> e = reinterpret_cast<entry*>(static_cast<uint8_t*>(static_cast<void*>(p)) - offsetof(entry, value));
       versioned_head exp = _head;
       do {
         e->next = exp.ptr;
       } while(!_head.compare_exchange_weak(exp, versioned_head(e, exp.version + 1)));
     }

     void push(pointer<T> begin, pointer<T> end) {
       pointer<entry> b = reinterpret_cast<entry*>(static_cast<uint8_t*>(static_cast<void*>(begin)) - offsetof(entry, value));
       pointer<entry> e = reinterpret_cast<entry*>(static_cast<uint8_t*>(static_cast<void*>(end)) - offsetof(entry, value));
       versioned_head exp = _head;
       do {
         e->next = exp.ptr;
       } while(!_head.compare_exchange_weak(exp, versioned_head(b, exp.version + 1)));
     }

     void pop(pointer<T> &ret) {
       versioned_head exp = _head;
       while (exp.ptr) {
         ret = &(exp.ptr->value);
         if (_head.compare_exchange_weak(exp, versioned_head(exp.ptr->next, exp.version + 1))){
           return;
         }
       }
       ret = nullptr;
     }

     void deallocate(pointer<T> e) {
       alloc.deallocate(reinterpret_cast<entry*>(static_cast<uint8_t*>(static_cast<void*>(e)) - offsetof(entry, value)), 1);
     }
  };
}



#endif /* LF_STACK_H_ */
