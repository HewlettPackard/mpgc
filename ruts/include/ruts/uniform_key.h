/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * uniform_key.h
 *
 *  Created on: Sep 7, 2014
 *      Author: evank
 */

#ifndef UNIFORM_KEY_H_
#define UNIFORM_KEY_H_

#include <functional>
#include <cstdint>
#include <random>
#include <utility>
#include <type_traits>
#include <atomic>
#include <ctime>

#include "ruts/hashes.h"
#include "ruts/mash.h"
#include "ruts/util.h"

namespace ruts {
  class uniform_key {
    static const masher &hi_masher() {
      static masher m{"Uniform Key High"};
      return m;
    }
    static const masher &lo_masher() {
      static masher m{"Uniform Key Low"};
      return m;
    }
  public:
    using hash_t = std::uint64_t;

    class default_generator {
      static hash_t seed() {
        static std::time_t now = std::time(nullptr);
        static auto rand = std::random_device()();
        static std::atomic<std::size_t> counter{0};
        return now+rand+(++counter);
      }
    public:
      hash_t operator()() {
        static thread_local std::mt19937_64 g{seed()};
        return g();
      }
    };

    hash_t high;
    hash_t low;

    class generated_t {};
    constexpr static generated_t generated = generated_t{};
    class computed_t {};
    constexpr static computed_t computed = computed_t{};

    using managed_ok = std::true_type;
    uniform_key(hash_t h, hash_t l)
    : high{h}, low{l}
    {}
    uniform_key() noexcept = default;
    explicit uniform_key(generated_t) {
      default_generator g;
      high = g();
      low = g();
    }

    template <typename T, typename U>
    explicit uniform_key(const std::pair<T, U> &hilo) : high{hilo.first}, low{hilo.second} {}

    template <typename T, typename ... Args>
    explicit uniform_key(computed_t, const T &first, Args&&...rest)
    : uniform_key(mash_pair(hi_masher(), lo_masher(), first, std::forward<Args>(rest)...))
    {}

    template <typename Generator>
    static uniform_key generate_using(Generator&& gen) {
      return uniform_key(gen(), gen());
    }

    template <typename Generator = default_generator>
    static uniform_key generate() {
      Generator g;
      return generate_using(g);
    }

    template <typename T, typename ... Args>
    static uniform_key compute(const T &first, Args&&...rest) {
      return uniform_key{computed, first, std::forward<Args>(rest)...};
    }


    template <typename T, typename H1, typename H2>
    static uniform_key compute_using(T obj, H1 h1, H2 h2){
      return uniform_key(h1(obj), h2(obj));
    }

    static std::pair<masher::accumulator_type, masher::accumulator_type>
    accumulators() {
      return std::make_pair(hi_masher().accumulator(), lo_masher().accumulator());
    }

    constexpr bool is_default() const {
      return high == 0 && low == 0;
    }

    template <typename CharT, typename Traits>
    friend std::basic_ostream<CharT, Traits> &operator <<(std::basic_ostream<CharT, Traits> &out, const uniform_key&key) {
      ruts::reset_flags_on_exit rf{out};
      return out << std::hex << key.high << "::" << key.low;
    }


  };

  template<>
  struct hash1<uniform_key> {
    uniform_key::hash_t operator()(const uniform_key &k) const {
      return k.high;
    }
  };

  template<>
  struct hash2<uniform_key> {
    uniform_key::hash_t operator()(const uniform_key &k) const {
      return k.low;
    }
  };

  inline bool operator==(const uniform_key &lhs, const uniform_key &rhs) {
    return lhs.high == rhs.high && lhs.low == rhs.low;
  }
  inline bool operator!=(const uniform_key &lhs, const uniform_key &rhs) {
    return lhs.high != rhs.high || lhs.low != rhs.low;
  }

  struct with_uniform_id {
    constexpr static std::uint64_t null_hash1 = 0;
    const uniform_key id;
    const uniform_key &uuid() const {
      return id;
    }
    using generated_t = uniform_key::generated_t;
    using computed_t = uniform_key::computed_t;
    constexpr static generated_t generated = uniform_key::generated;
    constexpr static computed_t computed = uniform_key::computed;
    using hash_t = uniform_key::hash_t;

    explicit with_uniform_id(generated_t g = generated) : id{g} {}
    template <typename T, typename U>
    explicit with_uniform_id(const std::pair<T, U> &hilo) : id{hilo} {}
    with_uniform_id(const uniform_key &k) : id{k} {}
    with_uniform_id(hash_t hi, hash_t lo) : id(std::make_pair(hi, lo)) {}
    template <typename T, typename ... Args>
    explicit with_uniform_id(computed_t, Args&&...rest)
    : id{computed, std::forward<Args>(rest)...}
    {}

  };

  template <typename T>
  struct hash1<T*, std::enable_if_t<std::is_base_of<with_uniform_id, T>::value>> {
    uniform_key::hash_t operator()(T *ptr) const {
      return ptr == nullptr ? 0 : hash1<uniform_key>{}(ptr->id);
    }
  };
  template <typename T>
  struct hash2<T*, std::enable_if_t<std::is_base_of<with_uniform_id, T>::value>> {
    uniform_key::hash_t operator()(T *ptr) const {
      return ptr == nullptr ? 0 : hash2<uniform_key>{}(ptr->id);
    }
  };


}

namespace std {
  template <> struct hash<ruts::uniform_key> : ruts::delegate_hash<ruts::uniform_key> {};
  // Unfortunately, there doesn't seem to be any way to add an is_base_of check here.
  template <> struct hash<ruts::with_uniform_id *> : ruts::delegate_hash<ruts::with_uniform_id *> {};
  template <> struct hash<const ruts::with_uniform_id *> : ruts::delegate_hash<const ruts::with_uniform_id *> {};


}




#endif /* UNIFORM_KEY_H_ */
