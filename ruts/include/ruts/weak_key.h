/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * mash.h
 *
 *  Created on: Sep 20, 2014
 *      Author: evank
 */

#ifndef WEAK_KEY_H_
#define WEAK_KEY_H_
#include "ruts/uniform_key.h"
#include <memory>
#include <type_traits>
#include <functional>
#include <ostream>

namespace ruts {
  /*
   * Stable key is like std::hash.  It takes a T and returns something
   * associated with the T that can be used in keys even if the actual
   * T has been deleted.
   */
  template <typename T> class stable_key;

  template <typename T>
  struct stable_key<T *> {
    constexpr auto operator()(T *ptr) {
      using vsk = stable_key<std::decay_t<T>>;
      using rt = std::decay_t<decltype(vsk()(*ptr))>;
      if (ptr == nullptr) {
        return rt();
      }
      return stable_key<T>()(*ptr);
    }
  };
  
  template <typename T>
  struct stable_key<std::shared_ptr<T>> {
    constexpr auto operator()(const std::shared_ptr<T> &ptr) {
      using vsk = stable_key<std::decay_t<T>>;
      using rt = std::decay_t<decltype(vsk()(*ptr))>;
      if (ptr == nullptr) {
        return rt();
      }
      return stable_key<T>()(*ptr);
    }
  };

  template <typename T>
  struct uniform_id_stable_key {
    //    static_assert(std::is_base_of<with_uniform_id, T>);
    constexpr auto operator()(const T &val) {
      return val.uuid();
    }
  };
  
  /*
   * A weak_key_traits class must define the following members:
   * - weak_type: WT
   * - strong_type: a strong equivalent type
   * - stable_key_type: The type returned by extract_stable()
   * - extract_stable(strong_type): get the stable key
   * - convert(strong_type): convert a strong to a weak
   * - lock(weak_type): (maybe) get a strong from a weak
   * - expired(weak_type): test to see whether the weak is valid.
   * - equals(weak_type, weak_type): are both valid and pointing to the same thing.
   *   If this just returns true, then only stable key equality used
   */
  template <typename WT> class weak_key_traits;

  template <typename T>
  struct weak_key_traits<std::weak_ptr<T>>
  {
    using weak_type = std::weak_ptr<T>;
    using strong_type = std::shared_ptr<T>;
    static weak_type convert(const strong_type &p) noexcept {
      return p;
    }
    static strong_type lock(const weak_type &p) noexcept {
      return p.lock();
    }
    static bool expired(const weak_type &p) noexcept {
      return p.expired();
    }
    static bool equals(const weak_type &lhs, const weak_type &rhs) noexcept {
      /*
       * We don't want to lock unless we have to.
       */
      if (lhs.expired()) {
        return rhs.expired();
      }
      if (rhs.expired()) {
        return false;
      }
      return lock(lhs) == lock(rhs);
    }

    static auto extract_stable(const strong_type &ptr) {
      using vsk = stable_key<std::decay_t<T>>;
      using rt = std::decay_t<decltype(vsk()(*ptr))>;
      if (ptr == nullptr) {
        return rt();
      }
      return stable_key<T>()(*ptr);
    }

    using stable_key_type = std::decay_t<decltype(extract_stable(std::declval<strong_type>()))>;
  };


  template <typename WeakKey, typename Traits=weak_key_traits<WeakKey> >
  struct weak_key {
    using traits_type = Traits;
    using weak_key_type = typename traits_type::weak_type;
    using strong_key_type = typename traits_type::strong_type;
    using stable_key_type = typename traits_type::stable_key_type;
    //  private:
    /*
     * The data members need to be public so that a descriptor can be written for MPGC.
     */
    stable_key_type _stable_key;
    weak_key_type _weak_key;
  public:
    weak_key(const strong_key_type &k)
      : _stable_key{traits_type::extract_stable(k)},
        _weak_key{traits_type::convert(k)}
    {}

    // template <typename T,
    //           typename = std::enable_if_t<!std::is_convertible<T, const strong_key_type &>::value
    //                                       && std::is_convertible<T, strong_key_type>::value> >
    template <typename T,
              typename = std::enable_if_t<!std::is_same<T, strong_key_type>::value
                                          && std::is_convertible<T, strong_key_type>::value> >
    weak_key(T&&k)
      : weak_key(static_cast<strong_key_type>(std::forward<T>(k)))
    {}

    weak_key() : weak_key(strong_key_type()) {}
    
    weak_key(const weak_key &) = default;
    weak_key(weak_key &&) = default;

    weak_key &operator =(const weak_key &) = default;
    weak_key &operator =(weak_key&&) = default;

    weak_key &operator =(const strong_key_type &k) {
      _stable_key = traits_type::extract_stable(k);
      _weak_key = traits_type::convert(k);
      return *this;
    }
    // template <typename T,
    //           typename = std::enable_if_t<!std::is_convertible<T, const strong_key_type &>::value
    //                                       && std::is_convertible<T, strong_key_type>::value> >
    template <typename T,
              typename = std::enable_if_t<!std::is_same<T, strong_key_type>::value
                                          && std::is_convertible<T, strong_key_type>::value> >
    weak_key &operator =(T&& k) {
      const strong_key_type key(std::forward<T>(k));
      return (*this) = key;
    }

    bool operator <(const weak_key &rhs) const {
      return _stable_key < rhs._stable_key;
    }

    bool operator ==(const weak_key &rhs) const {
      return _stable_key == rhs._stable_key && traits_type::equals(_weak_key, rhs._weak_key);
    }

    bool operator !=(const weak_key &rhs) const {
      return !(*this == rhs);
    }

    const stable_key_type &stable_key() const {
      return _stable_key;
    }

    bool expired() const {
      return traits_type::expired(_weak_key);
    }

    strong_key_type lock() const {
      return traits_type::lock(_weak_key);
    }

    const weak_key_type &peek() const {
      return _weak_key;
    }
    
  };

  template <typename CT, typename STr, typename WK, typename WKTr>
  inline
  std::basic_ostream<CT,STr> &operator<<(std::basic_ostream<CT,STr> &os,
                                         const weak_key<WK,WKTr> &key)
  {
    return os << key.peek() << " [" << key.stable_key() << "]";
  }
  
  template <typename WK, typename T>
  struct hash1<weak_key<WK,T>> {
    using wk_type = weak_key<WK,T>;
    using sk_type = typename wk_type::stable_key_type;
    auto operator()(const wk_type &key) const noexcept {
      return hash1<sk_type>()(key.stable_key());
    }
  };
  template <typename WK, typename T>
  struct hash2<ruts::weak_key<WK,T>> {
    using wk_type = ruts::weak_key<WK,T>;
    using sk_type = typename wk_type::stable_key_type;
    auto operator()(const wk_type &key) const noexcept {
      return hash2<sk_type>()(key.stable_key());
    }
  };
}

namespace std {
  template <typename WK, typename T>
  struct hash<ruts::weak_key<WK,T>> {
    using wk_type = ruts::weak_key<WK,T>;
    using sk_type = typename wk_type::stable_key_type;
    auto operator()(const wk_type &key) const noexcept {
      return hash<sk_type>()(key.stable_key());
    }
  };

}

#endif // WEAK_KEY_H_

