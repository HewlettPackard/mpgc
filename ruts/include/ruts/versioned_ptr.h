/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * versioned_ptr.h
 *
 *  Created on: Sep 1, 2014
 *      Author: evank
 */

#ifndef VERSIONED_PTR_H_
#define VERSIONED_PTR_H_

#include <cstdint>
#include <initializer_list>
#include <functional>
#include <type_traits>
#include <memory>
#include "ruts/cas_loop.h"
#include "ruts/packed_word.h"
#include "ruts/flag_set.h"
#include "ruts/util.h"

namespace ruts {
  template <typename Ptr, std::size_t NFlags, std::size_t N>
  class versioned;

}

namespace std {
  template <typename Ptr>
  struct default_versioned_pointer_traits : pointer_traits<Ptr> {
    using prim_rep = typename pointer_traits<Ptr>::element_type*;
    constexpr static size_t AddressBits = 48;
    template <typename M>
    constexpr static void construct_prim_rep(const void *loc,
                                             const Ptr &p,
                                             M&& mod) {
      return;
    }
    constexpr static Ptr from_prim_rep(prim_rep p) { return p;}
    constexpr static prim_rep to_prim_rep(Ptr p) { return p;}

    /*
     * modify() is called to do an actual modification of a
     * (non-atomic) versioned pointer (either an assignment or a
     * clear).  This provides hooks that, e.g., a gc_ptr can use to do
     * marking.  
     *
     * mod() does the actual modification and MUST be called at some
     *       point.  
     *
     * old_val() returns the current pointer value of the versioned
     *           pointer.  It is only guaranteed to be valid until
     *           mod() is called.  It will return a Ptr (or a
     *           reference to one).
     * 
     * new_val() returns the pointer value the versioned pointer is
     *           being set to.  It will return a Ptr (or a reference
     *           to one).
     */
    template <typename M, typename OV, typename NV>
    static void modify(const void *loc, M&& mod, OV&& old_val, NV&&new_val) {
      forward<M>(mod)(forward<NV>(new_val)());
    }

    struct is_dereference_allowed : true_type {};
  };

  template <typename Ptr>
  struct versioned_pointer_traits : default_versioned_pointer_traits<Ptr> {
  };
}

namespace ruts {
  class version_num {
  public:
    using rep_type = unsigned;
  private:
    rep_type _version;
  public:
    constexpr explicit version_num(rep_type v = 0) : _version(v) {}
    constexpr operator rep_type() const {
      return _version;
    }
    constexpr version_num operator+(rep_type delta) {
      return version_num(_version+delta);
    }

    class delta {
      rep_type _delta;
    public:
      explicit constexpr delta(rep_type d) : _delta(d) {}
      constexpr operator rep_type() const {
        return _delta;
      }
    };
    constexpr static delta next() {
      return delta{1};
    }
  };

  template <typename Ptr, std::size_t NFlags = 0, std::size_t N = std::versioned_pointer_traits<Ptr>::AddressBits>
  class versioned;
  template <typename Ptr, std::size_t NFlags = 0, std::size_t N = std::versioned_pointer_traits<Ptr>::AddressBits>
  class atomic_versioned;

  template <typename T, std::size_t NFlags = 0, std::size_t N = std::versioned_pointer_traits<T*>::AddressBits>
  using versioned_ptr = versioned<T*,NFlags,N>;
  template <typename T, std::size_t NFlags = 0, std::size_t N = std::versioned_pointer_traits<T*>::AddressBits>
  using atomic_versioned_ptr = atomic_versioned<T*,NFlags,N>;

  template <typename T>
  inline
  T *as_bare_pointer(T *ptr) {
    return ptr;
  }


  template <typename Ptr, std::size_t NFlags, std::size_t N>
  class versioned {
    static constexpr std::size_t nAddressBits = N;
    static_assert(nAddressBits < 8*sizeof(uint64_t), "Too many address bits");
    static constexpr std::size_t nFlagBits = NFlags;
    static_assert(nFlagBits+nAddressBits < 8*sizeof(uint64_t), "No room for version number");
    static constexpr std::size_t nVersionBits = 64-nAddressBits-nFlagBits;
    static_assert(nVersionBits <= 8*sizeof(unsigned), "Version number must fit in unsigned");

  public:
    using pointer_type = Ptr;
    using element_type = typename std::versioned_pointer_traits<Ptr>::element_type;
    using prim_rep = typename std::versioned_pointer_traits<Ptr>::prim_rep;
  private:
    template <typename U> using rebind = typename std::pointer_traits<Ptr>::template rebind<U>;

    using rep_type = ruts::packed_word<
        std::uint64_t,
        ruts::pw_field<std::size_t, nVersionBits>,
        ruts::pw_field<ruts::flag_set<nFlagBits>, nFlagBits>,
        ruts::pw_field<prim_rep, nAddressBits>
        >;

    rep_type _rep;
  public:
    constexpr static std::size_t version_field = 0;
    constexpr static std::size_t flags_field = 1;
    constexpr static std::size_t pointer_field = 2;

    using version_value = typename rep_type::template field_t<version_field>::type;
    using version_reference = typename rep_type::template field_t<version_field>::reference;
    using flags_value = typename rep_type::template field_t<flags_field>::type;
    using flags_reference = typename rep_type::template field_t<flags_field>::reference;
    using flag_reference = typename flags_reference::flag_ref_t;
    using pointer_value = pointer_type;
    class pointer_reference {
      using pf_ref = typename rep_type::template field_t<pointer_field>::reference;
      pf_ref _ref;
      pointer_reference(versioned &vp) : _ref{vp._rep.template field<pointer_field>()} {}
      friend class versioned;
    public:
      operator pointer_value() const {
        return std::versioned_pointer_traits<pointer_value>::from_prim_rep(_ref);
      }
      template <typename S = Ptr,
                typename E = std::enable_if_t<std::versioned_pointer_traits<S>
                                                 ::is_dereference_allowed::value>>
      element_type *operator->() const {
        return std::versioned_pointer_traits<pointer_value>::from_prim_rep(_ref).as_bare_pointer();
      }
      pointer_reference &operator =(const pointer_value &p) {
	using traits = std::versioned_pointer_traits<Ptr>;
	auto mod = [&](const pointer_value &ptr) {
	  _ref = traits::to_prim_rep(ptr);
	};
	auto old_val = [this]() {
	  return traits::from_prim_rep(_ref);
	};
	auto new_val = [&p]() {
	  return p;
	};
	traits::modify(this, mod, old_val, new_val);
        return *this;
      }
//      bool operator ==(const pointer_reference &rhs) const {
//        return _ref == rhs._ref;
//      }
      bool operator ==(const pointer_value &rhs) const {
        return static_cast<pointer_value>(*this) == rhs;
      }
      template <typename P2, std::size_t NF2, std::size_t N2>
      bool operator ==(const versioned<P2,NF2,N2> &rhs) const {
        return (*this) == rhs.pointer();
      }
      bool operator ==(nullptr_t) const {
        return static_cast<pointer_value>(*this) == nullptr;
      }
      template <typename X>
      bool operator !=(X &&rhs) const {
        return !((*this) == rhs);
      }
    };


    using atomic_pointer = atomic_versioned<Ptr,NFlags,N>;

    constexpr static std::size_t num_flags = nFlagBits;

    template <std::size_t F
    , typename = std::enable_if_t<(F<nFlagBits)>
    >
    struct flag_id {
      constexpr static std::size_t num() {
	return F;
      }
	  
      using mask_type = typename ruts::ints::uint_t<nFlagBits>::fast;
      constexpr static mask_type mask() {
	return mask_type{1} << num;
      }
      constexpr bool operator()(const versioned &vp) const {
        return vp.flag<num()>();
      }
      flag_reference operator()(versioned &vp) {
        return vp.flag<num()>();
      }
      bool operator()(const atomic_pointer &avp) const {
        return avp.flag<num()>();
      }
      typename atomic_pointer::flag_reference operator()(atomic_pointer &avp) {
        return avp.flag<num()>();
      }
    };

    constexpr pointer_value pointer() const {
      return std::versioned_pointer_traits<pointer_value>::from_prim_rep(_rep.template field<pointer_field>());
    }
    pointer_reference pointer() {
      return pointer_reference{*this};
    }
    constexpr operator pointer_value() const {
      return pointer();
    }
    constexpr pointer_value operator->() const {
      return pointer();
    }

    constexpr flags_value flags() const {
      return _rep.template field<flags_field>();
    }

    flags_reference flags() {
      return _rep.template field<flags_field>();
    }

    constexpr bool flag(std::size_t k) const {
      return flags()[k];
    }

    flag_reference flag(std::size_t k) {
      return flags()[k];
    }

    template <std::size_t K, typename = std::enable_if_t<(K<nFlagBits)> >
    constexpr bool flag(flag_id<K>) const {
      return flags()[K];
    }
    template <std::size_t K, typename = std::enable_if_t<(K<nFlagBits)> >
    flag_reference flag(flag_id<K>) {
      return flags()[K];
    }

    template <std::size_t K, typename = std::enable_if_t<(K<nFlagBits)> >
    constexpr bool operator[](flag_id<K>) const {
      return flags()[K];
    }
    template <std::size_t K, typename = std::enable_if_t<(K<nFlagBits)> >
    flag_reference operator[](flag_id<K>) {
      return flags()[K];
    }

    template <std::size_t K, typename = std::enable_if_t<(K<nFlagBits)>>
    constexpr bool flag() const {
      return flags()[K];
    }

    template <std::size_t K, typename = std::enable_if_t<(K<nFlagBits)>>
    flag_reference flag() {
      return flags()[K];
    }

    constexpr version_value version() const {
      return _rep.template field<version_field>();
    }

    version_reference version() {
      return _rep.template field<version_field>();
    }

    versioned(nullptr_t np = nullptr) noexcept : _rep() {}

    versioned(const pointer_type &p, version_num v = version_num(), flags_value f = flags_value()) noexcept
    : _rep(v, f, std::versioned_pointer_traits<pointer_type>::to_prim_rep(p))
    {
      std::versioned_pointer_traits<pointer_type>::construct_prim_rep(this, p,
        [&](const pointer_type &ptr) {
          _rep.set(v, f,
                   std::versioned_pointer_traits<pointer_type>::to_prim_rep(ptr));
        });
    }



    versioned(const pointer_type &p, flags_value f, version_num v = version_num()) noexcept
    : versioned(p, v, f)
    {
    }


    versioned(version_num v, flags_value f = flags_value()) noexcept
    : versioned(nullptr, v, f)
    {
    }


    versioned(flags_value f, version_num v = version_num()) noexcept
    : versioned(nullptr, v, f)
    {
    }

    template <std::size_t F, typename ...Flags>
    versioned(const pointer_type &p, version_num v, flag_id<F> f, Flags...flags) noexcept
      : versioned(p, v, flags_value::of(f.num(), flags.num()...))
      {}

    template <std::size_t F, typename ...Flags>
    versioned(const pointer_type &p, flag_id<F> f, Flags...flags) noexcept
      : versioned(p, flags_value::of(f.num(), flags.num()...))
      {}

    template <std::size_t F, typename ...Flags>
    versioned(version_num v, flag_id<F> f, Flags...flags) noexcept
      : versioned(v, flags_value::of(f.num(), flags.num()...))
      {}

    template <typename S = Ptr, typename E = typename std::versioned_pointer_traits<S>::copy_ctor_behavior>
    versioned(const versioned &v) noexcept : _rep(v._rep) {
      E::doit(this, v,
              [this](const pointer_type &p, const versioned &rhs) {
                _rep.set(rhs.version(),
                         rhs.flags(),
                         std::versioned_pointer_traits<pointer_type>::to_prim_rep(p));
              }
      );
    }

    template <typename S = Ptr, typename E = typename std::versioned_pointer_traits<S>::copy_ctor_behavior>
    versioned(versioned &&v) noexcept : _rep(std::move(v._rep)) {
      E::doit(this, *this,
              [this](const pointer_type &p, const versioned &rhs) {
                _rep.set(rhs.version(),
                         rhs.flags(),
                         std::versioned_pointer_traits<pointer_type>::to_prim_rep(p));
              }
      );
    }

    versioned &set(const pointer_type &p, version_num v, flags_value f) noexcept
    {
      using traits = std::versioned_pointer_traits<Ptr>;
      auto mod = [&](const pointer_type &ptr) {
	_rep.set(v, f, traits::to_prim_rep(ptr));
      };
      auto old_val = [this]() {
	return pointer();
      };
      auto new_val = [&p]() {
	return p;
      };
      traits::modify(this, mod, old_val, new_val);
      return *this;
    }


    versioned &set(const pointer_type &p, version_num::delta d, flags_value f) noexcept
    {
      pointer() = p;
      version() += d;
      flags() = f;
      return *this;
    }

    versioned &set(const pointer_type &p, version_num v) noexcept
    {
      pointer() = p;
      version() = v;
      return *this;
    }

    versioned &set(const pointer_type &p, version_num::delta d) noexcept
    {
      pointer() = p;
      version() += d;
      return *this;
    }


    versioned &set(const pointer_type &p, flags_value f) noexcept
    {
      pointer() = p;
      flags() = f;
      return *this;
    }



    versioned &set(version_num v, flags_value f) noexcept
    {
      version() = v;
      flags() = f;
      return *this;
    }


    versioned &set(version_num::delta d, flags_value f) noexcept
    {
      version() += d;
      flags() = f;
      return *this;
    }

    versioned &set(const pointer_type &p) noexcept
    {
      pointer() = p;
      return *this;
    }

    versioned &set(version_num v) noexcept
    {
      version() = v;
      return *this;
    }

    versioned &set(version_num::delta d) noexcept
    {
      version() += d;
      return *this;
    }


    versioned &set(flags_value f) noexcept
    {
      flags() = f;
      return *this;
    }

    versioned &inc_and_set(const pointer_type &p, flags_value f, int delta = 1) {
      return set(p, version_num::delta(delta), f);
    }

    versioned &inc_and_set(const pointer_type &p, int delta = 1) {
      return set(p, version_num::delta(delta));
    }

    // copy the pointer and flags, but increment the lhs version number
    versioned &inc_and_set(const versioned &rhs, int delta = 1) {
      return inc_and_set(rhs.pointer(), rhs.flags(), delta);
    }

    versioned &clear() {
      using traits = std::versioned_pointer_traits<Ptr>;
      auto mod = [this](const pointer_type &p) {
	_rep.clear();
      };
      auto old_val = [this]() {
	return pointer();
      };
      auto new_val = []() {
	return pointer_type{};
      };
      traits::modify(this, mod, old_val, new_val);

      return *this;
    }

    template <typename CharT, typename Traits>
    friend std::basic_ostream<CharT, Traits> &operator <<(std::basic_ostream<CharT, Traits> &out, const versioned &vp) {
      reset_flags_on_exit r(out);
      return out << std::hex << vp._rep;
    }

    bool operator ==(const versioned &rhs) const {
      return _rep == rhs._rep;
    }

    bool operator !=(const versioned &rhs) const {
      return _rep != rhs._rep;
    }

    bool operator ==(const pointer_type &rhs) const {
      return pointer() == rhs;
    }
    bool operator !=(const pointer_type &rhs) const {
      return pointer() != rhs;
    }

    bool operator ==(nullptr_t) const {
      return pointer() == nullptr;
    }
    bool operator !=(nullptr_t) const {
      return pointer() != nullptr;
    }

  };



  template <typename Ptr, std::size_t NF, std::size_t N>
  inline
  bool operator==(const typename versioned<Ptr,NF,N>::pointer_type &lhs, const versioned<Ptr,NF,N> &rhs) {
    return rhs == lhs;
  }
  template <typename Ptr, std::size_t NF, std::size_t N>
  inline
  bool operator!=(const typename versioned<Ptr,NF,N>::pointer_type &lhs, const versioned<Ptr,NF,N> &rhs) {
    return rhs != lhs;
  }
  template <typename Ptr, std::size_t NF, std::size_t N>
  inline
  bool operator==(nullptr_t, const versioned<Ptr,NF,N> &rhs) {
    return rhs == nullptr;
  }
  template <typename Ptr, std::size_t NF, std::size_t N>
  inline
  bool operator!=(nullptr_t, const versioned<Ptr,NF,N> &rhs) {
    return rhs != nullptr;
  }


  template <typename Ptr, std::size_t NFlags, std::size_t N>
  class atomic_versioned {
  public:
    using versioned_ptr_type = versioned<Ptr,NFlags,N>;
  private:
    using atomic_type = std::atomic<versioned_ptr_type>;
    atomic_type _atomic;
    versioned_ptr_type vp() const {
      return _atomic.load();
    }
  public:
    using update_return = cas_loop_return_value<versioned_ptr_type>;
    using version_value = typename versioned_ptr_type::version_value;
    using flags_value = typename versioned_ptr_type::flags_value;
    using pointer_value = typename versioned_ptr_type::pointer_value;
    constexpr static std::size_t num_flags = versioned_ptr_type::num_flags;
    using pointer_type = typename versioned_ptr_type::pointer_type;
    using element_type = typename versioned_ptr_type::element_type;

    template <std::size_t F,
    typename = std::enable_if_t<(F<num_flags)>>
    using flag_id = typename versioned_ptr_type::template flag_id<F>;

    const atomic_type &underlying_atomic() const {
      return _atomic;
    }

    atomic_type &underlying_atomic() {
      return _atomic;
    }

    versioned_ptr_type contents() const {
      return vp();
    }

    template <typename CharT, typename Traits>
    friend std::basic_ostream<CharT, Traits> &operator <<(std::basic_ostream<CharT, Traits> &out, const atomic_versioned &avp) {
      return out << avp.contents();
    }

    pointer_value pointer() const {
      return vp().pointer();
    }

    operator pointer_value() const {
      return vp().pointer();
    }

    pointer_value operator->() const {
      return pointer();
    }

    class pointer_reference {
      atomic_versioned &_avp;
      pointer_reference(atomic_versioned &avp) : _avp(avp) {}
      friend class atomic_versioned;
    public:
      operator pointer_value() const {
        return _avp.vp().pointer();
      }
      pointer_value operator->() const {
        return _avp.vp().pointer();
      }
      pointer_reference &operator =(const pointer_value &p) {
        _avp.set(p);
        return *this;
      }
      bool operator ==(const pointer_value &rhs) const {
        return static_cast<pointer_value>(*this) == rhs;
      }
      template <typename P2, std::size_t NF2, std::size_t N2>
      bool operator ==(const versioned<P2,NF2,N2> &rhs) const {
        return (*this) == rhs.pointer();
      }
      template <typename P2, std::size_t NF2, std::size_t N2>
      bool operator ==(const atomic_versioned<P2,NF2,N2> &rhs) const {
        return (*this) == rhs.pointer();
      }
      bool operator ==(nullptr_t) const {
        return static_cast<pointer_value>(*this) == nullptr;
      }
      template <typename X>
      bool operator !=(X &&rhs) const {
        return !((*this) == rhs);
      }
    };

    pointer_reference pointer() {
      return pointer_reference{*this};
    }

    flags_value flags() const {
      return vp().flags();
    }

    class flag_reference {
      atomic_versioned &_avp;
      const std::size_t _flag;
      flag_reference(atomic_versioned &avp, std::size_t f)
      : _avp(avp), _flag(f)
      {}
      friend class atomic_versioned;
      friend class flags_reference;
    public:
      operator bool() const {
        return _avp.vp().flag(_flag);
      }
      flag_reference &operator =(bool val) {
        _avp.set_flag(_flag, val);
        return *this;
      }
      flag_reference &set() {
        return (*this) = true;
      }
      flag_reference &clear() {
        return (*this) = true;
      }

    };

    class flags_reference {
      atomic_versioned &_avp;
      flags_reference(atomic_versioned &avp) : _avp(avp) {}
      friend class atomic_versioned;
    public:
      operator flags_value() const {
        return _avp.flags();
      }
      flags_reference &operator =(const flags_value &fs) {
        _avp.set(fs);
        return *this;
      }
      bool operator[](std::size_t f) const {
        return _avp.flag(f);
      }
      flag_reference operator[](std::size_t f) {
        return flag_reference(_avp, f);
      }
    };

    flags_reference flags() {
      return flags_reference{*this};
    }

    bool flag(std::size_t k) const {
      return vp().flag(k);
    }

    template <std::size_t F,
    typename = std::enable_if_t<(F<num_flags)>>
    bool flag() const {
      return flag(F);
    }

    template <std::size_t F,
    typename = std::enable_if_t<(F<num_flags)>>
    bool flag(flag_id<F>) const {
      return flag(F);
    }

    flag_reference flag(std::size_t k) {
      return flags()[k];
    }

    template <std::size_t F,
    typename = std::enable_if_t<(F<num_flags)>>
    flag_reference flag() {
      return flag(F);
    }

    template <std::size_t F,
    typename = std::enable_if_t<(F<num_flags)>>
    flag_reference flag(flag_id<F>) {
      return flag(F);
    }

    version_value version() const {
      return vp().version();
    }

    class version_reference {
      atomic_versioned &_avp;
      version_reference(atomic_versioned &avp) : _avp(avp) {}
      friend class atomic_versioned;
    public:
      operator version_value() const {
        return _avp.version();
      }
      version_reference &operator =(const version_value &v) {
        _avp.set(version_num(v));
        return *this;
      }

      version_reference &operator +=(std::size_t delta) {
        _avp.set(version_num::delta(delta));
        return *this;
      }
      version_reference &operator ++() {
        return operator +=(1);
      }
      version_value operator ++(int) {
        update_return r = _avp.set(version_num::next());
        return r.prior_value.version();
      }
    };

    version_reference version() {
      return version_reference(*this);
    }

    explicit atomic_versioned(const versioned_ptr_type &vp)
      : _atomic{vp}
    {}

    explicit atomic_versioned(nullptr_t)
      : _atomic{nullptr}
    {}
    
    explicit atomic_versioned(const pointer_type &p = pointer_type{}, version_num v = version_num(), flags_value f = flags_value()) noexcept
        : _atomic(versioned_ptr_type{p, v, f})
          {}

    atomic_versioned(const pointer_type &p, flags_value f, version_num v = version_num()) noexcept
    : _atomic(versioned_ptr_type{p, f, v})
    {
    }


    atomic_versioned(version_num v, flags_value f = flags_value()) noexcept
    : _atomic(versioned_ptr_type{v, f})
    {
    }


    atomic_versioned(flags_value f, version_num v = version_num()) noexcept
    : _atomic(versioned_ptr_type{f, v})
    {
    }

    template <typename Continue, typename Update>
    update_return try_update(Continue cfn, Update ufn) {
      return try_cas_loop(_atomic, cfn, ufn);
    }

    template <typename Continue, typename Update>
    update_return try_update(std::size_t max_tries, Continue cfn, Update ufn) {
      return max_tries == 1 ? try_cas(_atomic, cfn, ufn) : try_cas_loop(_atomic, max_tries, cfn, ufn);
    }

    template <typename Update>
    update_return try_update(std::size_t max_tries, Update ufn) {
      return try_cas_loop(_atomic, max_tries, ufn);
    }

    template <typename Update>
    update_return update(Update ufn) {
      return cas_loop(_atomic, ufn);
    }

    void fast_set(const versioned_ptr_type &to) {
      _atomic = to;
    }

    update_return set(const versioned_ptr_type &to) {
      return cas_loop(_atomic, [=](const versioned_ptr_type &){ return to; });
    }

    update_return reset() {
      return set(versioned_ptr_type{});
    }

    update_return change(const versioned_ptr_type &from, const versioned_ptr_type &to) {
      return try_change_value(_atomic, from, to);
    }

    update_return reset_from(const versioned_ptr_type &from) {
      return change(from, versioned_ptr_type{});
    }

    template <typename Update>
    update_return change_using(const versioned_ptr_type &from, Update ufn) {
      return try_change_value(_atomic, from, ufn(from));
    }



    update_return set(const pointer_type &p, version_num v, flags_value f) {
      return update([=](versioned_ptr_type vp) {
        return vp.set(p, v, f);
      });
    }

    update_return change(const versioned_ptr_type &expected, const pointer_type &p, version_num v, flags_value f) {
      return change_using(expected, [=](versioned_ptr_type vp) {
        return vp.set(p, v, f);
      });
    }


    update_return set(const pointer_type &p, version_num::delta d, flags_value f) {
      return update([=](versioned_ptr_type vp) {
        return vp.set(p, d, f);
      });
    }

    update_return change(const versioned_ptr_type &expected, const pointer_type &p, version_num::delta d, flags_value f) {
      return change_using(expected, [=](versioned_ptr_type vp) {
        return vp.set(p, d, f);
      });
    }

    update_return set(const pointer_type &p, version_num v) {
      return update([=](versioned_ptr_type vp) {
        return vp.set(p, v);
      });
    }

    update_return change(const versioned_ptr_type &expected, const pointer_type &p, version_num v) {
      return change_using(expected, [=](versioned_ptr_type vp) {
        return vp.set(p, v);
      });
    }


    update_return set(const pointer_type &p, version_num::delta d) {
      return update([=](versioned_ptr_type vp) {
        return vp.set(p, d);
      });
    }

    update_return change(const versioned_ptr_type &expected, const pointer_type &p, version_num::delta d) {
      return change_using(expected, [=](versioned_ptr_type vp) {
        return vp.set(p, d);
      });
    }

    update_return set(const pointer_type &p, flags_value f) {
      return update([=](versioned_ptr_type vp) {
        return vp.set(p, f);
      });
    }

    update_return change(const versioned_ptr_type &expected, const pointer_type &p, flags_value f) {
      return change_using(expected, [=](versioned_ptr_type vp) {
        return vp.set(p, f);
      });
    }

    update_return set(version_num v, flags_value f) {
      return update([=](versioned_ptr_type vp) {
        return vp.set(v, f);
      });
    }

    update_return change(const versioned_ptr_type &expected, version_num v, flags_value f) {
      return change_using(expected, [=](versioned_ptr_type vp) {
        return vp.set(v, f);
      });
    }


    update_return set(version_num::delta d, flags_value f) {
      return update([=](versioned_ptr_type vp) {
        return vp.set(d, f);
      });
    }

    update_return change(const versioned_ptr_type &expected, version_num::delta d, flags_value f) {
      return change_using(expected, [=](versioned_ptr_type vp) {
        return vp.set(d, f);
      });
    }

    update_return set(const pointer_type &p) {
      return update([=](versioned_ptr_type vp) {
        return vp.set(p);
      });
    }

    update_return set_pointer(const pointer_type &p) {
      return set(p);
    }

    update_return reset_pointer() {
      return set_pointer(pointer_type{});
    }

    update_return change(const versioned_ptr_type &expected, const pointer_type &p) {
      return change_using(expected, [=](versioned_ptr_type vp) {
        return vp.set(p);
      });
    }

    update_return change_pointer(const versioned_ptr_type &expected, const pointer_type &p) {
      return change(expected, p);
    }

    update_return reset_pointer_from(const versioned_ptr_type &expected) {
      return change(expected, pointer_type{});
    }
    
    update_return set(version_num v) {
      return update([=](versioned_ptr_type vp) {
        return vp.set(v);
      });
    }

    update_return change(const versioned_ptr_type &expected, version_num v) {
      return change_using(expected, [=](versioned_ptr_type vp) {
        return vp.set(v);
      });
    }
    update_return set(version_num::delta d) {
      return update([=](versioned_ptr_type vp) {
        return vp.set(d);
      });
    }

    update_return change(const versioned_ptr_type &expected, version_num::delta d) {
      return change_using(expected, [=](versioned_ptr_type vp) {
        return vp.set(d);
      });
    }
    update_return set(flags_value f) {
      return update([=](versioned_ptr_type vp) {
        return vp.set(f);
      });
    }

    update_return change(const versioned_ptr_type &expected, flags_value f) {
      return change_using(expected, [=](versioned_ptr_type vp) {
        return vp.set(f);
      });
    }
    update_return set_flag(std::size_t f, bool val = true) {
      return update([=](versioned_ptr_type vp) {
        vp.flag(f) = val;
        return vp;
      });
    }

    update_return change_flag(const versioned_ptr_type &expected, std::size_t f, bool val = true) {
      return change_using(expected, [=](versioned_ptr_type vp) {
        vp.flag(f) = val;
        return vp;
      });
    }

    update_return clear_flag(std::size_t f) {
      return set_flag(f, false);
    }

    update_return change_flag_clear(const versioned_ptr_type &expected, std::size_t f) {
      return change_flag(f, false);
    }

    template <std::size_t F, typename = std::enable_if_t<(F<num_flags)>>
    update_return set_flag(bool val = true) {
      return set_flag(F, val);
    }

    template <std::size_t f, typename = std::enable_if_t<(f<num_flags)>>
    update_return change_flag(const versioned_ptr_type &expected, bool val = true) {
      return change_flag(expected, f, val);
    }

    template <std::size_t f, typename = std::enable_if_t<(f<num_flags)>>
    update_return clear_flag() {
      return set_flag(f, false);
    }

    template <std::size_t f, typename = std::enable_if_t<(f<num_flags)>>
    update_return change_flag_clear(const versioned_ptr_type &expected) {
      return change_flag(f, false);
    }

    template <std::size_t f, typename = std::enable_if_t<(f<num_flags)>>
    update_return set_flag(flag_id<f>, bool val = true) {
      return set_flag(f, val);
    }

    template <std::size_t f, typename = std::enable_if_t<(f<num_flags)>>
    update_return change_flag(const versioned_ptr_type &expected, flag_id<f>, bool val = true) {
      return change_flag(expected, f, val);
    }

    template <std::size_t f, typename = std::enable_if_t<(f<num_flags)>>
    update_return clear_flag(flag_id<f>) {
      return set_flag(f, false);
    }

    template <std::size_t f, typename = std::enable_if_t<(f<num_flags)>>
    update_return change_flag_clear(const versioned_ptr_type &expected, flag_id<f>) {
      return change_flag(f, false);
    }



    update_return inc_and_set(const pointer_type &p, flags_value f, int delta = 1) {
      return set(p, version_num::delta(delta), f);
    }

    update_return inc_and_change(const versioned_ptr_type &expected, const pointer_type &p, flags_value f, int delta = 1) {
      return change(expected, p, version_num::delta(delta), f);
    }

    update_return inc_and_set(const pointer_type &p, int delta = 1) {
      return set(p, version_num::delta(delta));
    }

    update_return inc_and_change(const versioned_ptr_type &expected, const pointer_type &p, int delta = 1) {
      return change(expected, p, version_num::delta(delta));
    }

    update_return inc_and_set(flags_value f, int delta = 1) {
      return set(version_num::delta(delta), f);
    }

    update_return inc_and_change(const versioned_ptr_type &expected, flags_value f, int delta = 1) {
      return change(expected, version_num::delta(delta), f);
    }

    update_return inc_and_set_flag(std::size_t f, bool val = true) {
      return update([=](versioned_ptr_type vp) {
        vp.flag(f) = val;
        vp.version()++;
        return vp;
      });
    }

    update_return inc_and_change_flag(const versioned_ptr_type &expected, std::size_t f, bool val = true) {
      return change(expected, [=](versioned_ptr_type vp) {
        vp.flag(f) = val;
        vp.version()++;
        return vp;
      });
    }

    update_return inc_and_clear_flag(std::size_t f) {
      return inc_and_set_flag(f, false);
    }

    update_return inc_and_change_flag_clear(const versioned_ptr_type &expected, std::size_t f) {
      return inc_and_change_flag(f, false);
    }

    template <std::size_t f, typename = std::enable_if_t<(f<num_flags)>>
    update_return inc_and_set_flag(bool val = true) {
      return inc_and_set_flag(f, val);
    }

    template <std::size_t f, typename = std::enable_if_t<(f<num_flags)>>
    update_return inc_and_change_flag(const versioned_ptr_type &expected, bool val = true) {
      return inc_and_change_flag(expected, f, val);
    }

    template <std::size_t f, typename = std::enable_if_t<(f<num_flags)>>
    update_return inc_and_clear_flag() {
      return inc_and_set_flag(f, false);
    }

    template <std::size_t f, typename = std::enable_if_t<(f<num_flags)>>
    update_return inc_and_change_flag_clear(const versioned_ptr_type &expected) {
      return inc_and_change_flag(f, false);
    }

    template <std::size_t f, typename = std::enable_if_t<(f<num_flags)>>
    update_return inc_and_set_flag(flag_id<f>, bool val = true) {
      return inc_and_set_flag(f, val);
    }

    template <std::size_t f, typename = std::enable_if_t<(f<num_flags)>>
    update_return inc_and_change_flag(const versioned_ptr_type &expected, flag_id<f>, bool val = true) {
      return inc_and_change_flag(expected, f, val);
    }

    template <std::size_t f, typename = std::enable_if_t<(f<num_flags)>>
    update_return inc_and_clear_flag(flag_id<f>) {
      return inc_and_set_flag(f, false);
    }

    template <std::size_t f, typename = std::enable_if_t<(f<num_flags)>>
    update_return inc_and_change_flag_clear(const versioned_ptr_type &expected, flag_id<f>) {
      return inc_and_change_flag(f, false);
    }

    bool operator ==(const atomic_versioned &rhs) const {
      return contents() == rhs.contents();
    }
    bool operator ==(const versioned_ptr_type &rhs) const {
      return contents() == rhs;
    }
    bool operator ==(nullptr_t) const {
      return contents() == nullptr;
    }
    bool operator ==(const pointer_value &rhs) const {
      return contents() == rhs;
    }
    template <typename RHS>
    bool operator !=(RHS&& rhs) const {
      return !((*this) == std::forward<RHS>(rhs));
    }



  };
  template <typename Ptr, std::size_t NF, std::size_t N>
  inline
  bool operator==(const typename atomic_versioned<Ptr,NF,N>::pointer_type &lhs, const atomic_versioned<Ptr,NF,N> &rhs) {
    return rhs == lhs;
  }
  template <typename Ptr, std::size_t NF, std::size_t N>
  inline
  bool operator!=(const typename atomic_versioned<Ptr,NF,N>::pointer_type &lhs, const atomic_versioned<Ptr,NF,N> &rhs) {
    return !(lhs==rhs);
  }
  template <typename Ptr, std::size_t NF, std::size_t N>
  inline
  bool operator==(const typename atomic_versioned<Ptr,NF,N>::versioned_ptr_type &lhs, const atomic_versioned<Ptr,NF,N> &rhs) {
    return rhs == lhs;
  }
  template <typename Ptr, std::size_t NF, std::size_t N>
  inline
  bool operator!=(const typename atomic_versioned<Ptr,NF,N>::versioned_ptr_type &lhs, const atomic_versioned<Ptr,NF,N> &rhs) {
    return !(lhs==rhs);
  }
  template <typename Ptr, std::size_t NF, std::size_t N>
  inline
  bool operator==(nullptr_t, const atomic_versioned<Ptr,NF,N> &rhs) {
    return rhs == nullptr;
  }
  template <typename Ptr, std::size_t NF, std::size_t N>
  inline
  bool operator!=(nullptr_t, const atomic_versioned<Ptr,NF,N> &rhs) {
    return rhs != nullptr;
  }
}



#endif /* VERSIONED_PTR_H_ */
