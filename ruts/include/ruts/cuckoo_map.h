/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * cuckoo_map.h
 *
 *  Created on: Jul 28, 2014
 *      Author: evank
 */

#ifndef CUCKOO_MAP_H_
#define CUCKOO_MAP_H_

#include <cstdint>
#include <random>
#include <atomic>
#include <memory>
#include <utility>
#include <cassert>
#include <random>

#include "ruts/versioned_ptr.h"
#include "ruts/bit_field.h"
#include "ruts/meta.h"
#include "ruts/runtime_array.h"
#include "ruts/hashes.h"
#include "ruts/cas_loop.h"
#include "ruts/util.h"

namespace ruts {

  template <std::size_t Cap, std::size_t Bits, std::size_t Size, typename Enable = void> struct __bits_needed;

  template <typename K, typename V, typename Hash1=ruts::hash1<K>, typename Hash2=ruts::hash2<K>,
      std::size_t SegBits = 10, typename Allocator = std::allocator<V>>
  class cuckoo_map {
  public:
    using key_type = K;
    using value_type = V;

    using hash1_fn_type = Hash1;
    using hash2_fn_type = Hash2;
    using hash_type = uint64_t;

    //    template <typename T>
    //    using pointer = T*;
    template <typename T>
    using pointer
    = std::conditional_t<std::is_const<T>::value,
                         typename std::allocator_traits<Allocator>
                         ::template rebind_alloc<std::remove_const_t<T>>
                         ::const_pointer,
                         typename std::allocator_traits<Allocator>
                         ::template rebind_alloc<std::remove_const_t<T>>
                         ::pointer>;
    template <typename T, std::size_t NFlags=0>
    using v_pointer = versioned<pointer<T>,NFlags>;
    template <typename T, std::size_t NFlags=0>
    using av_pointer = atomic_versioned<pointer<T>,NFlags>;

  private:
    struct entry_type {
      const key_type key;
      std::atomic<value_type> val;
      entry_type (const key_type &k, const value_type &v) : key{k}, val{v} {}
    };

    constexpr static std::size_t num_flags = 2;
    using entry_ptr_type = v_pointer<entry_type, num_flags>;
    using atomic_entry_ptr_type = av_pointer<entry_type, num_flags>;
    /**
     * Pointer is in the process of being moved from one table to the other.  Not considered there yet.
     * (It may have been deleted between the time we started and the time we wrote.)
     */
    constexpr static typename entry_ptr_type::template flag_id<0> moving{};
    /**
     * Pointer has (maybe) been moved from segment to its replacement and shouldn't be overwritten
     */
    constexpr static typename entry_ptr_type::template flag_id<1> frozen{};


    using entry_alloc_type = meta::rebind_alloc_t<Allocator, entry_type>;
    using atomic_entry_ptr_alloc_type = meta::rebind_alloc_t<Allocator, atomic_entry_ptr_type>;

    constexpr static std::size_t n_tables = 2;
    constexpr static std::size_t n_seg_bits = SegBits;
    constexpr static std::size_t max_eviction_depth = 8;
    constexpr static std::size_t default_initial_segment_bits = 10;
    constexpr static std::size_t max_segment_slot_bits = 64-n_seg_bits;
    constexpr static std::size_t default_cap = 1 << (n_seg_bits + default_initial_segment_bits);

    enum class side { LEFT, RIGHT };


    class switched_hash {
      const hash1_fn_type hash1;
      const hash2_fn_type hash2;
      const bool use_hash1;
    public:
      switched_hash(side s, const hash1_fn_type h1, const hash2_fn_type h2) : hash1(h1), hash2(h2), use_hash1(s == side::LEFT) {}
      hash_type operator()(const key_type &key) const {
        return use_hash1 ? hash1(key) : hash2(key);
      }
    };




    struct replace_return {
      bool replaced = false;
      bool had_value = false;
      value_type old_value;
      value_type resulting_value;
      operator bool() const {
        return replaced;
      }
      replace_return() {}
      replace_return(bool r, bool hv, const value_type &ov, const value_type &nv)
      : replaced(r),
        had_value(hv),
        old_value(ov),
        resulting_value(nv)
      {}
    };


    class table;
    class segment;

    struct slot_const_ref {
      pointer<const segment> seg;
      std::size_t index;
      const atomic_entry_ptr_type *slot;
      operator const atomic_entry_ptr_type *() const {
        return slot;
      }
      const atomic_entry_ptr_type *operator->() const {
        return slot;
      }
      entry_ptr_type contents() const {
        return slot->contents();
      }
      slot_const_ref(const pointer<const segment> &s, std::size_t i, const atomic_entry_ptr_type &sr)
      : seg(s), index(i), slot(&sr)
      {}
    };

    struct slot_ref {
      pointer<segment> seg;
      std::size_t index;
      atomic_entry_ptr_type *slot;
      operator atomic_entry_ptr_type *() const {
        return slot;
      }
      atomic_entry_ptr_type *operator->() const {
        return slot;
      }
      operator slot_const_ref() const {
        return slot_const_ref(seg, index, *slot);
      }
      entry_ptr_type contents() const {
        return slot->contents();
      }
      slot_ref(const pointer<segment> &s, std::size_t i, atomic_entry_ptr_type &sr)
      : seg(s), index(i), slot(&sr)
      {}
    };

    class source_grew {};

    class segment {
      using slot_array_type = ruts::runtime_array<atomic_entry_ptr_type, atomic_entry_ptr_alloc_type>;

      const std::size_t _num;
      table &_table;
      switched_hash _hash = _table._hash;
      const std::size_t _slot_bits;
      const std::size_t _size = (std::size_t{1} << _slot_bits);
      const std::size_t _mask = _size-1;
      atomic_entry_ptr_alloc_type _alloc;
      slot_array_type _slots{_size, _alloc};
      std::atomic<pointer<segment>> _replacement{nullptr};
      mutable std::atomic<std::size_t> _next_to_migrate{0};

      friend class table;
      friend class cuckoo_map;

      /*constexpr*/ std::size_t slot_index(hash_type hash) const {
        return hash & _mask;
      }

      slot_ref slot(hash_type hash) {
        std::size_t i = slot_index(hash);
        return slot_ref(this, i, _slots[i]);
      }
      slot_const_ref slot(hash_type hash) const {
        std::size_t i = slot_index(hash);
        return slot_const_ref(this, i, _slots[i]);
      }

      slot_ref slot(const key_type &key) {
        return slot(_hash(key));
      }
      slot_const_ref slot(const key_type &key) const {
        return slot(_hash(key));
      }



      bool matches(const key_type &key, const entry_ptr_type &ep) const
      {
        pointer<entry_type> e = ep.pointer();
        return (e != nullptr && !moving(ep) && e->key == key);
      }

      bool replace_null(const pointer<entry_type> &with, hash_type hash) {
        atomic_entry_ptr_type &s = *slot(hash);

        auto guard = [=](const entry_ptr_type &ep) {
          return ep == nullptr && !ep[frozen];
        };

        auto change = [=](entry_ptr_type ep) {
          return ep.inc_and_set(with);
        };

        auto ur = s.try_update(1, guard, change);
        //  we don't want to succeed if the blocker points to the
        //  same value, because that's indicative of a "locked entry"
        //  due to a process crash immediately following removal of
        //  the "moving" flag.  (At least when evicting)
        if (ur) {
          return true;
        } else if (ur.prior_value[frozen]) {
          pointer<segment> new_seg = help_with_grow();
          return new_seg->replace_null(with, hash);
        } else {
          return false;
        }
      }


      // Throws source_grew if the source is frozen when we do the second read, because this
      // may no longer be the slot we wanted to move from.

      // On successful return, either the source or the destination (or neither) has the value,
      // but not both.

      /*
       * Note that it's possible that both source and target have entries (these should be
       * different unless we're in the middle of a move) with the same key.  In this case,
       * the left shadows the right, and we allow the move from left to right, but not from
       * right to left.  (Strictly speaking, we could go the other way, too, with the right-
       * to-left move not actually moving anything, but this raises the possibility that both
       * moves will happen at the same side and both will clear, deleting both.
       */

      bool accept_move(slot_ref &source,
                       entry_ptr_type current,
                       slot_ref &target)
      {
        if (moving(current)) {
          // we can't move something that's being moved.
          return false;
        }

	if (current.pointer() == nullptr) {
	  // For some reason we're trying to move a null.
	  // We'll just say we did it.
	  return true;
	}

        auto guard = [=](const entry_ptr_type &ep) {
          // TODO: Can we usurp if we see that somebody else is moving it?
	  if (ep[frozen]) {
	    return false;
	  }
	  auto ptr = ep.pointer();
	  if (ptr == nullptr) {
	    return true;
	  }
	  return (ptr->key == current->key 
		  && _table._side == side::RIGHT);
        };

        auto change = [=](entry_ptr_type ep) {
          ep.pointer() = current.pointer();
          ep[moving] = true;
          ep.version()++;
          return ep;
        };

        auto ur = target->try_update(guard, change);
        if (!ur) {
          // not empty or frozen.
          if (ur.prior_value[frozen]) {
            pointer<segment> new_seg = help_with_grow();
            // Find the new target slot (and communicate it back to the caller)
            target = new_seg->slot(current->key);
            return new_seg->accept_move(source, current, target);
          }
	  /*
	   * If we wanted to allow RTL moves with equivalent keys, we'd check
	   * for key equivalence here and let it fall through.
	   */
          return false;
        }

        // Check to make sure the old value wasn't deleted since we read it.
        entry_ptr_type sp = source.contents();
        // The logic for handling sources that change seems very complicated.  For
        // now, we're going to punt, which may result in more work being done than
        // strictly necessary.
        if (sp[frozen]) {
          _table._map.clear_slot(target, ur.resulting_value(), current->key);
          throw source_grew{};
        }
        if (sp.pointer() != current) {
          // It was removed, so we need to clear the slot.
          _table._map.clear_slot(target, ur.resulting_value(), current->key);
          return false;
        }
        // Now we remove the "moving" flag.
        while (true) {
          auto ur2 = target->change_using(ur.resulting_value(), [](entry_ptr_type ep){
            ep[moving] = false;
            ep.version()++;
            return ep;
          });
          // If not, the value was removed from the map after we set the moving flag.
          if (ur2) {
            break;
          } else if (ur2.prior_value[frozen]) {
            // The segment grew, so we need to reestablish the target
            pointer<segment> new_seg = help_with_grow();
            target = new_seg->slot(current->key);
          } else {
            return false;
          }
        }
        // We're done moving.  The value is now in both places.
        // Remove it from the source.  If it's not there, it means it was removed.  That's okay.
        _table._map.clear_slot(source, current, current->key);
        return true;
      }


      void grow(std::size_t by) {
        pointer<segment> new_seg = _table.create_segment(this, by);
        if (!ruts::try_change_value(_replacement, nullptr, new_seg)) {
          // Somebody else got there first.  That's okay.
          _table.delete_segment(new_seg);
        }
        help_with_grow();
        // At the end it will be installed.
      }

      pointer<segment> help_with_grow() const {
        pointer<segment> r = _replacement;
        segment *nc_this = const_cast<segment *>(this);
        for (std::size_t i = _next_to_migrate; i < _size; /* update at end */) {
          // We're okay with casting away constness to freeze the slot.
          atomic_entry_ptr_type &slot = nc_this->_slots[i];
          auto ur = slot.template set_flag(frozen);
          // We may not have been the first one to freeze it, but we can't assume that
          // the one who did succeeded in copying it.
          entry_ptr_type ep = ur.new_value;
          pointer<entry_type> e = ep;
          if (e != nullptr) {
            // Find the slot in the replacement.
            hash_type h = _hash(e->key);
            std::size_t i = r->slot_index(h);

            // we want to keep the same version number on the other side, but it needs to
            // not be frozen.  It's okay if it's moving, since we still want to complete the move.

            // TODO: *Why* do we want to keep the same version number
            // on the other side?  What's wrong with simply restarting
            // at one?
            ep[frozen] = false;
            // While everybody who's helping with the move will set
            // the same value, we have to worry about this thread
            // getting delayed for long enough that not only did the
            // value get moved by another thread, but the entire grow
            // finished, and somebody replaced the moved value with
            // something else.  So we can't just unconditionally move.
            // So instead we try to replace the initial null with this
            // value.  If it fails, that means that somebody else did
            // it.
            r->_slots[i].change(nullptr, ep);
          }
	  i = ruts::increment_to_at_least(_next_to_migrate, i+1).resulting_value();
        }
        // Now everything has been moved.  We might be the first to have finished (or the
        // one who was might have died before installing), so we'll try to install.
        cas_loop_return_value<pointer<segment>> install_res = try_change_value(_table._segments[_num], nc_this, r);
        // If that failed, somebody else got there first... and we might even have grown
        // again.  But that's okay.  We've completed this grow.
        // Even if it succeeded, we can't delete the old one yet, because others are using it.
        // So we'll drop it on the floor for now.  Eventually, we'll probably need to use
        // hazard pointers.
        // In any case, we return the currently-installed segment.
        return install_res.resulting_value();
      }

    public:
      explicit segment(std::size_t n, std::size_t slot_bits, atomic_entry_ptr_alloc_type alloc, table &t)
      : _num(n),
        _table(t),
        _slot_bits(slot_bits),
        _alloc(alloc)
      {
      }

      explicit segment(const pointer<segment> &prior, std::size_t plus_bits)
      : segment(prior->_num,
                prior->_slot_bits+plus_bits,
                prior->_alloc,
                prior->_table)
      {
//        std::cerr << "--- Growing segment " << prior << " (" << prior->_slot_bits << ") "
//            << "into " << this << " (" << _slot_bits << ")." << std::endl;
      }


      pointer<entry_type> find(const key_type &key, hash_type hash) const {
        entry_ptr_type current_entry = slot(hash).contents();
        if (current_entry[frozen]) {
          pointer<segment> new_seg = help_with_grow();
          return new_seg->find(key, hash);
        }
        if (matches(key, current_entry)) {
          return current_entry;
        } else {
          return nullptr;
        }
      }



      bool remove(const key_type &key, hash_type hash) {
        atomic_entry_ptr_type &s = *slot(hash);
        entry_ptr_type ep = s.contents();
        while (true) {
          if (ep[frozen]) {
            pointer<segment> new_seg = help_with_grow();
            return new_seg->remove(key, hash);
          }
          pointer<entry_type> e = ep.pointer();
          if (e == nullptr || e->key != key) {
            return false;
          }
	  auto ur = s.change_using(ep, inc_and_clear_value);
	  if (ur) {
	    return true;
	  }
	  /*
	   * Otherwise somebody changed it, possibly just
	   * to remove the moving flag.  So we'll go around
	   * again and check.  If it's not us, we'll notice
	   * next time.
	   */
	  ep = ur.prior_value;
	}
      }


      void growth_candidate(const key_type &key1,
                            const key_type &key2,
                            pointer<segment> &best,
                            std::size_t &resulting_size,
                            std::size_t &growth)
      {
        // If we're already too big, don't bother.
        if (_slot_bits >= resulting_size) {
          return;
        }
        hash_type h1 = _hash(key1);
        hash_type h2 = _hash(key2);
        // We assume they collide in the current _slot_bits
        hash_type x = (h1 ^ h2) >> (_slot_bits+1);
        for (std::size_t b = _slot_bits+1; b <= resulting_size; b++, x >>= 1) {
          if ((x & 1) != 0) {
            // Found a difference and we know we're not too big.  But we may
            // be big enough that growth matters.
            std::size_t g = b-_slot_bits;
            if (b < resulting_size || g > growth) {
              resulting_size = b;
              growth = g;
              best = this;
            }
            return;
          }
        }


      }

    };

    using segment_alloc_type = meta::rebind_alloc_t<Allocator, segment>;


    class table {
      static const std::size_t n_segments = 1 << n_seg_bits;

      cuckoo_map &_map;
      const side _side;
      const switched_hash _hash;
      std::array<std::atomic<pointer<segment>>, n_segments> _segments;
      table &_other_side = _map.other_table(_side);
      mutable segment_alloc_type _seg_alloc;

      const segment &find_segment(hash_type hash) const {
        std::size_t seg_num = left_bit_field(hash, n_seg_bits);
        pointer<const segment> sp = _segments[seg_num].load();
        return *sp;
      }
      segment &find_segment(hash_type hash) {
        std::size_t seg_num = left_bit_field(hash, n_seg_bits);
        return *(_segments[seg_num].load());
      }

      friend class segment;
      friend class cuckoo_map;
    public:
      template <typename ...Args>
      pointer<segment>
      create_segment(Args&&...args) const{
        pointer<segment> s = _seg_alloc.allocate(1);
        _seg_alloc.construct(s, std::forward<Args>(args)...);
        return s;
      }

      void
      delete_segment(const pointer<segment> &s) const {
        _seg_alloc.destroy(s);
        _seg_alloc.deallocate(s, 1);
      }

      explicit table(cuckoo_map &m, side s, const hash1_fn_type &hash1, const hash2_fn_type hash2, std::size_t seg_slot_bits, Allocator a) :
      _map(m), _side(s), _hash(s, hash1, hash2), _seg_alloc(segment_alloc_type{a})
      {
        int n = 0;
        for (auto &p : _segments) {
          p = create_segment(n++, seg_slot_bits, atomic_entry_ptr_alloc_type{a}, *this);
        }

      }

      table &other_side() const {
        return _other_side;
      }

      slot_ref slot(const key_type &key) {
        hash_type hash = _hash(key);
        segment &seg = find_segment(hash);
        return seg.slot(hash);
      }

      pointer<entry_type> find(const key_type &key) const {
        hash_type hash = _hash(key);
        const segment &seg = find_segment(hash);
        return seg.find(key, hash);
      }

      bool remove(const key_type &key) {
        hash_type hash = _hash(key);
        segment &seg = find_segment(hash);
        return seg.remove(key, hash);
      }
      bool replace_null(const pointer<entry_type> &with) {
        hash_type hash = _hash(with->key);
        segment &seg = find_segment(hash);
        return seg.replace_null(with, hash);
      }

    };

    table _left_table;
    table _right_table;
    mutable entry_alloc_type _entry_alloc;

    table &table_on(side s) {
      return s == side::LEFT ? _left_table : _right_table;
    }

    table &other_table(side s) {
      return s == side::RIGHT ? _left_table : _right_table;
    }

    pointer<entry_type> find(const key_type &key) const {
      pointer<entry_type> e = _left_table.find(key);
      if (e == nullptr) {
        e = _right_table.find(key);
      }
      return e;
    }



    class grow_needed {};

    // Propagates source_grew if it gets one from an accept_move() call
    side
    evict_one(slot_ref &left_source, slot_ref &right_source,
              std::size_t depth, std::size_t max_depth)
    {
      if (depth > max_depth) {
        throw grow_needed{};
      }

      while (1) {
        // we loop until we succeed in moving or until we get told it's impossible

        entry_ptr_type left_current = left_source.contents();
        if (left_current == nullptr && !left_current[frozen]) {
          // there's no point in moving nothing.
          return side::LEFT;
        }
        entry_ptr_type right_current = right_source.contents();
        if (right_current == nullptr &&!right_current[frozen]) {
          // there's no point in moving nothing.
          return side::RIGHT;
        }
        if (left_current[frozen]) {
          throw source_grew{};
        }
        if (right_current[frozen]) {
          throw source_grew{};
        }

        slot_ref left_target = _right_table.slot(left_current->key);
        if (left_target.seg->accept_move(left_source, left_current, left_target)) {
          return side::LEFT;
        }
        slot_ref right_target = _left_table.slot(right_current->key);
        if (right_target.seg->accept_move(right_source, right_current, right_target)) {
          return side::RIGHT;
        }

        // TODO: If one of our targets (the move's sources grew, we need to figure out a new target
        // and retry.  But if our source would have wound up in the same slot in the old and new segments,
        // it's okay
        side rec_call;
        try {
          // This may throw a grow_needed.  We pass it through.
          rec_call = evict_one(right_target, left_target, depth+1, max_depth);
        } catch (source_grew& ex) {
          continue;
        }
        switch (rec_call) {
        case side::LEFT:
          // we cleared out the one on the left, so we try to move the right source
          if (right_target.seg->accept_move(right_source, (right_current = right_source.contents()),
                                            right_target))
          {
            return side::RIGHT;
          }
          break;
        case side::RIGHT:
          // we cleared out the one on the right, so we try to move the left source
          if (left_target.seg->accept_move(left_source, (left_current = left_source.contents()),
                                           left_target))
          {
            return side::LEFT;
          }
          break;
        }
      }
      assert(ruts::fail("infinite loop ended"));
      throw grow_needed{};
    }


    void best_to_grow(pointer<table> t,
                      key_type key,
                      pointer<segment> &best,
                      std::size_t &resulting_size,
                      std::size_t &growth)
    {
      for (std::size_t d = 0; d < max_eviction_depth; d++) {
        slot_ref slot = t->slot(key);
        pointer<entry_type> e = slot.contents();
        if (e == nullptr) {
          // There's an open slot.  No point in continuing.
          best = nullptr;
          return;
        }
        slot.seg->growth_candidate(key, e->key, best, resulting_size, growth);
        key = e->key;
        t = &t->other_side();
      }

    }


    std::pair<pointer<segment>, std::size_t>
    best_to_grow(const key_type &key) {
      pointer<segment> best = nullptr;
      std::size_t resulting_size = 65;
      std::size_t growth = 0;
      best_to_grow(&_left_table, key, best, resulting_size, growth);
      if (best != nullptr) {
        best_to_grow(&_right_table, key, best, resulting_size, growth);
      }
      return std::make_pair(best, growth);
    }

  static entry_ptr_type inc_and_clear_value(entry_ptr_type e) {
    e.pointer() = nullptr;
    e.version()++;
    e[moving] = false;
    return e;
  }

    bool clear_slot(const slot_ref &slot, entry_ptr_type expected, const key_type &key){
      auto ur = slot->inc_and_change(expected, nullptr);
      if (ur) {
        return true;
      } else {
        if (ur.prior_value[frozen]) {
          // The slot started growing after we obtained it.  Help it finish and
          // find a new segment.  (It must have the same segment number.)
          pointer<segment> new_seg = slot.seg->help_with_grow();
          slot_ref new_slot = new_seg->slot(key);
          return clear_slot(new_slot, expected, key);
        }
        pointer<entry_type> pvp = ur.prior_value.pointer();
        // If it's null, that means that somebody else must've removed it (or moved it),
        // but the slot's clear anyway.
        return pvp == nullptr;
      }
    }

    void evict_blocker(const key_type &key) {
      while (true) {
        slot_ref left_slot = _left_table.slot(key);
        slot_ref right_slot = _right_table.slot(key);
        try {
          evict_one(left_slot, right_slot, 0, max_eviction_depth);
          return;
        } catch (source_grew &) {
          continue;
        } catch (grow_needed &) {
          std::pair<pointer<segment>, std::size_t> to_grow = best_to_grow(key);
          if (to_grow.first == nullptr) {
            // If it's null, that means we found a null along the way...Or nothing can be grown,
            // which we assume can't happen.
            continue;
          }
          to_grow.first->grow(to_grow.second);
          return;
        }
      }
    }

    template <typename GFn, typename UFn>
    bool put_in_existing(const key_type &key, replace_return &rr, GFn&& gfn, UFn&&ufn) {
      pointer<entry_type> e = find(key);
      if (e == nullptr) {
        return false;
      } else {
        rr.had_value = true;
        auto guard_fn = [gfn = std::forward<GFn>(gfn)](const value_type &old) {
          return gfn(true, old);
        };
        auto update_fn = [ufn = std::forward<UFn>(ufn)](const value_type &old) {
          return ufn(true, old);
        };
        // if this is no longer there by the time we return, that's
        // okay.  It's as if we did the set just before another thread
        // did the remove.
        auto clrv = ruts::try_cas_loop(e->val, guard_fn, update_fn);
        rr.replaced = clrv.succeeded;
        rr.old_value = clrv.prior_value;
        rr.resulting_value = clrv.resulting_value();
        return true;
      }
    }


    template <typename GFn, typename UFn>
    void evict_and_put(const pointer<entry_type> &e, replace_return &rr, GFn &&gfn, UFn &&ufn) {
      // This should eventually succeed.  (Most of the time, the first or second time around)
      while (true) {
        if (_left_table.replace_null(e)) {
          rr = replace_return(true, false, value_type(), e->val);
          return;
        }
        // It's possible that somebody else put an entry for the same key
        // in the left table since the last time we looked.  This is okay.  It's as
        // if we wrote first and they overwrote.
        if (_right_table.replace_null(e)) {
          rr = replace_return(true, false, value_type(), e->val);
          return;
        }
        evict_blocker(e->key);
        if (put_in_existing(e->key, rr, std::forward<GFn>(gfn), std::forward<UFn>(ufn))) {
          return;
        }
      }

    }

    pointer<entry_type> new_entry(const key_type &key, const value_type &val) const {
      pointer<entry_type> e = _entry_alloc.allocate(1);
      _entry_alloc.construct(e, key, val);
      return e;
    }


    static std::size_t slot_bits_for(std::size_t cap) {
      std::size_t bits = 1;
      std::size_t size = 1<<(n_seg_bits+1);
      while (size < cap) {
        bits++;
        size <<=1;
      }
      return bits;
    }

  public:
    cuckoo_map(const hash1_fn_type &h1, const hash2_fn_type &h2, std::size_t capacity = default_cap, Allocator alloc = Allocator{}) :
      _left_table(*this, side::LEFT, h1, h2, slot_bits_for(capacity), alloc),
      _right_table(*this, side::RIGHT, h1, h2, slot_bits_for(capacity), alloc),
      _entry_alloc(alloc)
      {}

      cuckoo_map(const hash1_fn_type &h1, const hash2_fn_type &h2, Allocator alloc) :
        cuckoo_map(h1, h2, default_cap, alloc)
      {}
    explicit cuckoo_map(std::size_t default_cap, Allocator alloc = Allocator{}) :
        cuckoo_map{hash1_fn_type{}, hash2_fn_type{}, default_cap, alloc}
    {}

    explicit cuckoo_map(Allocator alloc = Allocator{}) :
                cuckoo_map{hash1_fn_type{}, hash2_fn_type{}, default_cap, alloc}
    {}

    bool contains(const key_type &key) const {
      return find(key) != nullptr;
    }

    value_type get(const key_type &key) const {
      pointer<entry_type> e = find(key);
      return e == nullptr ? value_type{} : static_cast<value_type>(e->val);
    }

    bool remove(const key_type &key) {
      // need to go in reverse order just in case the two tables both
      // temporarily hold values (left shadowing right) with different
      // entries.  Removing the shadowing one first would make the other
      // value reappear.
      bool res2 = _right_table.remove(key);
      bool res1 = _left_table.remove(key);
      return res1 || res2;
    }

    template <typename F>
    constexpr static bool is_binary_guard()
    { return meta::is_callable<F(bool, const value_type), bool>::value; }

    template <typename F>
    constexpr static bool is_unary_guard()
    { return meta::is_callable<F(const value_type), bool>::value; }

    template <typename F>
    constexpr static bool is_nullary_guard()
    { return meta::is_callable<F(), bool>::value; }

    template <typename F>
    constexpr static bool is_binary_updater()
    { return meta::is_callable<F(bool, const value_type), value_type>::value; }

    template <typename F>
    constexpr static bool is_unary_updater()
    { return meta::is_callable<F(const value_type), value_type>::value; }

    template <typename F>
    constexpr static bool is_nullary_updater()
    { return meta::is_callable<F(), value_type>::value; }


    template <typename F1>
    static auto updater(F1&& u, std::enable_if_t<is_binary_updater<F1>(), nullptr_t> = nullptr)
    {
      return std::forward<F1>(u);
    }

    template <typename F1, typename F2,
              typename = std::enable_if_t<(is_unary_updater<F1>() && is_nullary_updater<F2>())> >

    static auto updater(F1&& present, F2&& absent)
    {
      return [present = std::forward<F1>(present),
              absent = std::forward<F2>(absent)](bool has_val, const value_type &val) {
        if (has_val) {
          return present(val);
        } else {
          return absent();
        }
      };
    }

    template <typename F1, typename = std::enable_if_t<is_unary_updater<F1>()> >
    static auto updater(F1&& present, const value_type &absent)
    {
      return updater(std::forward<F1>(present), [&](){ return absent; });
    }

    template <typename F1>
    static auto updater(F1&& ufn, std::enable_if_t<is_unary_updater<F1>(), nullptr_t> = nullptr)
    {
      return [ufn = std::forward<F1>(ufn)](bool, const value_type &old) {
        return ufn(old);
      };
    }

    static auto updater(const value_type &val)
    {
      return updater([&](const value_type &old){ return val; });
    }

    template <typename F1>
    static auto guard(F1&& g, std::enable_if_t<is_binary_guard<F1>(), nullptr_t> = nullptr)
    {
      return std::forward<F1>(g);
    }

    template <typename F1, typename F2,
              typename = std::enable_if_t<(is_unary_guard<F1>() && is_nullary_guard<F2>())> >
    static auto guard(F1&& present, F2&& absent)
    {
      return [present = std::forward<F1>(present),
              absent = std::forward<F2>(absent)](bool has_val, const value_type &val) {
        if (has_val) {
          return present(val);
        } else {
          return absent();
        }
      };
    }

    template <typename F1, typename = std::enable_if_t<is_unary_guard<F1>()> >
    static auto guard(F1&& present, bool absent)
    {
      return guard(std::forward<F1>(present), [=]() { return absent; });
    }

    static auto guard(bool present, bool absent)
    {
      return guard([=](){ return present; },
                   [=](){ return absent; });
    }

    template <typename F1>
    static auto guard(F1&& gfn, std::enable_if_t<is_unary_guard<F1>(), nullptr_t> = nullptr)
    {
      return [gfn = std::forward<F1>(gfn)](bool, const value_type &val) {
        return gfn(val);
      };
    }

    template <typename GFn, typename UFn,
              typename = std::enable_if_t<(is_binary_guard<GFn>() && is_binary_updater<UFn>())> >
    replace_return put(const key_type &key, GFn&& guard, UFn&& updater)
    {
      replace_return rr;
      if (!put_in_existing(key, rr, std::forward<GFn>(guard), std::forward<UFn>(updater))
          && std::forward<GFn>(guard)(false, value_type{}))
        {
          pointer<entry_type> e = new_entry(key, std::forward<UFn>(updater)(false, value_type{}));
          evict_and_put(e, rr, std::forward<GFn>(guard), std::forward<UFn>(updater));
        }
      return rr;
    }

    template <typename UFn, typename = std::enable_if_t<is_binary_updater<UFn>()> >
    replace_return put(const key_type &key, UFn&& updater)
    {
      auto guard = [](bool, const value_type &){ return true; };
      return put(key, guard, std::forward<UFn>(updater));
    }

    replace_return put(const key_type &key, const value_type &val) {
      return put(key, updater(val));
    }

    replace_return put_new(const key_type &key, const value_type &val) {
      auto guard = [](bool has_val, const value_type &){ return !has_val; };
      return put(key, guard, updater(val));
    }

    replace_return replace(const key_type &key,
                           const value_type &expected,
                           const value_type &val) {
      pointer<entry_type> e = find(key);
      if (e == nullptr) {
        // if it's not there, we can't replace
        return replace_return(false, false, value_type {});
      }
      auto clrv = ruts::try_change_value(e->val, expected, val);
      return replace_return(clrv, true, clrv.prior_value);
    }

    class reference {
      pointer<cuckoo_map> _map;
      const key_type _key;
    public:
      reference(const pointer<cuckoo_map> &m, const key_type key) : _map(m), _key(key) {}
      bool exists() const {
        return _map->contains(_key);
      }
      operator value_type() const {
        return _map->get(_key);
      }
      reference &operator=(const value_type & val) {
        _map->put(_key, val);
        return *this;
      }

      template <typename X, typename = decltype(std::declval<value_type&>() += std::declval<X>())>
      reference &operator +=(X&& arg) {
        _map->put(_key, updater([arg = std::forward<X>(arg)](value_type old) {
              return old += arg;
            }));
        return *this;
      }
      template <typename VT = value_type, typename = decltype(++std::declval<VT&>())>
      reference &operator ++() {
        _map->put(_key, updater([](value_type old) {
              return ++old;
            }));
        return *this;
      }
      template <typename VT = value_type, typename = decltype(std::declval<VT&>()++)>
      value_type operator ++(int) {
        auto rr = _map->put(_key, updater([](value_type old) {
              old++;
              return old;
            }));
        return rr.old_value;
      }

      template <typename X, typename = decltype(std::declval<value_type&>() -= std::declval<X>())>
      reference &operator -=(X&& arg) {
        _map->put(_key, updater([arg = std::forward<X>(arg)](value_type old) {
              return old -= arg;
            }));
        return *this;
      }
      template <typename VT = value_type, typename = decltype(--std::declval<VT&>())>
      reference &operator --() {
        _map->put(_key, updater([](value_type old) {
              return --old;
            }));
        return *this;
      }
      template <typename VT = value_type, typename = decltype(std::declval<VT&>()--)>
      value_type operator --(int) {
        auto rr = _map->put(_key, updater([](value_type old) {
              old--;
              return old;
            }));
        return rr.old_value;
      }
      
      template <typename X, typename = decltype(std::declval<value_type&>() *= std::declval<X>())>
      reference &operator *=(X&& arg) {
        _map->put(_key, updater([arg = std::forward<X>(arg)](value_type old) {
              return old *= arg;
            }));
        return *this;
      }
      template <typename X, typename = decltype(std::declval<value_type&>() /= std::declval<X>())>
      reference &operator /=(X&& arg) {
        _map->put(_key, updater([arg = std::forward<X>(arg)](value_type old) {
              return old /= arg;
            }));
        return *this;
      }
      template <typename X, typename = decltype(std::declval<value_type&>() %= std::declval<X>())>
      reference &operator %=(X&& arg) {
        _map->put(_key, updater([arg = std::forward<X>(arg)](value_type old) {
              return old %= arg;
            }));
        return *this;
      }
      template <typename X, typename = decltype(std::declval<value_type&>() &= std::declval<X>())>
      reference &operator &=(X&& arg) {
        _map->put(_key, updater([arg = std::forward<X>(arg)](value_type old) {
              return old &= arg;
            }));
        return *this;
      }
      template <typename X, typename = decltype(std::declval<value_type&>() |= std::declval<X>())>
      reference &operator |=(X&& arg) {
        _map->put(_key, updater([arg = std::forward<X>(arg)](value_type old) {
              return old |= arg;
            }));
        return *this;
      }
      template <typename X, typename = decltype(std::declval<value_type&>() ^= std::declval<X>())>
      reference &operator ^=(X&& arg) {
        _map->put(_key, updater([arg = std::forward<X>(arg)](value_type old) {
              return old ^= arg;
            }));
        return *this;
      }
      template <typename X, typename = decltype(std::declval<value_type&>() <<= std::declval<X>())>
      reference &operator <<=(X&& arg) {
        _map->put(_key, updater([arg = std::forward<X>(arg)](value_type old) {
              return old <<= arg;
            }));
        return *this;
      }
      template <typename X, typename = decltype(std::declval<value_type&>() >>= std::declval<X>())>
      reference &operator >>=(X&& arg) {
        _map->put(_key, updater([arg = std::forward<X>(arg)](value_type old) {
              return old >>= arg;
            }));
        return *this;
      }

    };

    std::pair<bool, value_type> lookup(const key_type &key) {
      pointer<entry_type> e = find(key);
      if (e == nullptr) {
        return std::make_pair(false, value_type());
      } else {
        return std::make_pair(true, e->val.load());
      }
    }

    reference operator[](const key_type &key) {
      return reference(this, key);
    }

    value_type operator[](const key_type &key) const {
      return get(key);
    }

    reference at(const key_type &key) {
      return reference(this, key);
    }

    value_type at(const key_type &key) const {
      return get(key);
    }

  };


  template <typename K, typename V, typename Hash1=ruts::hash1<K>, typename Hash2=ruts::hash2<K>,
      typename Allocator = std::allocator<V>>
      class small_cuckoo_map : public cuckoo_map<K,V,Hash1,Hash2,0,Allocator>
  {
    using base = cuckoo_map<K,V,Hash1,Hash2,0,Allocator>;
    using typename base::hash1_fn_type;
    using typename base::hash2_fn_type;
  public:
    constexpr static std::size_t default_cap = 16;
    small_cuckoo_map(const hash1_fn_type &h1, const hash2_fn_type &h2, std::size_t capacity = default_cap, Allocator alloc = Allocator{}) :
      base(h1, h2, default_cap, alloc)
  {}

    small_cuckoo_map(const hash1_fn_type &h1, const hash2_fn_type &h2, Allocator alloc) :
        small_cuckoo_map(h1, h2, default_cap, alloc)
      {}
    explicit small_cuckoo_map(std::size_t default_cap, Allocator alloc = Allocator{}) :
        small_cuckoo_map{hash1_fn_type{}, hash2_fn_type{}, default_cap, alloc}
    {}

    explicit small_cuckoo_map(Allocator alloc = Allocator{})
    : small_cuckoo_map{hash1_fn_type{}, hash2_fn_type{}, default_cap, alloc}
    {}


  };


  template <typename K, typename V, typename Hash1, typename Hash2, std::size_t SegBits, typename Allocator>
  constexpr typename cuckoo_map<K,V,Hash1,Hash2,SegBits,Allocator>::entry_ptr_type::template flag_id<0>
  cuckoo_map<K,V,Hash1,Hash2,SegBits,Allocator>::moving;

  template <typename K, typename V, typename Hash1, typename Hash2, std::size_t SegBits, typename Allocator>
  constexpr typename cuckoo_map<K,V,Hash1,Hash2,SegBits,Allocator>::entry_ptr_type::template flag_id<1>
  cuckoo_map<K,V,Hash1,Hash2,SegBits,Allocator>::frozen;


}



#endif /* CUCKOO_MAP_H_ */
