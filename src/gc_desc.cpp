/*
 *
 *  Multi Process Garbage Collector
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#include <algorithm>
#include "ruts/versioned_ptr.h"
#include "mpgc/gc_desc.h"
#include "mpgc/gc.h"
#include "ruts/util.h"

namespace mpgc {

  constexpr gc_descriptor::bool_field gc_descriptor::is_compact_fld;
  constexpr gc_descriptor::bool_field gc_descriptor::is_array_fld;
  constexpr gc_descriptor::size_field gc_descriptor::check_bits_fld;
  constexpr gc_descriptor::bool_field gc_descriptor::is_bitmap_fld;

  constexpr gc_descriptor::size_field gc_descriptor::bitmap_size_fld;
  constexpr gc_descriptor::size_field gc_descriptor::bitmap_map_fld;

  constexpr gc_descriptor::bool_field gc_descriptor::include_fields_fld;
  constexpr gc_descriptor::size_field gc_descriptor::n_fields_fld;



  constexpr gc_descriptor::size_field gc_descriptor::blob_size_fld;
  constexpr gc_descriptor::size_field gc_descriptor::l1_size_fld;
  constexpr gc_descriptor::size_field gc_descriptor::l1_f1_fld;
  
  constexpr std::size_t gc_descriptor::list_width[];


  /**
   * The possible types of external_descriptor.
   *
   * Used by gc_allocated with virtuals as a discriminator for external_descriptor.
   */
  enum external_descriptor_disc {
    include_list /**< The object is an include_list_external_descriptor*/
  };

  /**
   * A gc_allocated object representing a type too complicated to
   * describe in a single word.
   *
   * An external_descriptor contains the number of fields (#n_fields)
   * and a check pointer referring to itself (#check).  It
   * enumerates references via a (pseudo-)virtual for_each_ref_index()
   * method.
   *
   * @sa gc_descriptor

   */
  class gc_descriptor::external_descriptor
      : public gc_allocated_with_virtuals<external_descriptor, external_descriptor_disc>
  {
    using base = gc_allocated_with_virtuals<external_descriptor, external_descriptor_disc>;
  public:
    /**
     * The gc_allocated_with_virtuals dispatch object for external_descriptor.
     */
    struct virtuals : virtuals_base {
      virtual void for_each_ref_index(const external_descriptor *self,
                                      const std::function<void(std::size_t)> &fn) const = 0;
      virtual void desc_refs(const external_descriptor *self) const = 0;
    };
    /**
     * A (pseudo-)virtual function that applies a function to each
     * index that holds a GC reference.
     *
     * @param fn a function that can take a `std::size_t`.
     *
     * The field indexes in the desribed object that contain (possibly
     * null) GC pointers are enumerated and passed to the given
     * function.
     * @pure
     */
    void for_each_ref_index(const std::function<void(std::size_t)> &fn) const {
      call_virtual(this, &virtuals::for_each_ref_index, fn);
    }
    /**
     * A (pseudo-)virtual function used to describe the contents of the object.
     *
     * Called by gc_descriptor::trace().
     * @pure
     */
    void desc_refs() const {
      call_virtual(this, &virtuals::desc_refs);
    }

    /**
     * The number of fields contained in the described object.
     */
    const std::size_t n_fields;
    /**
     * An offset_ptr referring to this object, for validity checking.
     */
    offset_ptr<external_descriptor> check = this;
    
    /**
     * @param gc the GC token needed for MPGC heap allocation
     * @param nf the number of fields in the object.
     * @param d the external_descriptor_disc identifying the concrete class.
     */
    external_descriptor(gc_token &gc, std::size_t nf, discriminator_type d) 
      : base(gc,d),
        n_fields(nf)
    {}

    /**
     * @returns a reference to the object descriptor for external_descriptor.
     */
    static const auto &descriptor() {
      using this_type = external_descriptor;
      static gc_descriptor dd = 
	GC_DESC(this_type)
        .WITH_SUPER(base)
	.WITH_FIELD(&this_type::n_fields)
	.WITH_FIELD(&this_type::check);
      return dd;
    }

  };


  static_assert(zero_init_okay<offset_ptr<gc_descriptor::external_descriptor>>::value,
                "offset_ptr not zero-initializable");
  static_assert(zero_init_okay<gc_ptr<gc_descriptor::external_descriptor>>::value,
                "gc_ptr not zero-initializable");
  static_assert(zero_init_okay<std::atomic<gc_ptr<gc_descriptor::external_descriptor>>>::value,
                "atomic<gc_ptr> not zero-initializable");


  /**
   * A concrete subclass of external_descriptor that stores the
   * indices of reference fields in a gc_array.
   */
  class gc_descriptor::include_list_external_descriptor : public external_descriptor
  {
  public:
    /**
     * The discriminator value for include_list_external_descriptor.
     */
    static constexpr discriminator_type discrim = external_descriptor_disc::include_list;
    
    /**
     * The list of reference indices.
     */
    const gc_array_ptr<std::size_t> ref_fields;
    
    /**
     * Create an include_list_external_descriptor given a range.
     * @tparam Iter an iterator type.  More efficient if it's a random-access iterator.
     * @param gc the GC token needed for MPGC heap allocation
     * @param nf the number of fields in the object.
     * @param from,to the bounds of the range.
     * @param d the external_descriptor_disc identifying the concrete class.
     */
    template <typename Iter>
    include_list_external_descriptor(gc_token &gc, std::size_t nf, Iter from, Iter to,
                                     discriminator_type d = discrim) 
      : external_descriptor(gc, nf, d),
	ref_fields(make_gc_array<std::size_t>(from, to))
    {}

    /**
     * @returns a reference to the object descriptor for include_list_external_descriptor.
     */
    static const auto &descriptor() {
      using this_type = include_list_external_descriptor;
      static gc_descriptor dd = 
	GC_DESC(this_type)
        .WITH_SUPER(external_descriptor)
	.WITH_FIELD(&this_type::ref_fields)
	;
      return dd;
    }

    /**
     * The gc_allocated_with_virtuals dispatch object for include_list_external_descriptor.
     */
    struct virtuals : external_descriptor::virtuals {
      using impl = include_list_external_descriptor;
      virtual void for_each_ref_index(const external_descriptor *self,
                                      const std::function<void(std::size_t)> &fn) const override {
        self->call_non_virtual(&impl::for_each_ref_index_impl, fn);
      }
      virtual void desc_refs(const external_descriptor *self) const override {
        self->call_non_virtual(&impl::desc_refs_impl);
      }
    };

    /**
     * The implementation of for_each_ref_index().
     *
     * @param fn a function that can take a `std::size_t`.
     *
     * Applies `fn` to each index in #ref_fields.
     */
    void for_each_ref_index_impl(const std::function<void(std::size_t)> &fn) const {
      for (std::size_t i : ref_fields) {
        fn(i);
      }
    }

    /**
     * The implementation of desc_refs().
     *
     * Prints `ref =` _index_ for each index in #ref_fields.
     */
    void desc_refs_impl() const {
      using namespace std;
      for (std::size_t i : ref_fields) {
	cout <<  "      ref = " << i << endl;
      }
    }
    
  };


  /**
   * Create an external_descriptor and return a gc_descriptor
   * containing it.
   *
   * @returns a gc_descriptor containing a newly created
   * external_descriptor.
   *
   * The external_descriptor is (currently) necessarily an
   * include_list_external_descriptor.
   *
   * @note We assume that the gc_descriptor that we return will be
   * stored in a static variable, and we need to make sure that the
   * actual external_descriptor outlives the value in the static,
   * since we don't want the external_descriptor collected while the
   * gc_descriptor still refers to it (since values in statics are not
   * traced).  So what we do is simply leak an external_gc_ptr to it
   * (by creating it on the process heap and forgetting about it).
   * This ensures that the external_gc_ptr will live until the process
   * exits, at which point, the process's external_gc_ptr pointers
   * will no longer be roots.
   */

  gc_descriptor ref_field_collector__::make_external() const {
    using edt = gc_descriptor::include_list_external_descriptor;
    gc_ptr<gc_descriptor::external_descriptor> ed 
      = make_gc<edt>(n_fields, field_offsets.cbegin(), field_offsets.cend());
    auto ptr __attribute__((unused))
      = new external_gc_ptr<gc_descriptor::external_descriptor>(ed);
    return gc_descriptor(gc_descriptor::as_indirect{}, ed.as_offset_pointer());
  }

  /**
   * Convert the list of reference fields to a gc_descriptor.
   *
   * @returns a gc_descriptor.
   *
   * The following logic is used (where `nrefs` is the size of the
   * #field_offsets vector):
   *
   * + If `nrefs` is zero, return a blob with #n_fields fields.
   *
   * + If `nrefs =` #n_fields (all of the fields are reference
   * fields), return a reference array (a zero-length exclude list
   * descriptor with #n_fields fields).
   *
   * + If there are no more than 8 reference fields, construct a
   * gc_descriptor as an include list descriptor.  (This may fail if
   * #n_fields is too big).  Do not return it yet.
   *
   * + If there are no more than 8 reference fields missing from the
   * fields and there are fewer missing than there, construct a
   * gc_descriptor as an exclude list descriptor.  (This may fail if
   * #n_fields is too big.)
   *
   *   - If this succeeds, return the exclude list descriptor.
   *
   * + If we get here and we have an include list descriptor, return
   * it.
   *
   * + If there are no more than 32 fields, construct and return a
   * bitmap descriptor.
   *
   * + Otherwise construct and return an external descriptor by
   * calling make_external().
   */
  gc_descriptor ref_field_collector__::to_descriptor() {
    //    check_coverage();
    using rep_type = gc_descriptor::rep_type;
    const std::size_t nrefs = field_offsets.size();

    if (nrefs == 0) {
      // We'll assume for now that it will fit.  If not, the vector
      // itself probably wouldn't fit.
      return gc_descriptor::blob(n_fields);
    }
    if (nrefs == n_fields) {
      // ditto
      rep_type r = gc_descriptor::list_rep(n_fields, 0, false, 
					   field_offsets.cend(), field_offsets.cend());
      return gc_descriptor(gc_descriptor::direct(), r);
    }

    if (nrefs > 1) {
      std::sort(field_offsets.begin(), field_offsets.end());
    }

    rep_type pos_list = nrefs > 8 ? 0 
      : gc_descriptor::list_rep(n_fields, nrefs, true, 
				field_offsets.cbegin(), field_offsets.cend());
    std::size_t n_missing = n_fields-nrefs;
    if (n_missing < 8 && n_missing < nrefs) {
      // We don't do the work to figure out negative fields unless it
      // will be better to do so.
      std::vector<std::size_t> missing;
      missing.reserve(n_missing);
      std::size_t i = 0;
      for (size_t next_skip : field_offsets) {
	for (; i<next_skip; i++) {
	  missing.push_back(i);
	}
	i++;
      }
      for (; i < n_fields; i++) {
	missing.push_back(i);
      }
      rep_type neg_list = gc_descriptor::list_rep(n_fields, n_missing, false, 
						  missing.cbegin(), 
						  missing.cend());
      if (neg_list != 0) {
	// We have one and it's smaller than the positive one.
	return gc_descriptor(gc_descriptor::direct(), neg_list);
      }
    }
    if (pos_list != 0) {
      // Okay, use the positive one if it exists.
      return gc_descriptor(gc_descriptor::direct(), pos_list);
    }
    if (n_fields <= 32) {
      assert(false);
      return gc_descriptor(gc_descriptor::direct(), 
			   gc_descriptor::bitmap_rep(n_fields,
						     field_offsets.cbegin(), 
						     field_offsets.cend()));
    }
    // Nothing for it but to do an external one.
    return make_external();
  }

  offset_ptr<const gc_descriptor::external_descriptor>
  gc_descriptor::as_external_descriptor() const {
    // TODO: This is a kludge.
    if (base_offset_ptr::could_be_offset_ptr(_rep)) {
      return offset_ptr<const external_descriptor>(_rep);
    } else {
      return nullptr;
    }
  }

  bool gc_descriptor::external_is_valid() const {
    offset_ptr<const external_descriptor> ep = as_external_descriptor();
    return ep.is_valid() && ep->check == ep;
  }

  std::size_t
  gc_descriptor::external_object_size() const {
    return as_external_descriptor()->n_fields;
  }

  void
  gc_descriptor::external_for_each_ref_index(const std::function<void(std::size_t)> &fn) const {
    auto ep = as_external_descriptor();
    ep->for_each_ref_index(fn);
  }

  void gc_descriptor::trace(const char *type_name) const {
    using namespace std;
    using namespace ruts;
    cout << "GC descriptor for " << type_name << endl;
    {
      reset_flags_on_exit reset(cout);
      cout << "        rep = " << hex << _rep << endl;
    }
    cout << "    n words = " << object_n_fields() << endl;
    cout << "   is blob? = " << is_blob() << endl;
    cout << "  is array? = " << is_array() << endl;
    cout << "       size = " << object_size() << endl;
    cout << "    Address = " << this << endl;

    switch (category()) {
    case cat::illegal:
      {
        cout << "  ILLEGAL!" << endl;
        break;
      }
    case cat::external:
      {
        cout << "  EXTERNAL: " << endl;
        auto ep = as_external_descriptor();
        cout << "     size = " << ep->n_fields << endl;
        ep->desc_refs();
        break;
      }
    case cat::bitmap:
      {
        cout << "    BITMAP: " << endl;
        cout << "     size = " << bitmap_size_fld[_rep] << endl;
        {
          reset_flags_on_exit reset(cout);
          cout << hex;
          cout << "      map = " << bitmap_map_fld[_rep] << endl;
        }
        break;
      }
    case cat::list:
      {
        cout << "      LIST: " << endl;
        size_t nr = n_fields_fld[_rep];
        cout << " include? = " << (include_fields_fld[_rep] ? "include" : "exclude") << endl;
        cout << "   n refs = " << nr << endl;
        size_t w = list_width[nr];
        const char *tag = "     size = ";
        size_t shift = list_base-w;
        for (size_t i=0; i<= nr; i++, shift-=w) {
          cout << tag << size_field(shift, w)[_rep] << endl;
          tag = "      ref = ";
        }
        break;
      }
    default:
      assert(false);
    }
  }

  void gc_descriptor::deep_validity_check() const {
    using namespace std;
    gc_descriptor d = *this;
    assert(&d==&d);
    assert(trace_on_false(base_offset_ptr::is_valid(this+object_size() - 1),
			  []{cout << "size goes past end of heap" << endl;}));
    size_t nf = object_n_fields();
    switch (category()) {
    case cat::external:
      // We assume that the full pointer check in the external_descriptor is sufficient.
      return;
    case cat::bitmap:
      {
        size_t map = bitmap_map_fld[_rep];
        size_t mask = size_t(-1) << nf;
        assert(trace_on_false((map & mask) == 0,
                              []{cout << "mask has too many bits for nfields" << endl;}));
        return;
      }
    case cat::list:
      {
        size_t nr = n_fields_fld[_rep];
        size_t w = list_width[nr];
        size_t next_possible = 0;
        size_t shift = list_base-2*w;
        for (size_t i=1; i<= nr; i++, shift-=w) {
          size_t f = size_field(shift, w)[_rep];
          assert(trace_on_false(f < nf,
                                [&]{cout << "field " << f << " too big" << endl;}));
          assert(trace_on_false(f >= next_possible,
                                [&]{cout << "field " << f << " not in order" << endl;}));
          next_possible = f+1;
        }
        return;
      }
    case cat::illegal:
    default:
      assert(false);
      break;
    }
  }

  template <>
  void gc_allocated_with_virtuals<gc_descriptor::external_descriptor,
                                  external_descriptor_disc>
  ::init_vf_table(vf_table &ctable) {
    ctable.bind<gc_descriptor::include_list_external_descriptor>();
  }

}
